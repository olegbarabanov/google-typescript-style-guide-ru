<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Google TypeScript - руководство по стилю написания кода</title>
<link rel="stylesheet" href="javaguide.css">
<script src="include/styleguide.js"></script>
<link rel="shortcut icon" href="https://www.google.com/favicon.ico">
<script src="include/jsguide.js"></script>
</head>
<body onload="initStyleGuide();">
<div id="content">
<h1>Google TypeScript - руководство по стилю написания кода</h1>
<h1>TypeScript - руководство по стилю написания кода</h1>

<section>
  Это внешнее руководство, основанное на внутренней версии Google, но адаптированное для более широкой аудитории. There is no automatic deployment process for this version as it's pushed on-demand by volunteers.

<p>В нем содержатся как правила, так и лучшие практики. Выберите те, которые лучше всего подходят для вашей команды.</p>
</section>

<p>Данное руководство ссылается на терминологию стандарта <a href="http://tools.ietf.org/html/rfc2119">RFC 2119</a> при использовании фраз <em>ДОЛЖНЫ</em>, <em>НЕ ДОЛЖНЫ</em>, <em>РЕКОМЕНДУЕТСЯ</em>, <em>НЕ РЕКОМЕНДУЕТСЯ</em>, и <em>ВОЗМОЖНО</em>.
  All examples given are non-normative and serve only to illustrate the normative
  language of the style guide.</p>

<h2 id="syntax">Синтаксис</h2>

<h3 id="identifiers">Идентификаторы</h3>

<p>Идентификаторы должны использовать только ASCII символы, цифры, символы подчеркивания (для констант и названий методов структурных тестов) и знак '\('. Таким образом, каждое допустимое имя идентификатора соответствует регулярному выражению `[\)\w]+`.</p>

<table>
<thead>
<tr>
<th>Стиль</th>
<th>Категория</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>UpperCamelCase</code>
</td>
<td>класс / интерфейс / тип / перечисление / декоратор / параметр типа</td>
</tr>
<tr>
<td><code>lowerCamelCase</code>
</td>
<td>переменная / параметр / функция / метод / свойство / module alias</td>
</tr>
<tr>
<td><code>CONSTANT_CASE</code></td>
<td>глобальные константы, включая имена элементов перечислений</td>
</tr>
<tr>
<td><code>#ident</code></td>
<td>идентификаторы приватного доступа никогда не используются.</td>
</tr>
</tbody>
</table>

<ul>
<li><p><strong>Аббревиатуры</strong>:
Относитесь к аббревиатурам, подобным акронимам, в наименовании как к целым словам, т.е. используйте 
<code>loadHttpUrl</code>, а не <del><code>loadHTTPURL</code></del>, unless required by a platform name
(например <code>XMLHttpRequest</code>).</p></li>
<li><p><strong>Знак доллара</strong>: В идентификаторах, как правило, <em>не рекомендуется</em> использовать символ <code>$</code>, за исключением случаев, когда это соответствуют соглашениям об именовании для сторонних фреймворков.
<a href="#naming-style">See below</a> for more on using <code>$</code> with <code>Observable</code> values.</p></li>
<li><p><strong>Параметры типа</strong>: Параметры типов, как например в <code>Array&lt;T&gt;</code>, могут использовать один символ верхнего регистра (<code>T</code>) или <code>UpperCamelCase</code>.</p></li>
<li><p><strong>Названия тестов</strong>: Название тестовых методов в Closure <code>testSuite</code> и подобных тестовых фреймворках в стиле xUnit могут быть представлены с разделителями <code>_</code>, например <code>testX_whenY_doesZ()</code>.</p></li>
<li><p><strong><code>_</code> префикс/суффикс</strong>: Идентификаторы не должны использовать <code>_</code> в качестве префикса или суффикса.</p>
<p>Это также означает что символ <code>_</code> сам по себе не должен быть использован в качестве идентификатора (например, чтобы указать, что параметр не используется).</p></li>
</ul>

<blockquote>
  <p>Совет: Если вам нужны только некоторые элементы из массива (или TypeScript кортежа), вы можете вставить дополнительные запятые в выражение деструктуризации, чтобы игнорировать промежуточные элементы:</p>

<pre><code class="language-ts">const [a, , b] = [1, 5, 10];  // a &lt;- 1, b &lt;- 10
</code></pre>
</blockquote>

<ul>
<li><p><strong>Imports</strong>: Module namespace imports are <code>lowerCamelCase</code> while files are
<code>snake_case</code>, which means that imports correctly will not match in casing
style, such as</p>

<pre><code class="language-ts good">import * as fooBar from './foo_bar';
</code></pre>

<p>Some libraries might commonly use a namespace import prefix that violates
this naming scheme, but overbearingly common open source use makes the
violating style more readable. The only libraries that currently fall under
this exception are:</p>

<ul>
<li><a href="https://jquery.com/">jquery</a>, использует <code>$</code> как префикс</li>
<li><a href="https://threejs.org/">threejs</a>, использует <code>THREE</code> как префикс</li>
</ul></li>
<li><p><strong>Константы</strong>: <code>CONSTANT_CASE</code> указывает на то, что значение <em>не предназначено</em> для изменений и может быть использовано для тех значений, что могут быть изменены технически (т.е. значений, которые не являются глубоко замороженными) но не должны изменяться пользователями.</p>

<pre><code class="language-ts good">const UNIT_SUFFIXES = {
  'milliseconds': 'ms',
  'seconds': 's',
};
// Несмотря на то, что в соответствии с правилами JavaScript UNIT_SUFFIXES является изменяемым,
// верхний регистр символов обозначает для пользователей, что они не должны изменять значения.
</code></pre>

<p>Константой также может быть статическое свойство класса, которое предназначенно только для чтения (<code>static readonly</code>) .</p>

<pre><code class="language-ts good">class Foo {
  private static readonly MY_SPECIAL_NUMBER = 5;

  bar() {
    return 2 * Foo.MY_SPECIAL_NUMBER;
  }
}
</code></pre>

<p>Если во время работы программы значение создается более одного раза, или если пользователи каким-либо образом изменяют его, то для этого должен использоваться <code>lowerCamelCase</code> стиль.</p>

<p>Если значение представляет собой стрелочную функцию которая реализует интерфейс, тогда это может быть обьявлено в <code>lowerCamelCase</code> стиле.</p></li>
</ul>

<h4 id="aliases">Псевдонимы</h4>

<p>When creating a local-scope alias of an existing symbol, use the format of the
existing identifier. The local alias must match the existing naming and format
of the source. For variables use <code>const</code> for your local aliases, and for class
fields use the <code>readonly</code> attribute.</p>

<pre><code class="language-ts good">
const {Foo} = SomeType;
const CAPACITY = 5;

class Teapot {
  readonly BrewStateEnum = BrewStateEnum;
  readonly CAPACITY = CAPACITY;
}
</code></pre>

<h4 id="naming-style">Стиль именования</h4>

<p>TypeScript expresses information in types, so names <em>should not</em> be decorated
with information that is included in the type. (See also
<a href="https://testing.googleblog.com/2017/10/code-health-identifiernamingpostforworl.html">Testing Blog</a>
 for more about what
not to include.)</p>

<p>Несколько конкретных примеров для этого правила:</p>

<ul>
<li>Не используйте начальные или завершащие символы подчеркивания для приватных свойств или методов.</li>
<li>Не используйте префикс <code>opt_</code> для необязательных параметров.
<ul>
<li>Для аксессоров, см. ниже <a href="#getters-and-setters-accessors">правила использования аксессоров</a>.</li>
</ul></li>
<li>Do not mark interfaces specially (<del><code>IMyInterface</code></del> or
<del><code>MyFooInterface</code></del>) unless it's idiomatic in its
environment. When
introducing an interface for a class, give it a name that expresses why the
interface exists in the first place (e.g. <code>class TodoItem</code> and <code>interface
TodoItemStorage</code> if the interface expresses the format used for
storage/serialization in JSON).</li>
<li>Suffixing <code>Observable</code>s with <code>$</code> is a common external convention and can
help resolve confusion regarding observable values vs concrete values.
Judgement on whether this is a useful convention is left up to individual
teams, but <em>should</em> be consistent within projects.</li>
</ul>

<h4 id="descriptive-names">Описательные названия</h4>

<p>Названия <em>должны</em> быть описательными и ясными для новых читателей. Не используйте аббревиатуры, которые могут быть незнакомыми или двусмысленными для читателей за пределами вашего проекта и не сокращайте, удаляя в словах буквы.</p>

<ul>
<li><strong>Исключение</strong>: Для переменных, область действия которых составляет не более 10 строк, включая аргументы, которые <em>не</em> являются частью экспортируемого API, <em>возможно</em> использование коротких (например, однобуквенных) имен переменных.</li>
</ul>

<h3 id="file-encoding-utf-8">Кодировка файлов: UTF-8</h3>

<p>Для символов, отличных от ASCII, используйте фактический символ Юникода (например <code>∞</code>). Для непечатаемых символов можно использовать эквивалентный шестнадцатеричный код или экранирование Unicode-символов (например <code>\u221e</code>) вместе с пояснительным комментарием.</p>

<pre><code class="language-ts good">// Совершенно ясно даже без комментария
const units = 'μs';

// Используйте Unicode-экранирование для непечатаемых символов
const output = '\ufeff' + content; // это маркер последовательности байтов (Unicode BOM)
</code></pre>

<pre><code class="language-ts bad">// Даже с комментарием, это сложно для чтения и подвержено потенциальным ошибкам.
const units = '\u03bcs'; // Греческая буква mu, 's'

// Читающий код не поймет, что это такое
const output = '\ufeff' + content;
</code></pre>

<h3 id="comments-documentation">Комментарии &amp; Документация</h3>

<h4 id="jsdoc-vs-comments">Использование JSDoc в сравнении с обычными комментариями</h4>

<p>Существует два типа комментариев, JSDoc (<code>/** ... */</code>) и не относящиеся к JSDoc обычные комментарии (<code>// ...</code> или <code>/* ... */</code>).</p>

<ul>
<li>Используйте <code>/** JSDoc */</code> комментарии для документации. Это те комментарии, с которыми стоит ознакомиться при использовании кода.</li>
<li>Используйте <code>// строчные комментарии</code> для комментирования реализации. Эти комментарии которые касаются только реализации самого кода.</li>
</ul>

<p>Комментарии JSDoc могут распознаваться различными программными инструментами, такими как редакторы кода и генераторы документации, в то время как обычные комментарии могут быть распознаны только другими людьми.</p>

<h4 id="jsdoc-rules-follow-the-javascript-style">Правила JSDoc соответствуют стилю языка JavaScript</h4>

<p>В общих чертах, следуйте <a href="https://google.github.io/styleguide/jsguide.html#jsdoc">правилам для JSDoc из руководства по стилю написания JavaScript</a>, разделы 7.1 - 7.5. В остальной части этого раздела описываются исключения из этих правил.</p>

<h4 id="document-all-top-level-exports-of-modules">Document all top-level exports of modules</h4>

<p>Используйте <code>/** JSDoc */</code> комментарии для передачи информации пользователям вашего кода. Избегайте простого повторения имени свойства или параметра. Вам <em>рекомендуется</em> документировать все свойства и методы (экспортируемые/публичные или нет), назначение которых, по мнению вашего рецензента, не сразу очевидно из их названия.</p>

<p>Exception: Symbols that are only exported to be consumed by tooling, such as
@NgModule classes, do not require comments.</p>

<h4 id="omit-comments-that-are-redundant-with-typescript">Исключите те комментарии, которые излишни в TypeScript</h4>

<p>Для примера, не указывайте типы в <code>@param</code> или <code>@return</code> блоках, не пишите
<code>@implements</code>, <code>@enum</code>, <code>@private</code> в коде, который использует <code>implements</code>,
<code>enum</code>, <code>private</code> и пр. ключевые слова.</p>

<h4 id="do-not-use-override">Не используйте <code>@override</code></h4>

<p>Не используйте <code>@override</code> в исходном коде TypeScript.</p>

<p><code>@override</code> is not enforced by the compiler, which is surprising and leads to
annotations and implementation going out of sync. Including it purely for
documentation purposes is confusing.</p>

<h4 id="redundant-comments">Делайте комментарии, которые действительно добавляют информацию</h4>

<p>For non-exported symbols, sometimes the name and type of the function or
parameter is enough. Code will <em>usually</em> benefit from more documentation than
just variable names though!</p>

<ul>
<li><p>Избегайте комментариев, в которых просто повторяется имя и тип параметра.</p>

<pre><code class="language-ts bad">/** @param fooBarService Сервис "The Bar" для приложения "the Foo". */
</code></pre></li>

<li><p>Исходя из этого правила, строки <code>@param</code> и <code>@return</code> требуются только тогда, когда они добавлявляют новую информацию, а иначе их можно исключить.</p>

<pre><code class="language-ts good">/**
 * POSTs the request to start coffee brewing.
 * @param amountLitres The amount to brew. Must fit the pot size!
 */
brew(amountLitres: number, logger: Logger) {
  // ...
}
</code></pre></li>
</ul>

<h4 id="parameter-property-comments">Комментарии к свойствам параметров</h4>

<p>A parameter property is when a class declares a field and a constructor
parameter in a single declaration, by marking a parameter in the constructor.
E.g. <code>constructor(private readonly foo: Foo)</code>, declares that the class has a
<code>foo</code> field.</p>

<p>To document these fields, use JSDoc's <code>@param</code> annotation. Editors display the
description on constructor calls and property accesses.</p>

<pre><code class="language-ts good">/** This class demonstrates how parameter properties are documented. */
class ParamProps {
  /**
   * @param percolator The percolator used for brewing.
   * @param beans The beans to brew.
   */
  constructor(
    private readonly percolator: Percolator,
    private readonly beans: CoffeeBean[]) {}
}
</code></pre>

<pre><code class="language-ts good">/** This class demonstrates how ordinary fields are documented. */
class OrdinaryClass {
  /** The bean that will be used in the next call to brew(). */
  nextBean: CoffeeBean;

  constructor(initialBean: CoffeeBean) {
    this.nextBean = initialBean;
  }
}
</code></pre>

<h4 id="comments-when-calling-a-function">Комментарии при вызове функции </h4>

<p>При необходимости, документируйте параметры в местах вызова при помощи встраивания блочных комментариев.
   При этом нет каких-либо четких правил, касательно точного форматирования и размещения комментария.
   Также рассмотрите возможность применения именованных параметров с использованием литералов объекта и деструктуризации.</p>

<pre><code class="language-ts good">// Встраивание блочных комментариев для параметров, которые трудны для понимания:
new Percolator().brew(/* amountLitres= */ 5);
// Также рассмотрите возможность использования именованных аргументов и деструктуризации параметров (в объявлении метода "brew"):
new Percolator().brew({amountLitres: 5});
</code></pre>

<pre><code class="language-ts good">/** An ancient {@link CoffeeBrewer} */
export class Percolator implements CoffeeBrewer {
  /**
   * Сварить кофе.
   * @param amountLitres Количество, которое надо сварить. Должен соответствовать объему кофейника!
   */
  brew(amountLitres: number) {
    // Так или иначе, эта реализация создает ужасный кофе.
    // TODO(b/12345): Улучшить процесс варки кофе в кофеварке.
  }
}
</code></pre>

<h4 id="place-documentation-prior-to-decorators">Размещайте документацию перед декораторами</h4>

<p>When a class, method, or property have both decorators like <code>@Component</code> and
JsDoc, please make sure to write the JsDoc before the decorator.</p>

<ul>
<li><p>Do not write JsDoc between the Decorator and the decorated statement.</p>

<pre><code class="language-ts bad">@Component({
  selector: 'foo',
  template: 'bar',
})
/** Component that prints "bar". */
export class FooComponent {}
</code></pre></li>
<li><p>Write the JsDoc block before the Decorator.</p>

<pre><code class="language-ts good">/** Component that prints "bar". */
@Component({
  selector: 'foo',
  template: 'bar',
})
export class FooComponent {}
</code></pre></li>
</ul>

<h2 id="language-rules">Языковые правила</h2>

<h3 id="visibility">Видимость</h3>

<p>Restricting visibility of properties, methods, and entire types helps with
keeping code decoupled.</p>

<ul>
<li>Максимально ограничивайте область видимости обозначений.</li>
<li>Рассмотрите возможность преобразования приватных методов в неэкспортируемые функции в том же файле, 
  но вне какого-либо класса, а также перемещение приватных свойств в отдельные, неэкспортируемые классы.</li>
<li>В TypeScript все обозначения по умолчанию публичные. Никогда не используйте модификатор <code>public</code> за исключением случаев объявления публичных свойств параметров, недоступных только для чтения.</li>
</ul>

<pre><code class="language-ts bad">class Foo {
  public bar = new Bar();  // BAD: нет необходимости в модификаторе "public"

  constructor(public readonly baz: Baz) {}  // BAD: модификатор "readonly" подразумевает, что это свойство имеет по умолчанию модификатор "public"
}
</code></pre>

<pre><code class="language-ts good">class Foo {
  bar = new Bar();  // GOOD: нет необходимости в модификаторе "public"

  constructor(public baz: Baz) {}  // допускается модификатор "public"
}
</code></pre>

<p>See also <a href="#export-visibility">export visibility</a> below.</p>

<h3 id="constructors">Конструкторы</h3>

<p>При вызове конструктора всегда должны использоваться скобки, даже если никакие аргументы не передаются:</p>

<pre><code class="language-ts bad">const x = new Foo;
</code></pre>

<pre><code class="language-ts good">const x = new Foo();
</code></pre>

<p>Нет необходимости предоставлять пустой конструктор или конструктор, который просто делегирует в родительский класс, поскольку ES2015 предоставляет конструктор класса по умолчанию, если он не указан. Однако не следует убирать конструкторы со свойствами параметров, модификаторами или декораторами параметров, даже если тело конструктора пустое.</p>

<pre><code class="language-ts bad">class UnnecessaryConstructor {
  constructor() {}
}
</code></pre>

<pre><code class="language-ts bad">class UnnecessaryConstructorOverride extends Base {
    constructor(value: number) {
      super(value);
    }
}
</code></pre>

<pre><code class="language-ts good">class DefaultConstructor {
}

class ParameterProperties {
  constructor(private myService) {}
}

class ParameterDecorators {
  constructor(@SideEffectDecorator myService) {}
}

class NoInstantiation {
  private constructor() {}
}
</code></pre>

<h3 id="class-members">Class Members</h3>

<h4 id="private-fields">Не используйте приватные поля вида <code>#private</code></h4>

<p>Не используйте приватные поля (также известные как приватные идентификаторы):</p>

<pre><code class="language-ts bad">class Clazz {
  #ident = 1;
}
</code></pre>

<p>Вместо этого используйте поддерживаемые TypeScript аннотации видимости:</p>

<pre><code class="language-ts good">class Clazz {
  private ident = 1;
}
</code></pre>

<section class="zippy">
Почему?

<p> Приватные идентификаторы вызывают существенные проблемы с размером и производительностью при понижении версии стандарта ECMAScript, в которую будет скомпилирован код TypeScript и не поддерживаются до ES2015. Они могут быть понижены только до уровня ES2015, но не ниже. At the same time, they do not offer substantial benefits when static type checking is used to enforce visibility.</p>
</section>

<h4 id="use-readonly">Используйте модификатор <code>readonly</code></h4>
<p>Пометьте модификатором <code>readonly</code> те свойства, которые никогда не переназначаются вне конструктора (они не обязательно должны быть глубоко неизменяемыми).</p>

<h4 id="parameter-properties">Parameter properties</h4>

<p>Rather than plumbing an obvious initializer through to a class member, use a
TypeScript
<a href="https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties">parameter property</a>.</p>

<pre><code class="language-ts bad">class Foo {
  private readonly barService: BarService;

  constructor(barService: BarService) {
    this.barService = barService;
  }
}
</code></pre>

<pre><code class="language-ts good">class Foo {
  constructor(private readonly barService: BarService) {}
}
</code></pre>

<p>If the parameter property needs documentation,
<a href="#parameter-property-comments">use an <code>@param</code> JSDoc tag</a>.</p>

<h4 id="field-initializers">Field initializers</h4>

<p>If a class member is not a parameter, initialize it where it's declared, which
sometimes lets you drop the constructor entirely.</p>

<pre><code class="language-ts bad">class Foo {
  private readonly userList: string[];
  constructor() {
    this.userList = [];
  }
}
</code></pre>

<pre><code class="language-ts good">class Foo {
  private readonly userList: string[] = [];
}
</code></pre>

<h4 id="properties-used-outside-of-class-lexical-scope">Properties used outside of class lexical scope</h4>

<p>Properties used from outside the lexical scope of their containing class, such
as an AngularJS controller's properties used from a template, must not use
<code>private</code> visibility, as they are used outside of the lexical scope of their
containing class.</p>

<p>Prefer <code>public</code> visibility for these properties, however <code>protected</code> visibility
can also be used as needed. For example, Angular and Polymer template properties
should use <code>public</code>, but AngularJS should use <code>protected</code>.</p>

<p>TypeScript code must not not use <code>obj['foo']</code> to bypass the visibility of a
property</p>

<section class="zippy">
Why?

<p>When a property is <code>private</code>, you are declaring to both automated systems and
humans that the property accesses are scoped to the methods of the declaring
class, and they will rely on that. For example, a check for unused code will
flag a private property that appears to be unused, even if some other file
manages to bypass the visibility restriction.</p>

<p>Though it may appear that <code>obj['foo']</code> can bypass visibility in the TypeScript
compiler, this pattern can be broken by rearranging the build rules,
and also violates <a href="#optimization-compatibility">optimization compatibility</a>.
</p></section>

<h4>Геттеры и Сеттеры (Аксессоры)</h4>

<p>Для членов класса можно иcпользовать геттеры и сеттеры. Методы-геттеры должен быть 
  <a href="https://en.wikipedia.org/wiki/Pure_function">чистыми функциями</a> (т.е. не имеет побочных эффектов и каждый раз возвращает одинаковый результат при одних и тех же параметрах). Они также полезны как средство ограничения видимости внутренних или подробных деталей реализации (показано ниже).</p>

<pre><code class="language-ts good">class Foo {
  constructor(private readonly someService: SomeService) {}

  get someMember(): string {
    return this.someService.someVariable;
  }

  set someMember(newValue: string) {
    this.someService.someVariable = newValue;
  }
}
</code></pre>

<p>Если аксессор используется для сокрытия свойства класса, скрытое свойство может иметь префикс или суффикс с любым целым словом, например <code>internal</code> или <code>wrapped</code>. При использовании этих приватных свойств по возможности обращайтесь к их значению через аксессор. По крайней мере один аксессор к свойству должен быть нетривиальным: не определяйте <q>сквозные</q> аксессоры только для того, чтобы скрыть свойство. Вместо этого сделайте свойство публичным (или подумайте о том, чтобы сделать его доступным только для чтения (<code>readonly</code>), чем просто определять геттер без сеттера).</p>

<pre><code class="language-ts good">class Foo {
  private wrappedBar = '';
  get bar() {
    return this.wrappedBar || 'bar';
  }

  set bar(wrapped: string) {
    this.wrappedBar = wrapped.trim();
  }
}
</code></pre>

<pre><code class="language-ts bad">class Bar {
  private barInternal = '';
  // Ни один из этих аксессоров не имеет логики, поэтому просто сделайте bar публичным
  get bar() {
    return this.barInternal;
  }

  set bar(value: string) {
    this.barInternal = value;
  }
}
</code></pre>

<h3 id="primitive-types-wrapper-classes">Примитивные типы &amp; Классы-обертки</h3>

<p>Код TypeScript не должен создавать экземпляры классов-оболочек для примитивных типов
<code>String</code>, <code>Boolean</code>, и <code>Number</code>. Классы-оболочки имеют удивляющее поведение,
такое как <code>new Boolean(false)</code> равное <code>true</code>.</p>

<pre><code class="language-ts bad">const s = new String('hello');
const b = new Boolean(false);
const n = new Number(5);
</code></pre>

<pre><code class="language-ts good">const s = 'hello';
const b = false;
const n = 5;
</code></pre>

<h3 id="array-constructor">Конструктор массива</h3>

<p>В коде на Typescript не должны использоваться <code>Array()</code> конструкторы, с или без <code>new</code>.
Его применение неоднозначно и сбивает с толку:</p>

<pre><code class="language-ts bad">const a = new Array(2); // [undefined, undefined]
const b = new Array(2, 3); // [2, 3];
</code></pre>

<p>Вместо этого всегда используйте скобки для инициализации массивов , или <code>from</code> для инициализации <code>Array</code> с определенным размером:</p>

<pre><code class="language-ts good">const a = [2];
const b = [2, 3];

// Эквивалент для Array(2):
const c = [];
c.length = 2;

// [0, 0, 0, 0, 0]
Array.from&lt;number&gt;({length: 5}).fill(0);
</code></pre>

<h3 id="type-coercion">Преобразование типов</h3>

<p>В TypeScript коде можно использовать <code>String()</code> и <code>Boolean()</code> (примечание: без <code>new</code>!)
функции, строковые шаблонные литералы, или <code>!!</code> для преобразования типов.</p>

<pre><code class="language-ts good">const bool = Boolean(false);
const str = String(aNumber);
const bool2 = !!str;
const str2 = `result: ${bool2}`;
</code></pre>

<p>Using string concatenation to cast to string is discouraged, as we check that
operands to the plus operator are of matching types.</p>

<p>Код должен использовать <code>Number()</code> для парсинга числовых значений, и <em>должен</em> явно проверять его возврат на значения <code>NaN</code>, за исключением случаев, когда из контекста точно известно, что сбой парсинга невозможен.</p>

<p>Примечание: <code>Number('')</code>, <code>Number(' ')</code>, и <code>Number('\t')</code> могут вернуть <code>0</code> вместо <code>NaN</code>. <code>Number('Infinity')</code> и <code>Number('-Infinity')</code> могут вернуть <code>Infinity</code>
и <code>-Infinity</code> соответственно. Эти случаи могут потребовать особого обращения.</p>

<pre><code class="language-ts good">const aNumber = Number('123');
if (isNaN(aNumber)) throw new Error(...);  // Обрабатываем NaN, если в строке может не быть чисел
assertFinite(aNumber, ...);                // Необязательно: если NaN не может возникнуть, потому что он был проверен ранее.
</code></pre>

<p>В коде не должен использоваться унарный плюс (<code>+</code>) для преобразования строки в число. Парсинг чисел может привести к неудаче, иметь неожиданные исключительные ситуации и может быть признаком дурно пахнущего кода (парсинг чисел не на том уровне). Учитывая это, унарный плюс слишком легко пропустить при проверке кода.</p>

<pre><code class="language-ts bad">const x = +y;
</code></pre>

<p>Код также не должен использовать <code>parseInt</code> или <code>parseFloat</code> для парсинга чисел, за исключением строк не с десятичными значениями (см. ниже). Обе эти функции игнорируют конечные символы в строке, что может привести к возникновению ошибочного состояния (например, парсинг <code>12 гномов</code> как <code>12</code>).</p>

<pre><code class="language-ts bad">const n = parseInt(someString, 10);  // Подвержено ошибкам,
const f = parseFloat(someString);    // независимо от передачи основания системы счисления.
</code></pre>

<p>Код, который должен выполнять парсинг числа с использованием системы счисления, должен проверять, является ли его ввод числом, прежде чем вызывать <code>parseInt</code>;</p>

<pre><code class="language-ts good">if (!/^[a-fA-F0-9]+$/.test(someString)) throw new Error(...);
  // Требуется для парсинга восьмеричного числа.
// tslint:disable-next-line:ban
const n = parseInt(someString, 16);  // Допустимо только для основания числа != 10
</code></pre>

<p>Используйте <code>Number()</code>, а затем <code>Math.floor</code> или <code>Math.trunc</code> (там, где это возможно) для парсинга целых чисел:</p>

<pre><code class="language-ts good">let f = Number(someString);
if (isNaN(f)) handleError();
f = Math.floor(f);
</code></pre>

<p>Не используйте явное булево преобразование в условиях, в которых уже имеется неявное булево преобразование. Это условия в операторах <code>if</code>, <code>for</code> и <code>while</code>.</p>


<pre><code class="language-ts bad">const foo: MyInterface|null = ...;
if (!!foo) {...}
while (!!foo) {...}
</code></pre>

<pre><code class="language-ts good">const foo: MyInterface|null = ...;
if (foo) {...}
while (foo) {...}
</code></pre>

<p>В коде можно использовать явные сравнения:</p>

<pre><code class="language-ts good">// Явное сравнение &gt; 0 это хорошо:
if (arr.length &gt; 0) {...}
// так же как и полагаться на неявное булево преобразование:
if (arr.length) {...}
</code></pre>

<h3 id="variables">Переменные</h3>

<p>Всегда используйте <code>const</code> или <code>let</code> для обьявления переменных. По умолчанию используйте <code>const</code>, если не требуется переназначение переменной. Никогда не используйте <code>var</code>.</p>

<pre><code class="language-ts good">const foo = otherValue;  // Используйте, если "foo" никогда не меняется.
let bar = someValue;     // Используйте, если для "bar" когда-либо позднее будет присвоено значение 
</code></pre>

<p><code>const</code> и <code>let</code> имеют блочную область видимости, как и переменные в большинстве других языков.
  <code>var</code> в JavaScript ограничен областью действия функции, что может вызвать трудные для понимания ошибки. Не используйте его.</p>

<pre><code class="language-ts bad">var foo = someValue;     // Не используйте - область видимости var сложна и подвержена ошибкам.
</code></pre>

<p>Переменные не должны использоваться до их объявления.</p>

<h3 id="exceptions">Исключения</h3>

<p>Всегда используйте <code>new Error()</code> при создании исключений вместо простого вызова <code>Error()</code>. В обоих случаях создается новый экземпляр <code>Error</code>, но использование <code>new</code> более согласуется с тем, как создаются экземпляры других объектов.</p>

<pre><code class="language-ts good">throw new Error('Foo is not a valid bar.');
</code></pre>

<pre><code class="language-ts bad">throw Error('Foo is not a valid bar.');
</code></pre>

<h3 id="iterating-objects">Итерация объектов</h3>

<p>Итерация объектов с помощью <code>for (... in ...)</code> подвержена вероятным ошибкам, т.к. это включает в себя все перечисляемые свойства из цепочки прототипов.</p>

<p>Не используйте не фильтрованные <code>for (... in ...)</code> выражения:</p>

<pre><code class="language-ts bad">for (const x in someObj) {
  // x может происходить от некоторого родительского прототипа!
}
</code></pre>

<p>Либо явно отфильтруйте значения с помощью оператора <code>if</code>, либо используйте <code>for (... of
Object.keys(...))</code>.</p>

<pre><code class="language-ts good">for (const x in someObj) {
  if (!someObj.hasOwnProperty(x)) continue;
  // now x was definitely defined on someObj
}
for (const x of Object.keys(someObj)) { // note: for _of_!
  // now x was definitely defined on someObj
}
for (const [key, value] of Object.entries(someObj)) { // note: for _of_!
  // now key was definitely defined on someObj
}
</code></pre>

<h3 id="iterating-containers">Iterating containers</h3>

<p>Не используйте <code>for (... in ...)</code> для итерации по массивам. It will counterintuitively
  give the array's indices (as strings!), not values:</p>

<pre><code class="language-ts bad">for (const x in someArray) {
  // x - это индекс!
}
</code></pre>

<p>Для итерации по массивам используйте <code>for (... of someArr)</code> или обычные циклы <code>for</code> с индексами.</p>

<pre><code class="language-ts good">for (const x of someArr) {
  // x - ссылается на значение из someArr
}

for (let i = 0; i &lt; someArr.length; i++) {
  // Explicitly count if the index is needed, otherwise use the for/of form.
  const x = someArr[i];
  // ...
}
for (const [i, x] of someArr.entries()) {
  // Альтернативная версия предыдущего.
}
</code></pre>

<p>Не используйте <code>Array.prototype.forEach</code>, <code>Set.prototype.forEach</code>, и <code>Map.prototype.forEach</code>. Они усложняют отладку кода и препятствуют некоторым полезным проверкам компилятора (например, проверку достижимости).</p>

<pre><code class="language-ts bad">someArr.forEach((item, index) =&gt; {
  someFn(item, index);
});
</code></pre>

<section class="zippy">
Почему?

<p>Рассмотрим следующий код:</p>

<pre><code class="language-ts bad">let x: string|null = 'abc';
myArray.forEach(() =&gt; { x.charAt(0); });
</code></pre>

<p>Вы можете видеть, что этот код вполне в порядке: <code>x</code> не является null и не изменяется до обращения к нему. Но компилятор не может знать, что этот вызов <code>.forEach()</code> не привязан к переданному замыканию и не вызовет его позже, возможно, после того, как <code>x</code> будет установлен в null, поэтому он помечает этот код как ошибку. Эквивалентный цикл for-of работает нормально.</p>

<p>
<a href="https://www.typescriptlang.org/play?#code/DYUwLgBAHgXBDOYBOBLAdgcwD5oK7GAgF4IByAQwCMBjUgbgCgBtAXQDoAzAeyQFFzqACwAUwgJTEAfBADeDCNDZDySAIJhhABjGMAvjoYNQkAJ5xEqTDnyESFGvQbckEYdS5pEEAPoQuHCFYJOQUTJUEVdS0DXQYgA">Посмотреть в песочнице ошибочный и безошибочный варианты</a>
</p>

<p>In practice, variations of this limitation of control flow analysis show up in
more complex codepaths where it is more surprising.
</p></section>

<h3 id="using-the-spread-operator">Использование spread-операторов</h3>

<p>Использование spread-оператора <code>[...foo]; {...bar}</code> является удобным сокращением для копирования массивов и объектов. При использовании spread-оператора для объектов, более поздние значения заменяют более ранние с тем же ключом.</p>

<pre><code class="language-ts good">const foo = {
  num: 1,
};

const foo2 = {
  ...foo,
  num: 5,
};

const foo3 = {
  num: 5,
  ...foo,
}

foo2.num === 5;
foo3.num === 1;

</code></pre>

<p>При использовании spread-оператора раскладываемое значение должно соответствовать создаваемому. Т.е. при создании объекта с spread-оператором  можно использовать только объекты, а при создании массива раскладывайте только итерируемые объекты. Примитивы, включая <code>null</code> и <code>undefined</code>, никогда не могут быть разложены.</p>

<pre><code class="language-ts bad">const foo = {num: 7};
const bar = {num: 5, ...(shouldUseFoo &amp;&amp; foo)}; // might be undefined

// Creates {0: 'a', 1: 'b', 2: 'c'} but has no length
const fooStrings = ['a', 'b', 'c'];
const ids = {...fooStrings};
</code></pre>

<pre><code class="language-ts good">const foo = shouldUseFoo ? {num: 7} : {};
const bar = {num: 5, ...foo};
const fooStrings = ['a', 'b', 'c'];
const ids = [...fooStrings, 'd', 'e'];
</code></pre>

<h3 id="control-flow-statements-blocks">Операторы управления потоком &amp; блоки</h3>

<p>Операторы управления потоком, охватывающие несколько строк, всегда используют блоки для размещения содержащегося в них кода.</p>

<pre><code class="language-ts good">for (let i = 0; i &lt; x; i++) {
  doSomethingWith(i);
  andSomeMore();
}
if (x) {
  doSomethingWithALongMethodName(x);
}
</code></pre>

<pre><code class="language-ts bad">if (x)
  x.doFoo();
for (let i = 0; i &lt; x; i++)
  doSomethingWithALongMethodName(i);
</code></pre>

<p>Исключением являются операторы <code>if</code>, которые помещаются на одной строке и могут не использовать блоки.</p>

<pre><code class="language-ts good">if (x) x.doFoo();
</code></pre>

<h3 id="switch-statements">Switch оператор</h3>

<p>Каждый <code>switch</code> оператор должен включать в себя блок по умолчанию (<code>default</code>), даже если там не содержится кода.</p>

<pre><code class="language-ts good">switch (x) {
  case Y:
    doSomethingElse();
    break;
  default:
    // ничего не делать.
}
</code></pre>

<p>Non-empty statement groups (<code>case ...</code>) may not fall through (enforced by the
compiler):</p>

<pre><code class="language-ts bad">switch (x) {
  case X:
    doSomething();
    // дальнейший пропуск - не разрешен!
  case Y:
    // ...
}
</code></pre>

<p>Допускается пропуск пустых групп операторов:</p>

<pre><code class="language-ts good">switch (x) {
  case X:
  case Y:
    doSomething();
    break;
  default: // ничего не делать.
}
</code></pre>

<h3 id="equality-checks">Проверка равенства</h3>

<p>Всегда используйте тройное равенство (<code>===</code>) и неравенство (<code>!==</code>). Операторы двойного равенства вызывают склонные к ошибкам приведения типов, которые трудны для понимания и работают медленнее в реализации виртуальных машин JavaScript. Смотрите также <a href="https://dorey.github.io/JavaScript-Equality-Table/">JavaScript таблицу равенства</a>.</p>

<pre><code class="language-ts bad">if (foo == 'bar' || baz != bam) {
  // Трудное для понимания поведение из-за преобразования типов.
}
</code></pre>

<pre><code class="language-ts good">if (foo === 'bar' || baz !== bam) {
  // Здесь все хорошо и понятно.
}
</code></pre>

<p><strong>Исключение</strong>: При сравнении с <code>null</code> значением можно использовать <code>==</code> и <code>!=</code>
  операторы для общего охвата <code>null</code> и <code>undefined</code> значений.</p>

<pre><code class="language-ts good">if (foo == null) {
  // Будет срабатывать, когда foo равен null или undefined. 
}
</code></pre>

<h3 id="function-declarations">Объявление функции</h3>

<p>Используйте <code>function foo() { ... }</code> для объявления именованных функций, включая функции во вложенных областях, например внутри другой функции.</p>

<p>Используйте объявления функций вместо присваивания функционального выражения локальной переменной (<del><code>const x = function() {...};</code></del>). TypeScript уже запрещает переназначение функций, поэтому предотвращение перезаписи объявления функции с помощью <code>const</code> не требуется.</p>

<p>Исключение: Если функция обращается к <code>this</code> внешней области видимости, используйте назначаемые переменным стрелочные функции вместо объявления функции.</p>

<pre><code class="language-ts good">function foo() { ... }
</code></pre>

<pre><code class="language-ts bad">// Учитывая приведенное выше объявление, это не будет компилироваться:
foo = () =&gt; 3;  // ERROR: Недопустимая левая часть выражения присваивания.

// Так что такие объявления излишни.
const foo = function() { ... }
</code></pre>

<blockquote>
<p>Обратите внимание на разницу между объявлениями функций (<code>function foo() {}</code>) обсуждаемыми здесь, и функциональными выражениями (<del><code>doSomethingWith(function()
{});</code></del>) которые обсуждаются <a href="#function-expressions">ниже</a>.</p>
</blockquote>

<p>Стрелочные функции верхнего уровня <em>могут</em> использоваться для явного объявления того, что функция реализует интерфейс.</p>

<pre><code class="language-ts good">interface SearchFunction {
  (source: string, subString: string): boolean;
}

const fooSearch: SearchFunction = (source, subString) =&gt; { ... };
</code></pre>

<h3 id="function-expressions">Функциональные выражения</h3>

<h4 id="use-arrow-functions-in-expressions">Использование стрелочных функций в выражениях</h4>

<p>Всегда используйте стрелочные функции вместо функциональных выражений которые были до ES6 и задавались с помощью ключевого слова <code>function</code>.</p>

<pre><code class="language-ts good">bar(() =&gt; { this.doSomething(); })
</code></pre>

<pre><code class="language-ts bad">bar(function() { ... })
</code></pre>

<p>Функциональные выражения (определенные с помощью ключевого слова <code>function</code>) могут использоваться только в том случае, если код должен динамически перепривязать <code>this</code>, но в коде в принципе  <em>не рекомендуется</em> перепривязывать <code>this</code>. В коде обычных функций (в отличие от стрелочных функций и методов) <em>не рекомендуется</em> обращаться к <code>this</code>.</p>

<h4 id="expression-bodies-vs-block-bodies">Expression bodies vs block bodies</h4>

<p>Use arrow functions with expressions or blocks as their body as appropriate.</p>

<pre><code class="language-ts good">// Top level functions use function declarations.
function someFunction() {
  // Block arrow function bodies, i.e. bodies with =&gt; { }, are fine:
  const receipts = books.map((b: Book) =&gt; {
    const receipt = payMoney(b.price);
    recordTransaction(receipt);
    return receipt;
  });

  // Expression bodies are fine, too, if the return value is used:
  const longThings = myValues.filter(v =&gt; v.length &gt; 1000).map(v =&gt; String(v));

  function payMoney(amount: number) {
    // function declarations are fine, but don't access `this` in them.
  }
}
</code></pre>

<p>Only use an expression body if the return value of the function is actually
used.</p>

<pre><code class="language-ts bad">// BAD: use a block ({ ... }) if the return value of the function is not used.
myPromise.then(v =&gt; console.log(v));
</code></pre>

<pre><code class="language-ts good">// GOOD: return value is unused, use a block body.
myPromise.then(v =&gt; {
  console.log(v);
});
// GOOD: code may use blocks for readability.
const transformed = [1, 2, 3].map(v =&gt; {
  const intermediate = someComplicatedExpr(v);
  const more = acrossManyLines(intermediate);
  return worthWrapping(more);
});
</code></pre>

<h4 id="rebinding-this">Перепривязывание <code>this</code></h4>

<p>Функциональные выражения не должны использовать <code>this</code> если только они не существуют специально для перепривязки <code>this</code>. В большинстве случаев перепривязки <code>this</code> можно избежать, используя стрелочные функции или явно заданные параметры.</p>

<pre><code class="language-ts bad">function clickHandler() {
  // Плохо: что такое «this» в этом контексте?
  this.textContent = 'Hello';
}
// Плохо: `this` неявно ссылается на document.body .
document.body.onclick = clickHandler;
</code></pre>

<pre><code class="language-ts good">// Хорошо: явная ссылка на объект из стрелочной функции.
document.body.onclick = () =&gt; { document.body.textContent = 'hello'; };
// Альтернатива: взять явно заданный параметр
const setTextFn = (e: HTMLElement) =&gt; { e.textContent = 'hello'; };
document.body.onclick = setTextFn.bind(null, document.body);
</code></pre>

<h4 id="arrow-functions-as-properties">Стрелочные функции как свойства</h4>

<p>В классах обычно <em>не рекомендуется</em> содержать свойства, которые проинициализированы как стрелочные функции.
Использование стрелочных функций как свойств требует, чтобы вызывающая их функция корректно понимала, что у вызываемой функции уже есть привязанный <code>this</code>, что увеличивает путаницу в понимании того, что такое <code>this</code>, а сами места вызовов и ссылки использующие эти функции, могут смотреться некорректно работающими (т.к. это требует дополнительных знаний из-за пределов локального пространства вызывающей функции, чтобы определить, что они корректны). В коде <em>рекомендуется</em> всегда использовать стрелочные функции для вызова методов экземпляра (<code>const handler = (x) =&gt; { this.listener(x); };</code>), и <em>не рекомендуется</em> получать или передавать ссылки на методы экземпляра (<del><code>const handler = this.listener; handler(x);</code></del>).</p>

<blockquote>
<p>Note: in some specific situations, e.g. when binding functions in a template,
arrow functions as properties are useful and create much more readable code.
Use judgement with this rule. Также см. раздел <a href="#event-handlers"><code>Обработчики событий</code></a> ниже.</p>
</blockquote>

<pre><code class="language-ts bad">class DelayHandler {
  constructor() {
    // Problem: `this` is not preserved in the callback. `this` in the callback
    // will not be an instance of DelayHandler.
    setTimeout(this.patienceTracker, 5000);
  }
  private patienceTracker() {
    this.waitedPatiently = true;
  }
}
</code></pre>

<pre><code class="language-ts bad">// Стрелочные функции обычно не рекомендуется задавать свойствам.
class DelayHandler {
  constructor() {
    // Плохо: этот код выглядит так, как будто ту забыли привязать `this`. 
    setTimeout(this.patienceTracker, 5000);
  }
  private patienceTracker = () =&gt; {
    this.waitedPatiently = true;
  }
}
</code></pre>

<pre><code class="language-ts good">// Явное управление `this` во время вызова.
class DelayHandler {
  constructor() {
    // По возможности используйте анонимные функции.
    setTimeout(() =&gt; {
      this.patienceTracker();
    }, 5000);
  }
  private patienceTracker() {
    this.waitedPatiently = true;
  }
}
</code></pre>

<h4 id="event-handlers">Обработчики событий</h4>

<p>Обработчики событий <em>могут</em> использовать стрелочные функции, когда нет необходимости удалять обработчик (например, если событие генерируется самим классом). Если обработчик впоследствии должен быть удален, тогда правильным подходом будет использование назначенной свойству стрелочной функции, поскольку они автоматически захватывают <code>this</code> и при этом обеспечивается постоянная ссылка на обработчик для его последующего удаления.</p>

<pre><code class="language-ts good">// Обработчики событий могут быть анонимными функциями или назначенные свойствам стрелочными функциями.
class Component {
  onAttached() {
    // Событие генерируется этим классом, удалять его не нужно.
    this.addEventListener('click', () =&gt; {
      this.listener();
    });
    // this.listener это постоянная ссылка на функцию-обработчик, которую мы позже можем удалить.
    window.addEventListener('onbeforeunload', this.listener);
  }
  onDetached() {
    // Событие генерируется окном (window). Если мы не удалим функцию-обработчик (this.listener), то она
    // сохранит ссылку на `this` к которой привязана, что приведет к утечке памяти.
    window.removeEventListener('onbeforeunload', this.listener);
  }
  // Стрелочная функция, хранящаяся в свойстве, автоматически привязывается к `this`.
  private listener = () =&gt; {
    confirm('Вы хотите покинуть страницу?');
  }
}
</code></pre>

<p>Не используйте <code>bind</code> в выражениях, которые устанавливают обработчики событий, потому что это создает временную ссылку, которую нельзя удалить.</p>

<pre><code class="language-ts bad">// Привязка слушателей создает временную ссылку, которая недоступна для удаления.
class Component {
  onAttached() {
    // Это создает временную ссылку, которая нам не будет доступна для удаления.
    window.addEventListener('onbeforeunload', this.listener.bind(this));
  }
  onDetached() {
    // метод bind каждый раз создает новую ссылку, поэтому эта строка не делает ничего.
    window.removeEventListener('onbeforeunload', this.listener.bind(this));
  }
  private listener() {
    confirm('Вы хотите покинуть страницу?');
  }
}
</code></pre>

<h3 id="automatic-semicolon-insertion">Автоматическая вставка точки с запятой</h3>

<p>Не следует полагаться на автоматическую вставку точки с запятой (<abbr title="Automatic Semicolon Insertion">ASI</abbr>). Явно завершайте все
  операторы с помощью точки с запятой. Это предотвращает ошибки, возникающие из-за неправильной вставки точки с запятой, а также обеспечивает совместимость с инструментами которые имеют ограниченную поддержку ASI (например, clang-format).</p>

<h3 id="ts-ignore">@ts-ignore</h3>

<p>Не используйте <code>@ts-ignore</code>. На первый взгляд кажется, что это простой способ исправить ошибку компилятора, но на практике конкретная ошибка компилятора часто вызывается более серьезной проблемой, которая может быть исправлена более явным путем.</p>

<p>Например, если вы используете <code>@ts-ignore</code> для подавления ошибок типизации, то будет трудно предсказать, какие типы в конечном итоге будет видеть окружающий код. Для многих ошибок типизации, полезны советы в разделе <a href="#any">как лучше всего использовать <code>any</code></a>.</p>

<h3 id="type-and-non-nullability-assertions">Утверждения типа (Type Assertions) и утверждения ненулевого значения (Non-nullability Assertions)</h3>

<p>Утверждения типа (<code>x as SomeType</code>) и утверждения ненулевого значения (<code>y!</code>) не безопасны. Оба только заглушают компилятор TypeScript, но не вставляют никаких проверок во время выполнения, чтобы соответствовать этим утверждениям, поэтому они могут привести к сбою вашей программы во время выполнения.</p>

<p>По этой причине, вам <em>не рекомендуется</em> использовать утверждения типа и утверждения ненулевого значения без явной или объяснимой причины.</p>

<p>Instead of the following:</p>

<pre><code class="language-ts bad">(x as Foo).foo();

y!.bar();
</code></pre>

<p>Если вы хотите произвести утверждение типа или утверждение ненулевого значения то лучшим решением будет написать проверку, которая будет работать во время выполнения.</p>

<pre><code class="language-ts good">// предположим, что Foo - это класс.
if (x instanceof Foo) {
  x.foo();
}

if (y) {
  y.bar();
}
</code></pre>

<p>Иногда из-за некоторых внутренних особенностей вашего кода вы можете быть уверены, что форма утверждения безопасна. В таких ситуациях <em>рекомендуется</em> добавить пояснение, объясняющее, почему вы согласны с небезопасным поведением:</p>

<pre><code class="language-ts good">// x это Foo, потому что ...
(x as Foo).foo();

// y не может быть null, потому что ...
y!.bar();
</code></pre>


<p>Комментарии могут не потребоваться, если очевидны причины, лежащие в основе применения утверждения типа или утверждения ненулевого значения.
  Например, сгенерированный код-прототип всегда допускает значение null, но, возможно, в контексте кода хорошо известно, что определенные поля всегда предоставляются серверной частью. В таком случае, принимайте решение руководствуясь своим профессиональным видением.</p>

<h4 id="type-assertions-syntax">Синтаксис утверждения типа</h4>

<p>Утверждения типа должны использовать синтаксис <code>as</code> (в отличие от синтаксиса угловых скобок). Это позволяет заключить утверждение в круглые скобки при обращении к элементу.</p>

<pre><code class="language-ts bad">const x = (&lt;Foo&gt;z).length;
const y = &lt;Foo&gt;z.length;
</code></pre>

<pre><code class="language-ts good">const x = (z as Foo).length;
</code></pre>

<h4 id="type-assertions-and-object-literals">Утверждение типа и литералы объекта</h4>

<p>Используйте аннотации типа (<code>: Foo</code>) вместо утверждения типа (<code>as Foo</code>) для указания типа объектного литерала. Это позволяет обнаружить ошибки рефакторинга, когда поля интерфейса меняются со временем.</p>

<pre><code class="language-ts bad">interface Foo {
  bar: number;
  baz?: string;  // был "bam", но позднее был переименован в "baz".
}

const foo = {
  bar: 123,
  bam: 'abc',  // нет ошибки!
} as Foo;

function func() {
  return {
    bar: 123,
    bam: 'abc',  // нет ошибки!
  } as Foo;
}
</code></pre>

<pre><code class="language-ts good">interface Foo {
  bar: number;
  baz?: string;
}

const foo: Foo = {
  bar: 123,
  bam: 'abc',  // жалуется на то, что "bam" не был объявлен в Foo.
};

function func(): Foo {
  return {
    bar: 123,
    bam: 'abc',  // жалуется на то, что "bam" не был объявлен в Foo.
  };
}
</code></pre>

<h3 id="member-property-declarations">Member property declarations</h3>

<p>В объявлениях интерфейсов и классов для разделения объявлений отдельных членов необходимо использовать символ<code>;</code></p>

<pre><code class="language-ts good">interface Foo {
  memberA: string;
  memberB: number;
}
</code></pre>

<p>Интерфейсы специально не должны использовать символ <code>,</code> для разделения полей, что необходимо для симметричности с объявлениями классов:</p>

<pre><code class="language-ts bad">interface Foo {
  memberA: string,
  memberB: number,
}
</code></pre>

<p>Встраиваемые объявления типов объектов в качестве разделителя должны использовать запятую:</p>

<pre><code class="language-ts good">type SomeTypeAlias = {
  memberA: string,
  memberB: number,
};

let someProperty: {memberC: string, memberD: number};
</code></pre>

<h4 id="optimization-compatibility-for-property-access">Optimization compatibility for property access</h4>

<p>Код не должен смешивать доступ к свойству в кавычках с доступом к свойству через точку</p>

<pre><code class="language-ts bad">// Плохо: код должен использовать либо доступ без кавычек, либо доступ в кавычках для любого свойства
// единообразно для всего приложения:
console.log(x['someField']);
console.log(x.someField);
</code></pre>

<p>Code must not rely on disabling renaming, but must rather declare all properties
that are external to the application to prevent renaming:</p>

<p>Prefer for code to account for a possible property-renaming optimization, and
declare all properties that are external to the application to prevent renaming:</p>

<pre><code class="language-ts good">// Хорошо: объявление интерфейса
declare interface ServerInfoJson {
  appVersion: string;
  user: UserJson;
}
const data = JSON.parse(serverResponse) as ServerInfoJson;
console.log(data.appVersion); // Type safe &amp; renaming safe!
</code></pre>

<h4 id="optimization-compatibility-for-module-object-imports">Optimization compatibility for module object imports</h4>

<p>При импорте объекта модуля напрямую обращайтесь к свойствам объекта модуля, а не передавайте его. Это гарантирует, что модули могут быть проанализированы и оптимизированы. Отношение к <a href="#module-versus-destructuring-imports">импорту модулей</a> как к пространствам имен является нормальным.</p>

<pre><code class="language-ts good">import {method1, method2} from 'utils';
class A {
  readonly utils = {method1, method2};
}
</code></pre>

<pre><code class="language-ts bad">import * as utils from 'utils';
class A {
  readonly utils = utils;
}
</code></pre>

<h4 id="exception">Exception</h4>

<p>This optimization compatibility rule applies to all web apps. It does not apply
to code that only runs server side (e.g. in NodeJS for a test runner). It is
still strongly encouraged to always declare all types and avoid mixing quoted
and unquoted property access, for code hygiene.</p>

<h3 id="enums">Перечисления (Enums)</h3>

<p>Всегда используйте <code>enum</code>, а не <code>const enum</code>. В TypeScript перечисления и так не могут быть изменены, а <code>const enum</code> - это отдельная особенность языка, связанная с оптимизацией, которая делает перечисление невидимым для пользователей JavaScript модуля.</p>

<h3 id="debugger-statements">Команды отладчика</h3>

<p>Команды отладчика (наподобие <code>debugger;</code>) не должны включаться в рабочий код.</p>

<pre><code class="language-ts bad">function debugMe() {
  debugger;
}
</code></pre>

<h3 id="decorators">Декораторы</h3>

<p>Декораторы обозначаются с помощью префикса <code>@</code>, например <code>@MyDecorator</code>.</p>

<p>Не определяйте новых декораторов. Используйте только те декораторы, которые определены фреймворками:</p>

<ul>
<li>Angular (например, <code>@Component</code>, <code>@NgModule</code> и т.д.)</li>
<li>Polymer (например,<code>@property</code>)</li>
</ul>

<section>
Почему?

<p>В основном мы предпочитаем избегать декораторов, поскольку они были экспериментальной функцией, которая с тех пор отклонилась от предложения TC39 и имеет известные ошибки, которые вряд ли будут исправлены.</p></section>

<p>При использовании декораторов, декоратор должен непосредственно предшествовать элементу, к которому он применяется, без пустых строк между ними:</p>

<pre><code class="language-ts">/** Комментарии JSDoc идут перед декораторами */
@Component({...})  // Примечание: после декоратора не должно быть пустой строки. 
class MyComp {
  @Input() myField: string;  // Декораторы полей могут находиться на одной линии... 

  @Input()
  myOtherField: string;  // ...  или переноситься.
}
</code></pre>

<h2 id="source-organization">Source Organization</h2>

<h3 id="modules">Модули</h3>

<h4 id="import-paths">Использование путей в импортах</h4>
Пути могут быть относительными, т. е. начинаться с . или .., или уходить в корень базового каталога, например root/path/to/file.

<p>Код TypeScript обязательно должен содержать пути для импорта другого кода TypeScript. Пути могут быть относительными, т.е. начинаться с <code>.</code> или <code>..</code>, или начинаться с базовой директории, например <code>root/path/to/file</code>.</p>

<p>В коде <em>рекомендуется</em> использовать относительные импорты (<code>./foo</code>) вместо абсолютных импортов <code>path/to/foo</code> когда ссылается на файлы в пределах одного и того же (в логическом смысле) проекта.</p>

<p>Рассмотрите возможность ограничения количества родительских шагов (<code>../../../</code>) так как это может затруднить понимание структуры модулей и путей.</p>

<pre><code class="language-ts good">import {Symbol1} from 'google3/path/from/root';
import {Symbol2} from '../parent/file';
import {Symbol3} from './sibling';
</code></pre>

<h4 id="namespaces-vs-modules">Пространства имен (namespace) & Модули</h4>

<p>TypeScript поддерживает два метода организации кода: пространства имен (<em>namespaces</em>) и модули, но использование пространств имен необходимо избегать. В коде должны использоваться TypeScript <em>модули</em> (которые являются <a href="http://exploringjs.com/es6/ch_modules.html">модулями ECMAScript 6</a>). То есть ваш код <em>должен</em> ссылаться на код в других файлах с помощью импорта и экспорта вида <code>import {foo} from 'bar';</code></p>

<p>В вашем коде не должны использоваться <code>namespace Foo { ... }</code> конструкции. Пространства имен (<code>namespace</code>) могут использоваться только тогда, когда это необходимо для взаимодействия с внешним сторонним кодом. Чтобы семантически разделить пространство имен вашего кода, используйте отдельные файлы.</p>

<p>В коде не должны использоваться <code>require</code> (как в <code>import x = require('...');</code>) для импортов.
Используйте ES6 синтаксис модулей.</p>

<pre><code class="language-ts bad">// Плохо: не используйте пространства имен:
namespace Rocket {
  function launch() { ... }
}

// Плохо: не используйте &lt;reference&gt;
/// &lt;reference path="..."/&gt;

// Плохо: не используйте require()
import x = require('mydep');
</code></pre>

<blockquote>
  <p>Примечание: В TypeScript  пространства имен (<code>namespace</code>) раньше назывались внутренними модулями и использовали ключевое слово <code>module</code> в виде <code>module Foo { ... }</code>. Не используйте такую форму. Всегда используйте ES6 импорты.</p>
</blockquote>

<h3 id="exports">Экспорты</h3>

<p>Используйте именованный экспорты во всем коде::</p>

<pre><code class="language-ts good">// Использование именованного экспорта:
export class Foo { ... }
</code></pre>

<p>Не используйте экспорт по умолчанию. Это гарантирует, что все импорты будут следовать единому шаблону.</p>

<pre><code class="language-ts bad">// Не используйте экспорт по умолчанию:
export default class Foo { ... } // ПЛОХО!
</code></pre>

<section class="zippy">
Почему?

<p>Default exports provide no canonical name, which makes central maintenance
difficult with relatively little benefit to code owners, including potentially
decreased readability:</p>

<pre><code class="language-ts bad">import Foo from './bar';  // Legal.
import Bar from './bar';  // Also legal.
</code></pre>

<p>Преимущество именованного экспорта заключается в том, что оно приводит к ошибкам, когда операторы импорта пытаются импортировать что-то, что не было объявлено. В <code>foo.ts</code>:</p>

<pre><code class="language-ts bad">const foo = 'blah';
export default foo;
</code></pre>

<p>И в <code>bar.ts</code>:</p>

<pre><code class="language-ts bad">import {fizz} from './foo';
</code></pre>

<p>В результате возникает ошибка <code>error TS2614: Module '"./foo"' has no exported member 'fizz'.</code> While
<code>bar.ts</code>:</p>

<pre><code class="language-ts bad">import fizz from './foo';
</code></pre>

<p>В результате получается <code>fizz === foo</code>, что может быть неожиданным и затрудняющим отладку.</p>

<p>Кроме того, экспорт по умолчанию побуждает людей помещать все в один большой объект, чтобы разместить все вместе в пространстве имен:</p>

<pre><code class="language-ts bad">export default class Foo {
  static SOME_CONSTANT = ...
  static someHelpfulFunction() { ... }
  ...
}
</code></pre>

<p>В приведенном выше примере у нас есть область видимости файла, которая может использоваться как пространство имен. У нас также есть, возможно, ненужная вторая область видимости (класс <code>Foo</code>), который в других файлах может двусмысленно использоваться и как тип, и как значение.</p>

<p>Вместо этого предпочтительно использовать файловую область видимости для пространства имен, а также именованный экспорт:</p>

<pre><code class="language-ts good">export const SOME_CONSTANT = ...
export function someHelpfulFunction()
export class Foo {
  // only class stuff here
}
</code></pre>

</section>

<h4 id="export-visibility">Export visibility</h4>

<p>TypeScript does not support restricting the visibility for exported symbols.
Only export symbols that are used outside of the module. Generally minimize the
exported API surface of modules.</p>

<h4 id="mutable-exports">Мутабельность экспортов</h4>

<p>Независимо от технической стороны, мутабельные экспорты могут создавать трудно понимаемый и отлаживаемый код, особенно при реэкспорте в различных модулях. Если по другому сформулировать это правило, то <code>export let</code> не допускается.</p>

<section>

<pre><code class="language-ts bad">export let foo = 3;
// In pure ES6, foo is mutable and importers will observe the value change after a second.
// In TS, if foo is re-exported by a second file, importers will not see the value change.
window.setTimeout(() =&gt; {
  foo = 4;
}, 1000 /* ms */);
</code></pre>

</section>

<p>Если необходимо поддерживать доступные извне мутабельные привязки, то вместо этого рекомендуется явно использовать функции-геттеры.</p>

<pre><code class="language-ts good">let foo = 3;
window.setTimeout(() =&gt; {
  foo = 4;
}, 1000 /* ms */);
// Используйте явно заданный геттер для доступа к мутабельному экспорту.
export function getFoo() { return foo; };
</code></pre>

<p>For the common pattern of conditionally exporting either of two values, first do
the conditional check, then the export. Make sure that all exports are final
after the module's body has executed.</p>

<pre><code class="language-ts good">function pickApi() {
  if (useOtherApi()) return OtherApi;
  return RegularApi;
}
export const SomeApi = pickApi();
</code></pre>

<h4 id="container-classes">Классы-контейнеры</h4>

<p>Не создавайте классы-контейнеры со статическими методами или свойствами ради пространства имен.</p>

<pre><code class="language-ts bad">export class Container {
  static FOO = 1;
  static bar() { return 1; }
}
</code></pre>

<p>Вместо этого экспортируйте отдельные константы и функции:</p>

<pre><code class="language-ts good">export const FOO = 1;
export function bar() { return 1; }
</code></pre>

<h3 id="imports">Импорты</h3>

<p>В ES6 и TypeScript есть четыре варианта операторов импорта:</p>

<section>

<table>
<thead>
<tr>
<th>Вид импорта</th>
<th>Пример</th>
<th>Назначение</th>
</tr>
</thead>

<tbody>
<tr>
<td>module
</td>
<td><code>import * as foo from
'...';</code></td>
<td>TypeScript imports
</td>
</tr>
<tr>
<td>destructuring
</td>
<td><code>import {SomeThing} from
'...';</code></td>
<td>TypeScript imports
</td>
</tr>
<tr>
<td>default
</td>
<td><code>import SomeThing from
'...';</code></td>
<td>Only for other external code that
requires them</td>
</tr>
<tr>
<td>side-effect

</td>
<td><code>import '...';</code>

</td>
<td>Only to import libraries for
their side-effects on load (such
as custom elements)</td>
</tr>
</tbody>
</table>

<pre><code class="language-ts good">// Хорошо: выберите один из двух вариантов в зависимости от ситуации (см. ниже).
import * as ng from '@angular/core';
import {Foo} from './foo';

// Только при необходимости: импорт по умолчанию.
import Button from 'Button';

// Sometimes needed to import libraries for their side effects:
import 'jasmine';
import '@polymer/paper-button';
</code></pre>

</section>

<h4 id="module-versus-destructuring-imports">Module versus destructuring imports</h4>

<p>Both module and destructuring imports have advantages depending on the
situation.</p>

<p>Despite the <code>*</code>, a module import is not comparable to a <q>wildcard</q> import as
seen in other languages. Instead, module imports give a name to the entire
module and each symbol reference mentions the module, which can make code more
readable and gives autocompletion on all symbols in a module. They also require
less import churn (all symbols are available), fewer name collisions, and allow
terser names in the module that's imported. Module imports are particularly
useful when using many different symbols from large APIs.</p>

<p>Destructuring imports give local names for each imported symbol. They allow
terser code when using the imported symbol, which is particularly useful for
very commonly used symbols, such as Jasmine's <code>describe</code> and <code>it</code>.</p>

<pre><code class="language-ts bad">// Bad: overlong import statement of needlessly namespaced names.
import {TableViewItem, TableViewHeader, TableViewRow, TableViewModel,
  TableViewRenderer} from './tableview';
let item: TableViewItem = ...;
</code></pre>

<pre><code class="language-ts good">// Better: use the module for namespacing.
import * as tableview from './tableview';
let item: tableview.Item = ...;
</code></pre>

<pre><code class="language-ts">import * as testing from './testing';

// All tests will use the same three functions repeatedly.
// When importing only a few symbols that are used very frequently, also
// consider importing the symbols directly (see below).
testing.describe('foo', () =&gt; {
  testing.it('bar', () =&gt; {
    testing.expect(...);
    testing.expect(...);
  });
});
</code></pre>

<pre><code class="language-ts good">// Better: give local names for these common functions.
import {describe, it, expect} from './testing';

describe('foo', () =&gt; {
  it('bar', () =&gt; {
    expect(...);
    expect(...);
  });
});
...
</code></pre>

<h4 id="renaming-imports">Переименование импортов</h4>

<p>В коде <em>рекомендуется</em> устранить возможные конфликты имен используя импорт модулей и переименовывая сами экспорты. При необходимости в коде <em>можно</em> переименовывать импорты (<code>import {SomeThing as
  SomeOtherThing}</code>).</p>

<p>Три примера, когда переименование может быть полезным:</p>

<ol>
<li>If it's necessary to avoid collisions with other imported symbols.</li>
<li>If the imported symbol name is generated.</li>
<li>If importing symbols whose names are unclear by themselves, renaming can
improve code clarity. For example, when using RxJS the <code>from</code> function might
be more readable when renamed to <code>observableFrom</code>.</li>
</ol>

<h4 id="import-export-type">Импорты &amp; экспорты типов</h4>

<p>Не используйте <code>import type ... from</code> или <code>export type ... from</code>.</p>

<p>Примечание: это не относится к экспорту определений типов, т.е. <code>export type Foo =
...;</code>.</p>

<pre><code class="language-ts bad">import type {Foo} from './foo';
export type {Bar} from './bar';
</code></pre>

<p>Вместо этого просто используйте обычный импорт:</p>

<pre><code class="language-ts good">import {Foo} from './foo';
export {Bar} from './bar';
</code></pre>

<p>TypeScript tooling automatically distinguishes symbols used as types vs symbols
used as values and only generates runtime loads for the latter.</p>

<section class="zippy">
Why?

<p>TypeScript tooling automatically handles the distinction and does not insert
runtime loads for type references. This gives a better developer UX: toggling
back and forth between <code>import type</code> and <code>import</code> is bothersome. At the same
time, <code>import type</code> gives no guarantees: your code might still have a hard
dependency on some import through a different transitive path.</p>

<p>If you need to force a runtime load for side effects, use <code>import '...';</code>. See
</p>

<p><code>export type</code> might seem useful to avoid ever exporting a value symbol for an
API. However it does not give guarantees either: downstream code might still
import an API through a different path. A better way to split &amp; guarantee type
vs value usages of an API is to actually split the symbols into e.g.
<code>UserService</code> and <code>AjaxUserService</code>. This is less error prone and also better
communicates intent.</p>

</section>

<h3 id="organize-by-feature">Organize By Feature</h3>

<p>Organize packages by feature, not by type. For example, an online shop <em>should</em>
have packages named <code>products</code>, <code>checkout</code>, <code>backend</code>, not <del><code>views</code>, <code>models</code>,
<code>controllers</code></del>.</p>

<h2 id="type-system">Система типов</h2>

<h3 id="type-inference">Вывод типа</h3>

<p>Code may rely on type inference as implemented by the TypeScript compiler for
all type expressions (variables, fields, return types, etc). The google3
compiler flags reject code that does not have a type annotation and cannot be
inferred, so all code is guaranteed to be typed (but might use the <code>any</code> type
explicitly).</p>

<pre><code class="language-ts good">const x = 15;  // Type inferred.
</code></pre>

<p>Leave out type annotations for trivially inferred types: variables or parameters
initialized to a <code>string</code>, <code>number</code>, <code>boolean</code>, <code>RegExp</code> literal or <code>new</code>
expression.</p>

<pre><code class="language-ts bad">const x: boolean = true;  // Bad: 'boolean' here does not aid readability
</code></pre>

<pre><code class="language-ts bad">// Bad: 'Set' is trivially inferred from the initialization
const x: Set&lt;string&gt; = new Set();
</code></pre>

<pre><code class="language-ts good">const x = new Set&lt;string&gt;();
</code></pre>

<p>For more complex expressions, type annotations can help with readability of the
program. Whether an annotation is required is decided by the code reviewer.</p>

<h4 id="return-types">Return types</h4>

<p>Whether to include return type annotations for functions and methods is up to
the code author. Reviewers <em>may</em> ask for annotations to clarify complex return
types that are hard to understand. Projects <em>may</em> have a local policy to always
require return types, but this is not a general TypeScript style requirement.</p>

<p>There are two benefits to explicitly typing out the implicit return values of
functions and methods:</p>

<ul>
<li>More precise documentation to benefit readers of the code.</li>
<li>Surface potential type errors faster in the future if there are code changes
that change the return type of the function.</li>
</ul>

<h3 id="null-vs-undefined">Null vs Undefined</h3>

<p>TypeScript supports <code>null</code> and <code>undefined</code> types. Nullable types can be
constructed as a union type (<code>string|null</code>); similarly with <code>undefined</code>. There
is no special syntax for unions of <code>null</code> and <code>undefined</code>.</p>

<p>TypeScript code can use either <code>undefined</code> or <code>null</code> to denote absence of a
value, there is no general guidance to prefer one over the other. Many
JavaScript APIs use <code>undefined</code> (e.g. <code>Map.get</code>), while many DOM and Google APIs
use <code>null</code> (e.g. <code>Element.getAttribute</code>), so the appropriate absent value
depends on the context.</p>

<h4 id="nullableundefined-type-aliases">Nullable/undefined type aliases</h4>

<p>Type aliases <em>must not</em> include <code>|null</code> or <code>|undefined</code> in a union type.
Nullable aliases typically indicate that null values are being passed around
through too many layers of an application, and this clouds the source of the
original issue that resulted in <code>null</code>. They also make it unclear when specific
values on a class or interface might be absent.</p>

<p>Instead, code <em>must</em> only add <code>|null</code> or <code>|undefined</code> when the alias is actually
used. Code <em>should</em> deal with null values close to where they arise, using the
above techniques.</p>

<pre><code class="language-ts bad">// Bad
type CoffeeResponse = Latte|Americano|undefined;

class CoffeeService {
  getLatte(): CoffeeResponse { ... };
}
</code></pre>

<pre><code class="language-ts good">// Better
type CoffeeResponse = Latte|Americano;

class CoffeeService {
  getLatte(): CoffeeResponse|undefined { ... };
}
</code></pre>

<pre><code class="language-ts good">// Best
type CoffeeResponse = Latte|Americano;

class CoffeeService {
  getLatte(): CoffeeResponse {
    return assert(fetchResponse(), 'Coffee maker is broken, file a ticket');
  };
}
</code></pre>

<h4 id="optionals-vs-undefined-type">Опциональные свойства & тип <code>|undefined</code></h4>

<p>Также язык TypeScript поддерживает специальную конструкцию для опциональных параметров и полей, используя <code>?</code>:</p>

<pre><code class="language-ts good">interface CoffeeOrder {
  sugarCubes: number;
  milk?: Whole|LowFat|HalfHalf;
}

function pourCoffee(volume?: Milliliter) { ... }
</code></pre>

<p>Опциональные параметры неявно включают <code>|undefined</code> в свой тип. Однако они отличаются тем, что их можно не указывать при составлении выражения или вызове метода. Например, <code>{sugarCubes: 1}</code> является валидным <code>CoffeeOrder</code> поскольку <code>milk</code> является опциональным.</p>

<p>Используйте опциональные поля (в интерфейсах или классах) и параметры вместо <code>|undefined</code> типов.</p>

<p>Для классов лучше вообще избегать этого приёма и инициализировать как можно больше полей.</p>

<pre><code class="language-ts good">class MyClass {
  field = '';
}
</code></pre>

<h3 id="structural-types-vs-nominal-types">Structural Types vs Nominal Types</h3>

<p>TypeScript's type system is structural, not nominal. That is, a value matches a
type if it has at least all the properties the type requires and the properties'
types match, recursively.</p>

<p>Use structural typing where appropriate in your code. Outside of test code, use
interfaces to define structural types, not classes. In test code it can be
useful to have mock implementations structurally match the code under test
without introducing an extra interface.</p>

<p>When providing a structural-based implementation, explicitly include the type at
the declaration of the symbol (this allows more precise type checking and error
reporting).</p>

<pre><code class="language-ts good">const foo: Foo = {
  a: 123,
  b: 'abc',
}
</code></pre>

<pre><code class="language-ts bad">const badFoo = {
  a: 123,
  b: 'abc',
}
</code></pre>

<section class="zippy">
Why?

<p>The <q>badFoo</q> object above relies on type inference. Additional fields could be
added to <q>badFoo</q> and the type is inferred based on the object itself.</p>

<p>When passing a <q>badFoo</q> to a function that takes a <q>Foo</q>, the error will be at
the function call site, rather than at the object declaration site. This is also
useful when changing the surface of an interface across broad codebases.</p>

<pre><code class="language-ts">interface Animal {
  sound: string;
  name: string;
}

function makeSound(animal: Animal) {}

/**
 * 'cat' has an inferred type of '{sound: string}'
 */
const cat = {
  sound: 'meow',
};

/**
 * 'cat' does not meet the type contract required for the function, so the
 * TypeScript compiler errors here, which may be very far from where 'cat' is
 * defined.
 */
makeSound(cat);

/**
 * Horse has a structural type and the type error shows here rather than the
 * function call.  'horse' does not meet the type contract of 'Animal'.
 */
const horse: Animal = {
  sound: 'niegh',
};

const dog: Animal = {
  sound: 'bark',
  name: 'MrPickles',
};

makeSound(dog);
makeSound(horse);
</code></pre>

</section>

<h3 id="interfaces-vs-type-aliases">Интерфейсы и псевдонимы типов</h3>

<p>TypeScript supports
<a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases">type aliases</a>
for naming a type expression. This can be used to name primitives, unions,
tuples, and any other types.</p>

<p>However, when declaring types for objects, use interfaces instead of a type
alias for the object literal expression.</p>

<pre><code class="language-ts good">interface User {
  firstName: string;
  lastName: string;
}
</code></pre>

<pre><code class="language-ts bad">type User = {
  firstName: string,
  lastName: string,
}
</code></pre>

<section class="zippy">
Why?

<p>These forms are nearly equivalent, so under the principle of just choosing one
out of two forms to prevent variation, we should choose one. Additionally, there
also
<a href="https://ncjamieson.com/prefer-interfaces/">interesting technical reasons to prefer interface</a>.
That page quotes the TypeScript team lead: <q>Honestly, my take is that it should
really just be interfaces for anything that they can model. There is no benefit
to type aliases when there are so many issues around display/perf.</q>
</p></section>

<h3 id="arrayt-type">Тип <code>Array&lt;T&gt;</code></h3>

<p>Для простых типов (содержащих только буквенно-цифровые символы и точку) используйте синтаксический сахар для массивов, <code>T[]</code>, а не более длинную форму <code>Array&lt;T&gt;</code>.</p>

<p>Для чего-то более сложного используйте более длинную форму <code>Array&lt;T&gt;</code>.</p>

<p>Это также относится к <code>readonly T[]</code> и <code>ReadonlyArray&lt;T&gt;</code>.</p>

<pre><code class="language-ts good">const a: string[];
const b: readonly string[];
const c: ns.MyObj[];
const d: Array&lt;string|number&gt;;
const e: ReadonlyArray&lt;string|number&gt;;
</code></pre>

<pre><code class="language-ts bad">const f: Array&lt;string&gt;;            //  синтаксический сахар короче 
const g: ReadonlyArray&lt;string&gt;;
const h: {n: number, s: string}[]; // the braces/parens make it harder to read
const i: (string|number)[];
const j: readonly (string|number)[];
</code></pre>

<h3 id="indexable-key-string-number-type">Индексируемый (<code>{[key: string]: number}</code>) тип</h3>

<p>В JavaScript принято использовать объект в качестве ассоциативного массива (он же <q>карта (map)</q>,
  <q>хеш-таблица</q>, или <q>словарь</q>):</p>

<pre><code class="language-ts">const fileSizes: {[fileName: string]: number} = {};
fileSizes['readme.txt'] = 541;
</code></pre>

<p>In TypeScript, provide a meaningful label for the key. (The label only exists
for documentation; it's unused otherwise.)</p>

<pre><code class="language-ts bad">const users: {[key: string]: number} = ...;
</code></pre>

<pre><code class="language-ts good">const users: {[userName: string]: number} = ...;
</code></pre>

<blockquote>
<p>Вместо использования одного из тех вариантов, рассмотрите возможность использования типов ES6 <code>Map</code> и <code>Set</code>. Объекты JavaScript обладают довольно <a href="http://2ality.com/2012/01/objects-as-maps.html">неожиданным нежелательным поведением</a>, а типы ES6 более явно передают ваши намерения. Также, <code>Set</code>могут хранить значения, а <code>Map</code> еще и ключи, отличные от <code>string</code>.</p>
</blockquote>

<p>Встроенный в TypeScript тип <code>Record&lt;Keys, ValueType&gt;</code> позволяет создавать типы с определенным набором ключей. Это отличается от ассоциативных массивов тем, что ключи известны статически. См. рекомендации по этому вопросу <a href="#mapped-conditional-types">ниже</a>.</p>

<h3 id="mapped-conditional-types">Mapped &amp; Conditional Types</h3>

<p>TypeScript's
<a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types">mapped types</a>
and
<a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types">conditional types</a>
allow specifying new types based on other types. TypeScript's standard library
includes several type operators based on these (<code>Record</code>, <code>Partial</code>, <code>Readonly</code>
etc).</p>

<p>These type system features allow succinctly specifying types and constructing
powerful yet type safe abstractions. They come with a number of drawbacks
though:</p>

<ul>
<li>Compared to explicitly specifying properties and type relations (e.g. using
interfaces and extension, see below for an example), type operators require
the reader to mentally evaluate the type expression. This can make programs
substantially harder to read, in particular combined with type inference and
expressions crossing file boundaries.</li>
<li>Mapped &amp; conditional types' evaluation model, in particular when combined
with type inference, is underspecified, not always well understood, and
often subject to change in TypeScript compiler versions. Code can
<q>accidentally</q> compile or seem to give the right results. This increases
future support cost of code using type operators.</li>
<li>Mapped &amp; conditional types are most powerful when deriving types from
complex and/or inferred types. On the flip side, this is also when they are
most prone to create hard to understand and maintain programs.</li>
<li>Some language tooling does not work well with these type system features.
E.g. your IDE's find references (and thus rename property refactoring) will
not find properties in a <code>Pick&lt;T, Keys&gt;</code> type, and Code Search won't
hyperlink them.</li>
<li>
</ul>

<p>The style recommendation is:</p>

<ul>
<li>Always use the simplest type construct that can possibly express your code.</li>
<li>A little bit of repetition or verbosity is often much cheaper than the long
term cost of complex type expressions.</li>
<li>Mapped &amp; conditional types may be used, subject to these considerations.</li>
</ul>

<section class="zippy">
For example, TypeScript's builtin <code>Pick&lt;T, Keys&gt;</code> type allows creating a new
type by subsetting another type <code>T</code>, but simple interface extension can often be
easier to understand.

<pre><code class="language-ts">interface User {
  shoeSize: number;
  favoriteIcecream: string;
  favoriteChocolate: string;
}

// FoodPreferences has favoriteIcecream and favoriteChocolate, but not shoeSize.
type FoodPreferences = Pick&lt;User, 'favoriteIcecream'|'favoriteChocolate'&gt;;
</code></pre>

<p>This is equivalent to spelling out the properties on <code>FoodPreferences</code>:</p>

<pre><code class="language-ts">interface FoodPreferences {
  favoriteIcecream: string;
  favoriteChocolate: string;
}
</code></pre>

<p>To reduce duplication, <code>User</code> could extend <code>FoodPreferences</code>, or (possibly
better) nest a field for food preferences:</p>

<pre><code class="language-ts good">interface FoodPreferences { /* as above */ }
interface User extends FoodPreferences {
  shoeSize: number;
  // also includes the preferences.
}
</code></pre>

<p>Using interfaces here makes the grouping of properties explicit, improves IDE
support, allows better optimization, and arguably makes the code easier to
understand.
</p></section>

<h3 id="any">Тип <code>any</code></h3>

<p>TypeScript's <code>any</code> type is a super and subtype of all other types, and allows
dereferencing all properties. As such, <code>any</code> is dangerous - it can mask severe
programming errors, and its use undermines the value of having static types in
the first place.</p>

<section>
<strong>Подумайте о том, чтобы <em>не</em> использовать <code>any</code>.</strong> В тех обстоятельствах, в которых вы захотите использовать <code>any</code>, рассмотрите один из вариантов:
</section>

<ul>
<li><a href="#any-specific">Указать более конкретный тип</a></li>
<li><a href="#any-unknown">Использовать <code>unknown</code></a></li>
<li><a href="#any-suppress">Подавить предупреждение анализатора кода и задокументировать, почему </a></li>
</ul>

<h4 id="any-specific">Providing a more specific type</h4>

<p>Use interfaces , an inline object type, or
a type alias:</p>

<pre><code class="language-ts good">// Use declared interfaces to represent server-side JSON.
declare interface MyUserJson {
  name: string;
  email: string;
}

// Use type aliases for types that are repetitive to write.
type MyType = number|string;

// Or use inline object types for complex returns.
function getTwoThings(): {something: number, other: string} {
  // ...
  return {something, other};
}

// Use a generic type, where otherwise a library would say `any` to represent
// they don't care what type the user is operating on (but note "Return type
// only generics" below).
function nicestElement&lt;T&gt;(items: T[]): T {
  // Find the nicest element in items.
  // Code can also put constraints on T, e.g. &lt;T extends HTMLElement&gt;.
}
</code></pre>

<h4 id="any-unknown">Using <code>unknown</code> over <code>any</code></h4>

<p>The <code>any</code> type allows assignment into any other type and dereferencing any
property off it. Often this behaviour is not necessary or desirable, and code
just needs to express that a type is unknown. Use the built-in type <code>unknown</code> in
that situation — it expresses the concept and is much safer as it does not allow
dereferencing arbitrary properties.</p>

<pre><code class="language-ts good">// Can assign any value (including null or undefined) into this but cannot
// use it without narrowing the type or casting.
const val: unknown = value;
</code></pre>

<pre><code class="language-ts bad">const danger: any = value /* result of an arbitrary expression */;
danger.whoops();  // This access is completely unchecked!
</code></pre>

<section>
To safely use <code>unknown</code> values, narrow the type using a
<a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types">type guard</a>
</section>

<h4 id="any-suppress">Suppressing <code>any</code> lint warnings</h4>

<p>Sometimes using <code>any</code> is legitimate, for example in tests to construct a mock
object. In such cases, add a comment that suppresses the lint warning, and
document why it is legitimate.</p>

<pre><code class="language-ts good">// This test only needs a partial implementation of BookService, and if
// we overlooked something the test will fail in an obvious way.
// This is an intentionally unsafe partial mock
// tslint:disable-next-line:no-any
const mockBookService = ({get() { return mockBook; }} as any) as BookService;
// Shopping cart is not used in this test
// tslint:disable-next-line:no-any
const component = new MyComponent(mockBookService, /* unused ShoppingCart */ null as any);
</code></pre>

<h3 id="tuple-types">Tuple Types</h3>

<p>If you are tempted to create a Pair type, instead use a tuple type:</p>

<pre><code class="language-ts bad">interface Pair {
  first: string;
  second: string;
}
function splitInHalf(input: string): Pair {
  ...
  return {first: x, second: y};
}
</code></pre>

<pre><code class="language-ts good">function splitInHalf(input: string): [string, string] {
  ...
  return [x, y];
}

// Use it like:
const [leftHalf, rightHalf] = splitInHalf('my string');
</code></pre>

<p>However, often it's clearer to provide meaningful names for the properties.</p>

<p>If declaring an <code>interface</code> is too heavyweight, you can use an inline object
literal type:</p>

<pre><code class="language-ts good">function splitHostPort(address: string): {host: string, port: number} {
  ...
}

// Use it like:
const address = splitHostPort(userAddress);
use(address.port);

// You can also get tuple-like behavior using destructuring:
const {host, port} = splitHostPort(userAddress);
</code></pre>

<h3 id="wrapper-types">Типы-обертки</h3>

<p>Есть несколько типов, связанных с примитивами JavaScript, которые никогда не следует использовать:</p>

<ul>
<li><code>String</code>, <code>Boolean</code>, и <code>Number</code> имеют несколько иное значение, чем соответствующие примитивные типы <code>string</code>, <code>boolean</code>, and <code>number</code>. Всегда используйте версию со строчными буквами.</li>

<li><code>Object</code> has similarities to both <code>{}</code> and <code>object</code>, but is slightly looser.
Use <code>{}</code> for a type that include everything except <code>null</code> and <code>undefined</code>,
or lowercase <code>object</code> to further exclude the other primitive types (the
three mentioned above, plus <code>symbol</code> and <code>bigint</code>).</li>
</ul>

<p>Кроме того, никогда не вызывайте типы-обертки в качестве конструкторов (с помощью <code>new</code>).</p>

<h3 id="return-type-only-generics">Return type only generics</h3>

<p>Avoid creating APIs that have return type only generics. When working with
  existing APIs that have return type only generics always explicitly specify the
  generics.</p>

<h2 id="consistency">Consistency</h2>

<p>For any style question that isn't settled definitively by this specification, do
what the other code in the same file is already doing (<q>be consistent</q>). If that
doesn't resolve the question, consider emulating the other files in the same
directory.</p>

<h3 id="goals">Goals</h3>

<p>In general, engineers usually know best about what's needed in their code, so if
there are multiple options and the choice is situation dependent, we should let
decisions be made locally. So the default answer should be <q>leave it out</q>.</p>

<p>The following points are the exceptions, which are the reasons we have some
global rules. Evaluate your style guide proposal against the following:</p>

<ol>
<li><p><strong>В коде рекомендуется избегать шаблонов, которые известны как вызывающие проблемы, особенно для пользователей, только начинающих изучать язык.</strong></p>

<p>Примеры:</p>

<ul>
  <li>Типом <code>any</code> легко злоупотребить (<em>действительно</em> ли эта переменная может быть и числом, и вызываться как функция?),поэтому у нас есть рекомендации по его использованию.</li>
<li>В TypeScript пространство имен (<code>namespace</code>) создает проблемы с оптимизациями Closure.</li>
<li>Точки в именах файлов делают их уродливыми/запутанными для импорта из JavaScript.</li>
<li>Static functions in classes optimize confusingly, while often file-level
functions accomplish the same goal.</li>
<li>Users unaware of the <code>private</code> keyword will attempt to obfuscate their
function names with underscores.</li>
</ul></li>
<li><p><strong>Code across
projects should be consistent across
irrelevant variations.</strong></p>

<p>When there are two options that are equivalent in a superficial way, we
should consider choosing one just so we don't divergently evolve for no
reason and avoid pointless debates in code reviews.</p>

<p>We should usually match JavaScript style as well, because people often write
both languages together.</p>

<p>Примеры:</p>

<ul>
<li>The capitalization style of names.</li>
<li><code>x as T</code> syntax vs the equivalent <code>&lt;T&gt;x</code> syntax (disallowed).</li>
<li><code>Array&lt;[number, number]&gt;</code> vs <code>[number, number][]</code>.</li>
</ul></li>
<li><p><strong>Code should be maintainable in the long term.</strong></p>

<p>Code usually lives longer than the original author works on it, and the
TypeScript team must keep all of Google working into the future.</p>

<p>Примеры:</p>

<ul>
<li>We use software to automate changes to code, so code is autoformatted so
it's easy for software to meet whitespace rules.</li>
<li>We require a single set of Closure compilation flags, so a given TS
library can be written assuming a specific set of flags, and users can
always safely use a shared library.</li>
<li>Code must import the libraries it uses (<q>strict deps</q>) so that a
refactor in a dependency doesn't change the dependencies of its users.</li>
<li>We ask users to write tests. Without tests we cannot have confidence
that changes that we make to the language, or google3-wide library
changes, don't break users.</li>
</ul></li>
<li><p><strong>Code reviewers should be focused on improving the quality of the code, not
enforcing arbitrary rules.</strong></p>

<p>If it's possible to implement your rule as an

automated check that is often a good sign.
This also supports principle 3.</p>

<p>If it really just doesn't matter that much -- if it's an obscure corner of
the language or if it avoids a bug that is unlikely to occur -- it's
probably worth leaving out.</p></li>
</ol>

</div>
</body>
</html>