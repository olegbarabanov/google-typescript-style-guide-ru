# Google TypeScript - руководство по стилю написания кода
# TypeScript - руководство по стилю написания кода

Это внешнее руководство, основанное на внутренней версии Google, но адаптированное для более широкой аудитории. Для этой версии руководства не существует какого-либо механизма автоматического развертывания, поскольку она предоставляется волонтерами в ответ на запросы пользователей. 
В нем содержатся как правила, так и лучшие практики. Выберите те, которые лучше всего подходят для вашей команды.

Данное руководство ссылается на терминологию стандарта [RFC 2119](https://tools.ietf.org/html/rfc2119) при использовании фраз *ДОЛЖНЫ*, *НЕ ДОЛЖНЫ*, *РЕКОМЕНДУЕТСЯ*, *НЕ РЕКОМЕНДУЕТСЯ*, и *ВОЗМОЖНО*. Все приведенные примеры не носят нормативного характера и служат лишь для иллюстрации стандартных формулировок из данного руководства по стилю.

## Синтаксис
### Идентификаторы

Идентификаторы должны использовать только ASCII символы, цифры, символы подчеркивания (для констант и названий методов структурных тестов) и знак '\('. Таким образом, каждое допустимое имя идентификатора соответствует регулярному выражению `[\)\w]+`.

| Стиль | Категория |
|-----|---------|
| `UpperCamelCase` | класс / интерфейс / тип / перечисление / декоратор / параметр типа|
| `lowerCamelCase` | переменная / параметр / функция / метод / свойство / module alias|
| `CONSTANT_CASE` | глобальные константы, включая имена элементов перечислений|
| `#ident` | идентификаторы приватного доступа никогда не используются.|

- **Аббревиатуры**: Рассматривайте используемые в именах аббревиатуры типа акронимов как целые слова, т.е. используйте `loadHttpUrl`, а не `loadHTTPURL`, если только это не обусловлено названием конкретной платформы (например `XMLHttpRequest`).
- **Знак доллара**: В идентификаторах, как правило, не рекомендуется использовать символ `$`, за исключением случаев, когда это соответствуют соглашениям об именовании для сторонних фреймворков. Подробнее об использовании суффикса `$` для наблюдаемых (`Observable`) значений [см. ниже](/#naming-style).
- **Параметры типа**: Параметры типов, как например в `Array<T>`, могут использовать один символ верхнего регистра (`T`) или `UpperCamelCase`.
- **Названия тестов**: Название тестовых методов в Closure `testSuite` и подобных тестовых фреймворках в стиле xUnit могут быть представлены с разделителями `_`, например `testX_whenY_doesZ()`.
- `_` **префикс/суффикс**: Идентификаторы не должны использовать `_` в качестве префикса или суффикса.  
Это также означает что символ `_` сам по себе не должен быть использован в качестве идентификатора (например, чтобы указать, что параметр не используется).
   > Совет: Если вам нужны только некоторые элементы из массива (или TypeScript кортежа), вы можете вставить дополнительные запятые в выражение деструктуризации, чтобы игнорировать промежуточные элементы:
  ```ts
  const [a, , b] = [1, 5, 10];  // a <- 1, b <- 10
  ```
- **Импорты**: Импорты пространств имен модулей имеют верблюжий регистр (`lowerCamelCase`) в то время как файлы имеют змеиный регистр (`snake_case`), что означает, что корректные импорты не будут совпадать по стилю написания, например:  
  ```ts
  import * as fooBar from './foo_bar';
  ```  
  Некоторые библиотеки могут широко использовать префиксы для импорта пространств имен, которые противоречат этой схеме именования, но широко распространенное использование в открытых источниках делает этот нарушающий стиль более понятным. Единственными библиотеками, которые в настоящее время подпадают под это исключение, являются:  
  + [jquery](https://jquery.com), использует `$` как префикс
  + [threejs](https://threejs.org), использует `THREE` как префикс

- **Константы**: `CONSTANT_CASE` указывает на то, что значение *не предназначено* для изменений и может быть использовано для тех значений, что могут быть изменены технически (т.е. значений, которые не являются глубоко замороженными) но не должны изменяться пользователями.  
  ```ts
  const UNIT_SUFFIXES = {
    'milliseconds': 'ms',
    'seconds': 's',
  };
  // Несмотря на то, что в соответствии с правилами JavaScript UNIT_SUFFIXES является изменяемым,
  // верхний регистр символов обозначает для пользователей, что они не должны изменять значения.
  ```

  Константой также может быть статическое свойство класса, которое предназначенно только для чтения (`static readonly`).

  ```ts
  class Foo {
    private static readonly MY_SPECIAL_NUMBER = 5;

    bar() {
      return 2 * Foo.MY_SPECIAL_NUMBER;
    }
  }
  ```

  Если во время работы программы значение создается более одного раза, или если пользователи каким-либо образом изменяют его, то для этого должен использоваться `lowerCamelCase` стиль.

  Если значение представляет собой стрелочную функцию которая реализует интерфейс, тогда это может быть обьявлено в `lowerCamelCase` стиле.
  
#### Псевдонимы
При создании локального псевдонима существующего элемента, используйте формат уже существующего его обозначения. Локальный псевдоним должен совпадать с существующим именем и форматом источника. Для переменных используйте `const` для локальных псевдонимов, а для полей класса - атрибут `readonly`.
```ts
const {Foo} = SomeType;
const CAPACITY = 5;

class Teapot {
  readonly BrewStateEnum = BrewStateEnum;
  readonly CAPACITY = CAPACITY;
}
```

#### Стиль именования

TypeScript отражает информацию в типах, поэтому имена *не рекомендуется* дополнять информацией, которая включена в тип. (См. также [Блог о тестировании (Testing Blog)](https://testing.googleblog.com/2017/10/code-health-identifiernamingpostforworl.html) для получения дополнительной информации о том, что не следует включать.)

Несколько конкретных примеров для этого правила:
- Не используйте начальные или завершащие символы подчеркивания для приватных свойств или методов.
- Не используйте префикс `opt_` для необязательных параметров.
  + Для аксессоров, см. ниже [правила использования аксессоров](/#getters-and-setters-accessors).
- Не стоит специально помечать интерфейсы (~`IMyInterface`~ или ~`MyFooInterface`~), если только они не идиоматичны в своей среде. Когда вы вводите интерфейс для класса, дайте ему имя, которое выражает причину существования интерфейса (например, `class TodoItem` и `interface TodoItemStorage` если интерфейс выражает формат, используемый для хранения/сериализации в JSON).
- Добавление к наблюдаемым элементам (`Observable`) суффикса `$` является распространенным внешним соглашением и может помочь устранить путаницу между наблюдаемыми и конкретными значениями. Решение о том, является ли это полезным соглашением, остается на усмотрение отдельных команд, но *рекомендуется*, чтобы оно было согласованным в рамках проектов.

#### Описательные названия

Названия *должны* быть описательными и ясными для новых читателей. Не используйте аббревиатуры, которые могут быть незнакомыми или двусмысленными для читателей за пределами вашего проекта и не сокращайте, удаляя в словах буквы.

- **Исключение**: Для переменных, область действия которых составляет не более 10 строк, включая аргументы, которые *не* являются частью экспортируемого API, *возможно* использование коротких (например, однобуквенных) имен переменных.

### Кодировка файлов: UTF-8
Для символов, отличных от ASCII, используйте фактический символ Юникода (например `∞`). Для непечатаемых символов можно использовать эквивалентный шестнадцатеричный код или экранирование Unicode-символов (например `\u221e`) вместе с пояснительным комментарием.

```ts
// Совершенно ясно даже без комментария
const units = 'μs';

// Используйте Unicode-экранирование для непечатаемых символов
const output = '\ufeff' + content; // это маркер последовательности байтов (Unicode BOM)
```

```ts
// Даже с комментарием, это сложно для чтения и подвержено потенциальным ошибкам.
const units = '\u03bcs'; // Греческая буква mu, 's'

// Читающий код не поймет, что это такое
const output = '\ufeff' + content;
```

### Комментарии & Документация
#### Использование JSDoc в сравнении с обычными комментариями
Существует два типа комментариев, JSDoc (`/** ... */`) и не относящиеся к JSDoc обычные комментарии (`// ...` или `/* ... */`).

- Используйте `/** JSDoc */` комментарии для документации. Это те комментарии, с которыми стоит ознакомиться при использовании кода.
- Используйте `// строчные комментарии` для комментирования реализации. Эти комментарии которые касаются только реализации самого кода.

Комментарии JSDoc могут распознаваться различными инструментальными программами, такими как редакторы кода и генераторы документации, в то время как обычные комментарии могут быть распознаны только другими людьми.

#### Правила JSDoc соответствуют стилю языка JavaScript
В общих чертах, следуйте [правилам для JSDoc из руководства по стилю написания JavaScript](https://google.github.io/styleguide/jsguide.html#jsdoc), разделы 7.1 - 7.5. В остальной части этого раздела описываются исключения из этих правил.

#### Документирование всех экспортов верхнего уровня в составе модулей
Используйте `/** JSDoc */` комментарии для передачи информации пользователям вашего кода. Избегайте простого повторения имени свойства или параметра. Вам *рекомендуется* документировать все свойства и методы (экспортируемые/публичные или нет), назначение которых, по мнению вашего рецензента, не сразу очевидно из их названия.

Исключение: элементы, которые экспортируются только для использования инструментальными программами, например классы @NgModule, не требуют комментариев.

#### Исключите те комментарии, которые излишни в TypeScript
Для примера, не указывайте типы в `@param` или `@return` блоках, не пишите `@implements`, `@enum`, `@private` в коде, который использует `implements`, `enum`, `private` и пр. ключевые слова.

#### Не используйте @override
Не используйте `@override` в исходном коде TypeScript.
`@override` не применяется компилятором, что может стать неожиданным сюрпризом и привести к несогласованности аннотаций и реализации. Использование @override только для документирования может привести к путанице.

#### Делайте комментарии, которые действительно добавляют информацию
Для неэкспортируемых элементов иногда достаточно имени и типа функции или параметра. Хотя код *обычно* выигрывает от большего документирования, чем просто имена переменных!
- Избегайте комментариев, в которых просто повторяется имя и тип параметра.
  ```ts
  /** @param fooBarService Сервис "The Bar" для приложения "the Foo". */
  ```
- Исходя из этого правила, строки `@param` и `@return` требуются только тогда, когда они добавляют новую информацию, а иначе их можно исключить.
  ```ts
  /**
   * Отправляет POST-запрос для начала варки кофе.
   * @param amountLitres Количество для заваривания. Должно соответствовать размеру емкости!
   */
  brew(amountLitres: number, logger: Logger) {
    // ...
  }
  ```

#### Комментарии к параметризованным свойствам
Параметризованное свойство — это когда класс объявляет поле и параметр конструктора в одном объявлении путем пометки параметра как свойства в конструкторе. Например `constructor(private readonly foo: Foo)`, объявляет, что класс имеет поле `foo`.
Чтобы задокументировать эти поля, используйте JSDoc `@param` аннотацию. Редакторы отображают описание при вызовах конструктора и доступе к свойствам.

```ts
/** Этот класс демонстрирует, как документируются параметризованные свойства. */
class ParamProps {
  /**
   * @param percolator Кофеварка, используемая для варки.
   * @param beans Зерна для варки.
   */
  constructor(
    private readonly percolator: Percolator,
    private readonly beans: CoffeeBean[]) {}
}
```

```ts
/** Этот класс демонстрирует, как документируются обычные поля. */
class OrdinaryClass {
  /** Кофейные зерна, которые будут использоваться в следующем вызове brew(). */
  nextBean: CoffeeBean;

  constructor(initialBean: CoffeeBean) {
    this.nextBean = initialBean;
  }
}
```

#### Комментарии при вызове функции
При необходимости, документируйте параметры в местах вызова при помощи встраивания блочных комментариев. При этом нет каких-либо четких правил, касательно точного форматирования и размещения комментария. Также рассмотрите возможность применения именованных параметров с использованием литералов объекта и деструктуризации.

```ts
// Встраивание блочных комментариев для параметров, которые трудны для понимания:
new Percolator().brew(/* amountLitres= */ 5);
// Также рассмотрите возможность использования именованных аргументов и деструктуризации параметров (в объявлении метода "brew"):
new Percolator().brew({amountLitres: 5});
```

```ts
/** An ancient {@link CoffeeBrewer} */
export class Percolator implements CoffeeBrewer {
  /**
   * Сварить кофе.
   * @param amountLitres Количество, которое надо сварить. Должен соответствовать объему кофейника!
   */
  brew(amountLitres: number) {
    // Так или иначе, эта реализация создает ужасный кофе.
    // TODO(b/12345): Улучшить процесс варки кофе в кофеварке.
  }
}
```

#### Размещайте документацию перед декораторами
Когда класс, метод или свойство имеют и декораторы вида `@Component` и JsDoc, убедитесь, что JsDoc написан перед декоратором.
- Не пишите JsDoc между декоратором и декорируемым выражением.
  ```ts
  @Component({
    selector: 'foo',
    template: 'bar',
  })
  /** Компонент, который печатает "bar". */
  export class FooComponent {}
  ```
- Пишите блок с JsDoc перед декоратором.
  ```ts
  /** Компонент, который печатает "bar". */
  @Component({
    selector: 'foo',
    template: 'bar',
  })
  export class FooComponent {}
  ```

## Языковые правила
### Видимость

Ограничение видимости свойств, методов и целых типов помогает сохранить код слабо связанным.
- Максимально ограничивайте область видимости обозначений.
- Рассмотрите возможность преобразования приватных методов в неэкспортируемые функции в том же файле, но вне какого-либо класса, а также перемещение приватных свойств в отдельные, неэкспортируемые классы.
- В TypeScript все обозначения по умолчанию публичные. Никогда не используйте модификатор public за исключением случаев объявления публичных свойств параметров, недоступных только для чтения.
```ts
class Foo {
  public bar = new Bar();  // ПЛОХО: нет необходимости в модификаторе "public"

  constructor(public readonly baz: Baz) {}  // ПЛОХО: модификатор "readonly" подразумевает, что это свойство имеет по умолчанию модификатор "public"
}
```

```ts
class Foo {
  bar = new Bar();  // ХОРОШО: нет необходимости в модификаторе "public"

  constructor(public baz: Baz) {}  // допускается модификатор "public"
}
```

См. также [Область видимости экспортируемых элементов](/#export-visibility) ниже.

### Конструкторы
При вызове конструктора всегда должны использоваться скобки, даже если никакие аргументы не передаются:
```ts
const x = new Foo;
```

```ts
const x = new Foo();
```

Нет необходимости предоставлять пустой конструктор или конструктор, который просто делегирует в родительский класс, поскольку ES2015 предоставляет конструктор класса по умолчанию, если он не указан. Однако не следует убирать конструкторы со свойствами параметров, модификаторами или декораторами параметров, даже если тело конструктора пустое.
```ts
class UnnecessaryConstructor {
  constructor() {}
}
```

```ts
class UnnecessaryConstructorOverride extends Base {
    constructor(value: number) {
      super(value);
    }
}
```

```ts
class DefaultConstructor {
}

class ParameterProperties {
  constructor(private myService) {}
}

class ParameterDecorators {
  constructor(@SideEffectDecorator myService) {}
}

class NoInstantiation {
  private constructor() {}
}
```

### Члены класса
#### Не используйте приватные поля вида `#private`
Не используйте приватные поля (также известные как приватные идентификаторы):
```ts
class Clazz {
  #ident = 1;
}
```
Вместо этого используйте поддерживаемые TypeScript аннотации видимости:
```ts
class Clazz {
  private ident = 1;
}
```

Почему?
Приватные идентификаторы вызывают существенные проблемы с размером и производительностью при понижении версии стандарта ECMAScript, в которую будет скомпилирован код TypeScript и не поддерживаются до ES2015. Они могут быть понижены только до уровня ES2015, но не ниже. В то же время, они не дают существенных преимуществ, когда для контроля области видимости используется статическая проверка типов.

#### Используйте модификатор `readonly`
Пометьте модификатором `readonly` те свойства, которые никогда не переназначаются вне конструктора (они не обязательно должны быть глубоко неизменяемыми).

#### Параметризованные свойства
Вместо того чтобы просто передавать очевидный инициализатор в член класса, используйте [параметризованные свойства](/#parameter-properties) TypeScript.

```ts
class Foo {
  private readonly barService: BarService;

  constructor(barService: BarService) {
    this.barService = barService;
  }
}
```

```ts
class Foo {
  constructor(private readonly barService: BarService) {}
}
```

Если параметризованное свойство нуждается в документировании [используйте JSDoc тег `@param`](/#parameter-property-comments).
