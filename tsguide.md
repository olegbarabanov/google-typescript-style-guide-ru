# Google TypeScript - руководство по стилю написания кода
# TypeScript - руководство по стилю написания кода

Это внешнее руководство, основанное на внутренней версии Google, но адаптированное для более широкой аудитории. Для этой версии руководства не существует какого-либо механизма автоматического развертывания, поскольку она предоставляется волонтерами в ответ на запросы пользователей. 
В нем содержатся как правила, так и лучшие практики. Выберите те, которые лучше всего подходят для вашей команды.

Данное руководство ссылается на терминологию стандарта [RFC 2119](https://tools.ietf.org/html/rfc2119) при использовании фраз *ДОЛЖНЫ*, *НЕ ДОЛЖНЫ*, *РЕКОМЕНДУЕТСЯ*, *НЕ РЕКОМЕНДУЕТСЯ*, и *ВОЗМОЖНО*. Все приведенные примеры не носят нормативного характера и служат лишь для иллюстрации стандартных формулировок из данного руководства по стилю.

## Синтаксис
### Идентификаторы

Идентификаторы должны использовать только ASCII символы, цифры, символы подчеркивания (для констант и названий методов структурных тестов) и знак '\('. Таким образом, каждое допустимое имя идентификатора соответствует регулярному выражению `[\)\w]+`.

| Стиль | Категория |
|-----|---------|
| `UpperCamelCase` | класс / интерфейс / тип / перечисление / декоратор / параметр типа|
| `lowerCamelCase` | переменная / параметр / функция / метод / свойство / module alias|
| `CONSTANT_CASE` | глобальные константы, включая имена элементов перечислений|
| `#ident` | идентификаторы приватного доступа никогда не используются.|

- **Аббревиатуры**: Рассматривайте используемые в именах аббревиатуры типа акронимов как целые слова, т.е. используйте `loadHttpUrl`, а не `loadHTTPURL`, если только это не обусловлено названием конкретной платформы (например `XMLHttpRequest`).
- **Знак доллара**: В идентификаторах, как правило, не рекомендуется использовать символ `$`, за исключением случаев, когда это соответствуют соглашениям об именовании для сторонних фреймворков. Подробнее об использовании суффикса `$` для наблюдаемых (`Observable`) значений [см. ниже](/#naming-style).
- **Параметры типа**: Параметры типов, как например в `Array<T>`, могут использовать один символ верхнего регистра (`T`) или `UpperCamelCase`.
- **Названия тестов**: Название тестовых методов в Closure `testSuite` и подобных тестовых фреймворках в стиле xUnit могут быть представлены с разделителями `_`, например `testX_whenY_doesZ()`.
- `_` **префикс/суффикс**: Идентификаторы не должны использовать `_` в качестве префикса или суффикса.  
Это также означает что символ `_` сам по себе не должен быть использован в качестве идентификатора (например, чтобы указать, что параметр не используется).
   > Совет: Если вам нужны только некоторые элементы из массива (или TypeScript кортежа), вы можете вставить дополнительные запятые в выражение деструктуризации, чтобы игнорировать промежуточные элементы:
  ```ts
  const [a, , b] = [1, 5, 10];  // a <- 1, b <- 10
  ```
- **Импорты**: Импорты пространств имен модулей имеют верблюжий регистр (`lowerCamelCase`) в то время как файлы имеют змеиный регистр (`snake_case`), что означает, что корректные импорты не будут совпадать по стилю написания, например:  
  ```ts
  import * as fooBar from './foo_bar';
  ```  
  Некоторые библиотеки могут широко использовать префиксы для импорта пространств имен, которые противоречат этой схеме именования, но широко распространенное использование в открытых источниках делает этот нарушающий стиль более понятным. Единственными библиотеками, которые в настоящее время подпадают под это исключение, являются:  
  + [jquery](https://jquery.com), использует `$` как префикс
  + [threejs](https://threejs.org), использует `THREE` как префикс

- **Константы**: `CONSTANT_CASE` указывает на то, что значение *не предназначено* для изменений и может быть использовано для тех значений, что могут быть изменены технически (т.е. значений, которые не являются глубоко замороженными) но не должны изменяться пользователями.  
  ```ts
  const UNIT_SUFFIXES = {
    'milliseconds': 'ms',
    'seconds': 's',
  };
  // Несмотря на то, что в соответствии с правилами JavaScript UNIT_SUFFIXES является изменяемым,
  // верхний регистр символов обозначает для пользователей, что они не должны изменять значения.
  ```

  Константой также может быть статическое свойство класса, которое предназначенно только для чтения (`static readonly`).

  ```ts
  class Foo {
    private static readonly MY_SPECIAL_NUMBER = 5;

    bar() {
      return 2 * Foo.MY_SPECIAL_NUMBER;
    }
  }
  ```

  Если во время работы программы значение создается более одного раза, или если пользователи каким-либо образом изменяют его, то для этого должен использоваться `lowerCamelCase` стиль.

  Если значение представляет собой стрелочную функцию которая реализует интерфейс, тогда это может быть обьявлено в `lowerCamelCase` стиле.
  
#### Псевдонимы
При создании локального псевдонима существующего элемента, используйте формат уже существующего его обозначения. Локальный псевдоним должен совпадать с существующим именем и форматом источника. Для переменных используйте `const` для локальных псевдонимов, а для полей класса - атрибут `readonly`.
```ts
const {Foo} = SomeType;
const CAPACITY = 5;

class Teapot {
  readonly BrewStateEnum = BrewStateEnum;
  readonly CAPACITY = CAPACITY;
}
```

#### Стиль именования

TypeScript отражает информацию в типах, поэтому имена *не рекомендуется* дополнять информацией, которая включена в тип. (См. также [Блог о тестировании (Testing Blog)](https://testing.googleblog.com/2017/10/code-health-identifiernamingpostforworl.html) для получения дополнительной информации о том, что не следует включать.)

Несколько конкретных примеров для этого правила:
- Не используйте начальные или завершащие символы подчеркивания для приватных свойств или методов.
- Не используйте префикс `opt_` для необязательных параметров.
  + Для аксессоров, см. ниже [правила использования аксессоров](/#getters-and-setters-accessors).
- Не стоит специально помечать интерфейсы (~`IMyInterface`~ или ~`MyFooInterface`~), если только они не идиоматичны в своей среде. Когда вы вводите интерфейс для класса, дайте ему имя, которое выражает причину существования интерфейса (например, `class TodoItem` и `interface TodoItemStorage` если интерфейс выражает формат, используемый для хранения/сериализации в JSON).
- Добавление к наблюдаемым элементам (`Observable`) суффикса `$` является распространенным внешним соглашением и может помочь устранить путаницу между наблюдаемыми и конкретными значениями. Решение о том, является ли это полезным соглашением, остается на усмотрение отдельных команд, но *рекомендуется*, чтобы оно было согласованным в рамках проектов.

#### Описательные названия

Названия *должны* быть описательными и ясными для новых читателей. Не используйте аббревиатуры, которые могут быть незнакомыми или двусмысленными для читателей за пределами вашего проекта и не сокращайте, удаляя в словах буквы.

- **Исключение**: Для переменных, область действия которых составляет не более 10 строк, включая аргументы, которые *не* являются частью экспортируемого API, *возможно* использование коротких (например, однобуквенных) имен переменных.

### Кодировка файлов: UTF-8
Для символов, отличных от ASCII, используйте фактический символ Юникода (например `∞`). Для непечатаемых символов можно использовать эквивалентный шестнадцатеричный код или экранирование Unicode-символов (например `\u221e`) вместе с пояснительным комментарием.

```ts
// Совершенно ясно даже без комментария
const units = 'μs';

// Используйте Unicode-экранирование для непечатаемых символов
const output = '\ufeff' + content; // это маркер последовательности байтов (Unicode BOM)
```

```ts
// Даже с комментарием, это сложно для чтения и подвержено потенциальным ошибкам.
const units = '\u03bcs'; // Греческая буква mu, 's'

// Читающий код не поймет, что это такое
const output = '\ufeff' + content;
```

### Комментарии & Документация
#### Использование JSDoc в сравнении с обычными комментариями
Существует два типа комментариев, JSDoc (`/** ... */`) и не относящиеся к JSDoc обычные комментарии (`// ...` или `/* ... */`).

- Используйте `/** JSDoc */` комментарии для документации. Это те комментарии, с которыми стоит ознакомиться при использовании кода.
- Используйте `// строчные комментарии` для комментирования реализации. Эти комментарии которые касаются только реализации самого кода.

Комментарии JSDoc могут распознаваться различными инструментальными программами, такими как редакторы кода и генераторы документации, в то время как обычные комментарии могут быть распознаны только другими людьми.

#### Правила JSDoc соответствуют стилю языка JavaScript
В общих чертах, следуйте [правилам для JSDoc из руководства по стилю написания JavaScript](https://google.github.io/styleguide/jsguide.html#jsdoc), разделы 7.1 - 7.5. В остальной части этого раздела описываются исключения из этих правил.

#### Документирование всех экспортов верхнего уровня в составе модулей
Используйте `/** JSDoc */` комментарии для передачи информации пользователям вашего кода. Избегайте простого повторения имени свойства или параметра. Вам *рекомендуется* документировать все свойства и методы (экспортируемые/публичные или нет), назначение которых, по мнению вашего рецензента, не сразу очевидно из их названия.

Исключение: элементы, которые экспортируются только для использования инструментальными программами, например классы @NgModule, не требуют комментариев.

#### Исключите те комментарии, которые излишни в TypeScript
Для примера, не указывайте типы в `@param` или `@return` блоках, не пишите `@implements`, `@enum`, `@private` в коде, который использует `implements`, `enum`, `private` и пр. ключевые слова.

#### Не используйте @override
Не используйте `@override` в исходном коде TypeScript.
`@override` не применяется компилятором, что может стать неожиданным сюрпризом и привести к несогласованности аннотаций и реализации. Использование @override только для документирования может привести к путанице.

#### Делайте комментарии, которые действительно добавляют информацию
Для неэкспортируемых элементов иногда достаточно имени и типа функции или параметра. Хотя код *обычно* выигрывает от большего документирования, чем просто имена переменных!
- Избегайте комментариев, в которых просто повторяется имя и тип параметра.
  ```ts
  /** @param fooBarService Сервис "The Bar" для приложения "the Foo". */
  ```
- Исходя из этого правила, строки `@param` и `@return` требуются только тогда, когда они добавляют новую информацию, а иначе их можно исключить.
  ```ts
  /**
   * Отправляет POST-запрос для начала варки кофе.
   * @param amountLitres Количество для заваривания. Должно соответствовать размеру емкости!
   */
  brew(amountLitres: number, logger: Logger) {
    // ...
  }
  ```

#### Комментарии к параметризованным свойствам
Параметризованное свойство — это когда класс объявляет поле и параметр конструктора в одном объявлении путем пометки параметра как свойства в конструкторе. Например `constructor(private readonly foo: Foo)`, объявляет, что класс имеет поле `foo`.
Чтобы задокументировать эти поля, используйте JSDoc `@param` аннотацию. Редакторы отображают описание при вызовах конструктора и доступе к свойствам.

```ts
/** Этот класс демонстрирует, как документируются параметризованные свойства. */
class ParamProps {
  /**
   * @param percolator Кофеварка, используемая для варки.
   * @param beans Зерна для варки.
   */
  constructor(
    private readonly percolator: Percolator,
    private readonly beans: CoffeeBean[]) {}
}
```

```ts
/** Этот класс демонстрирует, как документируются обычные поля. */
class OrdinaryClass {
  /** Кофейные зерна, которые будут использоваться в следующем вызове brew(). */
  nextBean: CoffeeBean;

  constructor(initialBean: CoffeeBean) {
    this.nextBean = initialBean;
  }
}
```

#### Комментарии при вызове функции
При необходимости, документируйте параметры в местах вызова при помощи встраивания блочных комментариев. При этом нет каких-либо четких правил, касательно точного форматирования и размещения комментария. Также рассмотрите возможность применения именованных параметров с использованием литералов объекта и деструктуризации.

```ts
// Встраивание блочных комментариев для параметров, которые трудны для понимания:
new Percolator().brew(/* amountLitres= */ 5);
// Также рассмотрите возможность использования именованных аргументов и деструктуризации параметров (в объявлении метода "brew"):
new Percolator().brew({amountLitres: 5});
```

```ts
/** An ancient {@link CoffeeBrewer} */
export class Percolator implements CoffeeBrewer {
  /**
   * Сварить кофе.
   * @param amountLitres Количество, которое надо сварить. Должен соответствовать объему кофейника!
   */
  brew(amountLitres: number) {
    // Так или иначе, эта реализация создает ужасный кофе.
    // TODO(b/12345): Улучшить процесс варки кофе в кофеварке.
  }
}
```

#### Размещайте документацию перед декораторами
Когда класс, метод или свойство имеют и декораторы вида `@Component` и JsDoc, убедитесь, что JsDoc написан перед декоратором.
- Не пишите JsDoc между декоратором и декорируемым выражением.
  ```ts
  @Component({
    selector: 'foo',
    template: 'bar',
  })
  /** Компонент, который печатает "bar". */
  export class FooComponent {}
  ```
- Пишите блок с JsDoc перед декоратором.
  ```ts
  /** Компонент, который печатает "bar". */
  @Component({
    selector: 'foo',
    template: 'bar',
  })
  export class FooComponent {}
  ```

## Языковые правила
### Видимость

Ограничение видимости свойств, методов и целых типов помогает сохранить код слабо связанным.
- Максимально ограничивайте область видимости обозначений.
- Рассмотрите возможность преобразования приватных методов в неэкспортируемые функции в том же файле, но вне какого-либо класса, а также перемещение приватных свойств в отдельные, неэкспортируемые классы.
- В TypeScript все обозначения по умолчанию публичные. Никогда не используйте модификатор public за исключением случаев объявления публичных свойств параметров, недоступных только для чтения.
```ts
class Foo {
  public bar = new Bar();  // ПЛОХО: нет необходимости в модификаторе "public"

  constructor(public readonly baz: Baz) {}  // ПЛОХО: модификатор "readonly" подразумевает, что это свойство имеет по умолчанию модификатор "public"
}
```

```ts
class Foo {
  bar = new Bar();  // ХОРОШО: нет необходимости в модификаторе "public"

  constructor(public baz: Baz) {}  // допускается модификатор "public"
}
```

См. также [Область видимости экспортируемых элементов](/#export-visibility) ниже.

### Конструкторы
При вызове конструктора всегда должны использоваться скобки, даже если никакие аргументы не передаются:
```ts
const x = new Foo;
```

```ts
const x = new Foo();
```

Нет необходимости предоставлять пустой конструктор или конструктор, который просто делегирует в родительский класс, поскольку ES2015 предоставляет конструктор класса по умолчанию, если он не указан. Однако не следует убирать конструкторы со свойствами параметров, модификаторами или декораторами параметров, даже если тело конструктора пустое.
```ts
class UnnecessaryConstructor {
  constructor() {}
}
```

```ts
class UnnecessaryConstructorOverride extends Base {
    constructor(value: number) {
      super(value);
    }
}
```

```ts
class DefaultConstructor {
}

class ParameterProperties {
  constructor(private myService) {}
}

class ParameterDecorators {
  constructor(@SideEffectDecorator myService) {}
}

class NoInstantiation {
  private constructor() {}
}
```

### Члены класса
#### Не используйте приватные поля вида `#private`
Не используйте приватные поля (также известные как приватные идентификаторы):
```ts
class Clazz {
  #ident = 1;
}
```
Вместо этого используйте поддерживаемые TypeScript аннотации видимости:
```ts
class Clazz {
  private ident = 1;
}
```

Почему?
Приватные идентификаторы вызывают существенные проблемы с размером и производительностью при понижении версии стандарта ECMAScript, в которую будет скомпилирован код TypeScript и не поддерживаются до ES2015. Они могут быть понижены только до уровня ES2015, но не ниже. В то же время, они не дают существенных преимуществ, когда для контроля области видимости используется статическая проверка типов.

#### Используйте модификатор `readonly`
Пометьте модификатором `readonly` те свойства, которые никогда не переназначаются вне конструктора (они не обязательно должны быть глубоко неизменяемыми).

#### Параметризованные свойства
Вместо того чтобы просто передавать очевидный инициализатор в член класса, используйте [параметризованные свойства](/#parameter-properties) TypeScript.

```ts
class Foo {
  private readonly barService: BarService;

  constructor(barService: BarService) {
    this.barService = barService;
  }
}
```

```ts
class Foo {
  constructor(private readonly barService: BarService) {}
}
```

Если параметризованное свойство нуждается в документировании [используйте JSDoc тег `@param`](/#parameter-property-comments).

#### Инициализаторы полей

Если элемент класса не является параметризованным свойством,инициализируйте его там, где он объявлен, что иногда позволяет совсем отбросить конструктор.

```ts
class Foo {
  private readonly userList: string[];
  constructor() {
    this.userList = [];
  }
}
```

```ts
class Foo {
  private readonly userList: string[] = [];
}
```

#### Свойства, используемые за пределами лексической области класса

Для свойств, используемых вне лексической области видимости содержащего их класса, например, для свойств контроллера AngularJS, используемых из шаблона, не должна использоваться приватная (`private`) область видимости, поскольку они используются вне лексической области видимости содержащего их класса.

Для этих свойств предпочтительна публичная (`public`) видимость, однако при необходимости можно использовать и защищенную (`protected`) видимость. Например, для свойств используемых в шаблонах Angular и Polymer следует использовать `public`, а в AngularJS - `protected`.

В TypeScript коде не должны использоваться `obj['foo']` для обхода видимости свойства

Почему?
Когда свойство является приватным (`private`), вы объявляете автоматизированным системам и людям, что доступ к свойству ограничен методами объявленного класса, и они будут полагаться на это. Например, проверка на неиспользуемый код отметит приватное свойство, которое может посчитаться неиспользуемым, даже если какому-то коду из другого файла удастся обойти ограничение видимости.

Хотя может показаться, что `obj['foo']` может обойти область видимости в компиляторе TypeScript, эта схема может быть нарушена путем изменения правил сборки, а также нарушается согласованность с оптимизациями.

#### Геттеры и Сеттеры (Аксессоры)

Для членов класса можно иcпользовать геттеры и сеттеры. Методы-геттеры должен быть [чистыми функциями](https://en.wikipedia.org/wiki/Pure_function) (т.е. не имеет побочных эффектов и каждый раз возвращает одинаковый результат при одних и тех же параметрах). Они также полезны как средство ограничения видимости внутренних или подробных деталей реализации (показано ниже).

```ts
class Foo {
  constructor(private readonly someService: SomeService) {}

  get someMember(): string {
    return this.someService.someVariable;
  }

  set someMember(newValue: string) {
    this.someService.someVariable = newValue;
  }
}
```

Если аксессор используется для сокрытия свойства класса, скрытое свойство может иметь префикс или суффикс с любым целым словом, например `internal` или `wrapped`. При использовании этих приватных свойств по возможности обращайтесь к их значению через аксессор. По крайней мере один аксессор к свойству должен быть нетривиальным: не определяйте сквозные аксессоры только для того, чтобы скрыть свойство. Вместо этого сделайте свойство публичным (или подумайте о том, чтобы сделать его доступным только для чтения (`readonly`), чем просто определять геттер без сеттера).

```ts
class Foo {
  private wrappedBar = '';
  get bar() {
    return this.wrappedBar || 'bar';
  }

  set bar(wrapped: string) {
    this.wrappedBar = wrapped.trim();
  }
}
```

```ts
class Bar {
  private barInternal = '';
  // Ни один из этих аксессоров не имеет логики, поэтому просто сделайте bar публичным
  get bar() {
    return this.barInternal;
  }

  set bar(value: string) {
    this.barInternal = value;
  }
}
```

### Примитивные типы & Классы-обертки

Код TypeScript не должен создавать экземпляры классов-оболочек для примитивных типов `String`, `Boolean`, и `Number`. Классы-оболочки имеют удивляющее поведение, такое как `new Boolean(false)` равное `true`.

```ts
const s = new String('hello');
const b = new Boolean(false);
const n = new Number(5);
```

```ts
const s = 'hello';
const b = false;
const n = 5;
```

### Конструктор массива

В коде на Typescript не должны использоваться `Array()` конструкторы, с или без `new`. Его применение неоднозначно и сбивает с толку:

```ts
const a = new Array(2); // [undefined, undefined]
const b = new Array(2, 3); // [2, 3];
```

Вместо этого всегда используйте скобки для инициализации массивов , или `from` для инициализации `Array` с определенным размером:

```ts
const a = [2];
const b = [2, 3];

// Эквивалент для Array(2):
const c = [];
c.length = 2;

// [0, 0, 0, 0, 0]
Array.from<number>({length: 5}).fill(0);
```

### Преобразование типов

В TypeScript коде можно использовать `String()` и `Boolean()` (примечание: без `new`!) функции, строковые шаблонные литералы, или `!!` для преобразования типов.

```ts
const bool = Boolean(false);
const str = String(aNumber);
const bool2 = !!str;
const str2 = `result: ${bool2}`;
```

Не приветствуется для приведения к строке использовать конкатенацию строк, так как при проверке кода мы отслеживаем, чтобы операнды оператора «плюс» имели совпадающие типы.

Код должен использовать `Number()` для парсинга числовых значений, и должен явно проверять его возврат на значения `NaN`, за исключением случаев, когда из контекста точно известно, что сбой парсинга невозможен.

Примечание: `Number('')`, `Number(' ')`, и `Number('\t')` могут вернуть `0` вместо `NaN`. `Number('Infinity')` и `Number('-Infinity')` могут вернуть `Infinity` и `-Infinity` соответственно. Эти случаи могут потребовать особого обращения.

```ts
const aNumber = Number('123');
if (isNaN(aNumber)) throw new Error(...);  // Обрабатываем NaN, если в строке может не быть чисел
assertFinite(aNumber, ...);                // Необязательно: если NaN не может возникнуть, потому что он был проверен ранее.
```

В коде не должен использоваться унарный плюс (`+`) для преобразования строки в число. Парсинг чисел может привести к неудаче, иметь неожиданные исключительные ситуации и может быть признаком дурно пахнущего кода (парсинг чисел не на том уровне). Учитывая это, унарный плюс слишком легко пропустить при проверке кода.

```ts
const x = +y;
```

Код также не должен использовать `parseInt` или `parseFloat` для парсинга чисел, за исключением строк не с десятичными значениями (см. ниже). Обе эти функции игнорируют конечные символы в строке, что может привести к возникновению ошибочного состояния (например, парсинг `12 гномов` как `12`).

```ts
const n = parseInt(someString, 10);  // Подвержено ошибкам,
const f = parseFloat(someString);    // независимо от передачи основания системы счисления.
```

Код, который должен выполнять парсинг числа с использованием системы счисления, должен проверять, является ли его ввод числом, прежде чем вызывать `parseInt`;

```ts
if (!/^[a-fA-F0-9]+$/.test(someString)) throw new Error(...);
  // Требуется для парсинга восьмеричного числа.
// tslint:disable-next-line:ban
const n = parseInt(someString, 16);  // Допустимо только для основания числа != 10
```

Используйте `Number()`, а затем `Math.floor` или `Math.trunc` (там, где это возможно) для парсинга целых чисел:

```ts
let f = Number(someString);
if (isNaN(f)) handleError();
f = Math.floor(f);
```

Не используйте явное булево преобразование в условиях, в которых уже имеется неявное булево преобразование. Это условия в операторах `if`, `for` и `while`.

```ts
const foo: MyInterface|null = ...;
if (!!foo) {...}
while (!!foo) {...}
```

```ts
const foo: MyInterface|null = ...;
if (foo) {...}
while (foo) {...}
```

В коде можно использовать явные сравнения:

```ts
// Явное сравнение > 0 это хорошо:
if (arr.length > 0) {...}
// так же как и полагаться на неявное булево преобразование:
if (arr.length) {...}
```

### Переменные

Всегда используйте `const` или `let` для обьявления переменных. По умолчанию используйте `const`, если не требуется переназначение переменной. Никогда не используйте `var`.

```ts
const foo = otherValue;  // Используйте, если "foo" никогда не меняется.
let bar = someValue;     // Используйте, если для "bar" когда-либо позднее будет присвоено значение 
```

`const` и `let` имеют блочную область видимости, как и переменные в большинстве других языков. `var` в JavaScript ограничен областью действия функции, что может вызвать трудные для понимания ошибки. Не используйте его.

```ts
var foo = someValue;     // Не используйте - область видимости var сложна и подвержена ошибкам.
```

Переменные не должны использоваться до их объявления.

### Исключения

Всегда используйте `new Error()` при создании исключений вместо простого вызова `Error()`. В обоих случаях создается новый экземпляр `Error`, но использование `new` более согласуется с тем, как создаются экземпляры других объектов.

```ts
throw new Error('Foo is not a valid bar.');
```

```ts
throw Error('Foo is not a valid bar.');
```

### Итерация объектов

Итерация объектов с помощью `for (... in ...)` подвержена вероятным ошибкам, т.к. это включает в себя все перечисляемые свойства из цепочки прототипов.

Не используйте не фильтрованные `for (... in ...)` выражения:

```ts
for (const x in someObj) {
  // x может происходить от некоторого родительского прототипа!
}
```

Либо явно отфильтруйте значения с помощью оператора `if`, либо используйте `for (... of Object.keys(...))`.

```ts
for (const x in someObj) {
  if (!someObj.hasOwnProperty(x)) continue;
  // сейчас x был точно определен в принадлежности someObj
}
for (const x of Object.keys(someObj)) { // примечание: for _of_!
  // сейчас x был точно определен в принадлежности someObj
}
for (const [key, value] of Object.entries(someObj)) { // примечание: for _of_!
  // сейчас key был точно определен в принадлежности someObj
}
```

