# Google TypeScript - руководство по стилю написания кода
# TypeScript - руководство по стилю написания кода

Это внешнее руководство, основанное на внутренней версии Google, но адаптированное для более широкой аудитории. Для этой версии руководства не существует какого-либо механизма автоматического развертывания, поскольку она предоставляется волонтерами в ответ на запросы пользователей. 
В нем содержатся как правила, так и лучшие практики. Выберите те, которые лучше всего подходят для вашей команды.

Данное руководство ссылается на терминологию стандарта [RFC 2119](https://tools.ietf.org/html/rfc2119) при использовании фраз *ДОЛЖНЫ*, *НЕ ДОЛЖНЫ*, *РЕКОМЕНДУЕТСЯ*, *НЕ РЕКОМЕНДУЕТСЯ*, и *ВОЗМОЖНО*. Все приведенные примеры не носят нормативного характера и служат лишь для иллюстрации стандартных формулировок из данного руководства по стилю.

## Синтаксис
### Идентификаторы

Идентификаторы должны использовать только ASCII символы, цифры, символы подчеркивания (для констант и названий методов структурных тестов) и знак '\('. Таким образом, каждое допустимое имя идентификатора соответствует регулярному выражению `[\)\w]+`.

| Стиль | Категория |
|-----|---------|
| `UpperCamelCase` | класс / интерфейс / тип / перечисление / декоратор / параметр типа|
| `lowerCamelCase` | переменная / параметр / функция / метод / свойство / module alias|
| `CONSTANT_CASE` | глобальные константы, включая имена элементов перечислений|
| `#ident` | идентификаторы приватного доступа никогда не используются.|

- **Аббревиатуры**: Рассматривайте используемые в именах аббревиатуры типа акронимов как целые слова, т.е. используйте `loadHttpUrl`, а не `loadHTTPURL`, если только это не обусловлено названием конкретной платформы (например `XMLHttpRequest`).
- **Знак доллара**: В идентификаторах, как правило, не рекомендуется использовать символ `$`, за исключением случаев, когда это соответствуют соглашениям об именовании для сторонних фреймворков. Подробнее об использовании суффикса `$` для наблюдаемых (`Observable`) значений [см. ниже](/#naming-style).
- **Параметры типа**: Параметры типов, как например в `Array<T>`, могут использовать один символ верхнего регистра (`T`) или `UpperCamelCase`.
- **Названия тестов**: Название тестовых методов в Closure `testSuite` и подобных тестовых фреймворках в стиле xUnit могут быть представлены с разделителями `_`, например `testX_whenY_doesZ()`.
- `_` **префикс/суффикс**: Идентификаторы не должны использовать `_` в качестве префикса или суффикса.  
Это также означает что символ `_` сам по себе не должен быть использован в качестве идентификатора (например, чтобы указать, что параметр не используется).
   > Совет: Если вам нужны только некоторые элементы из массива (или TypeScript кортежа), вы можете вставить дополнительные запятые в выражение деструктуризации, чтобы игнорировать промежуточные элементы:
  ```ts
  const [a, , b] = [1, 5, 10];  // a <- 1, b <- 10
  ```
- **Импорты**: Импорты пространств имен модулей имеют верблюжий регистр (`lowerCamelCase`) в то время как файлы имеют змеиный регистр (`snake_case`), что означает, что корректные импорты не будут совпадать по стилю написания, например:  
  ```ts
  import * as fooBar from './foo_bar';
  ```  
  Некоторые библиотеки могут широко использовать префиксы для импорта пространств имен, которые противоречат этой схеме именования, но широко распространенное использование в открытых источниках делает этот нарушающий стиль более понятным. Единственными библиотеками, которые в настоящее время подпадают под это исключение, являются:  
  + [jquery](https://jquery.com), использует `$` как префикс
  + [threejs](https://threejs.org), использует `THREE` как префикс

- **Константы**: `CONSTANT_CASE` указывает на то, что значение *не предназначено* для изменений и может быть использовано для тех значений, что могут быть изменены технически (т.е. значений, которые не являются глубоко замороженными) но не должны изменяться пользователями.  
  ```ts
  const UNIT_SUFFIXES = {
    'milliseconds': 'ms',
    'seconds': 's',
  };
  // Несмотря на то, что в соответствии с правилами JavaScript UNIT_SUFFIXES является изменяемым,
  // верхний регистр символов обозначает для пользователей, что они не должны изменять значения.
  ```

  Константой также может быть статическое свойство класса, которое предназначенно только для чтения (`static readonly`).

  ```ts
  class Foo {
    private static readonly MY_SPECIAL_NUMBER = 5;

    bar() {
      return 2 * Foo.MY_SPECIAL_NUMBER;
    }
  }
  ```

  Если во время работы программы значение создается более одного раза, или если пользователи каким-либо образом изменяют его, то для этого должен использоваться `lowerCamelCase` стиль.

  Если значение представляет собой стрелочную функцию которая реализует интерфейс, тогда это может быть обьявлено в `lowerCamelCase` стиле.
  
#### Псевдонимы
При создании локального псевдонима существующего элемента, используйте формат уже существующего его обозначения. Локальный псевдоним должен совпадать с существующим именем и форматом источника. Для переменных используйте `const` для локальных псевдонимов, а для полей класса - атрибут `readonly`.
```ts
const {Foo} = SomeType;
const CAPACITY = 5;

class Teapot {
  readonly BrewStateEnum = BrewStateEnum;
  readonly CAPACITY = CAPACITY;
}
```

#### Стиль именования

TypeScript отражает информацию в типах, поэтому имена *не рекомендуется* дополнять информацией, которая включена в тип. (См. также [Блог о тестировании (Testing Blog)](https://testing.googleblog.com/2017/10/code-health-identifiernamingpostforworl.html) для получения дополнительной информации о том, что не следует включать.)

Несколько конкретных примеров для этого правила:
- Не используйте начальные или завершащие символы подчеркивания для приватных свойств или методов.
- Не используйте префикс `opt_` для необязательных параметров.
  + Для аксессоров, см. ниже [правила использования аксессоров](/#getters-and-setters-accessors).
- Не стоит специально помечать интерфейсы (~`IMyInterface`~ или ~`MyFooInterface`~), если только они не идиоматичны в своей среде. Когда вы вводите интерфейс для класса, дайте ему имя, которое выражает причину существования интерфейса (например, `class TodoItem` и `interface TodoItemStorage` если интерфейс выражает формат, используемый для хранения/сериализации в JSON).
- Добавление к наблюдаемым элементам (`Observable`) суффикса `$` является распространенным внешним соглашением и может помочь устранить путаницу между наблюдаемыми и конкретными значениями. Решение о том, является ли это полезным соглашением, остается на усмотрение отдельных команд, но *рекомендуется*, чтобы оно было согласованным в рамках проектов.

#### Описательные названия

Названия *должны* быть описательными и ясными для новых читателей. Не используйте аббревиатуры, которые могут быть незнакомыми или двусмысленными для читателей за пределами вашего проекта и не сокращайте, удаляя в словах буквы.

- **Исключение**: Для переменных, область действия которых составляет не более 10 строк, включая аргументы, которые *не* являются частью экспортируемого API, *возможно* использование коротких (например, однобуквенных) имен переменных.

### Кодировка файлов: UTF-8
Для символов, отличных от ASCII, используйте фактический символ Юникода (например `∞`). Для непечатаемых символов можно использовать эквивалентный шестнадцатеричный код или экранирование Unicode-символов (например `\u221e`) вместе с пояснительным комментарием.

```ts
// Совершенно ясно даже без комментария
const units = 'μs';

// Используйте Unicode-экранирование для непечатаемых символов
const output = '\ufeff' + content; // это маркер последовательности байтов (Unicode BOM)
```

```ts
// Даже с комментарием, это сложно для чтения и подвержено потенциальным ошибкам.
const units = '\u03bcs'; // Греческая буква mu, 's'

// Читающий код не поймет, что это такое
const output = '\ufeff' + content;
```

### Комментарии & Документация
#### Использование JSDoc в сравнении с обычными комментариями
Существует два типа комментариев, JSDoc (`/** ... */`) и не относящиеся к JSDoc обычные комментарии (`// ...` или `/* ... */`).

- Используйте `/** JSDoc */` комментарии для документации. Это те комментарии, с которыми стоит ознакомиться при использовании кода.
- Используйте `// строчные комментарии` для комментирования реализации. Эти комментарии которые касаются только реализации самого кода.

Комментарии JSDoc могут распознаваться различными инструментальными программами, такими как редакторы кода и генераторы документации, в то время как обычные комментарии могут быть распознаны только другими людьми.

#### Правила JSDoc соответствуют стилю языка JavaScript
В общих чертах, следуйте [правилам для JSDoc из руководства по стилю написания JavaScript](https://google.github.io/styleguide/jsguide.html#jsdoc), разделы 7.1 - 7.5. В остальной части этого раздела описываются исключения из этих правил.

#### Документирование всех экспортов верхнего уровня в составе модулей
Используйте `/** JSDoc */` комментарии для передачи информации пользователям вашего кода. Избегайте простого повторения имени свойства или параметра. Вам *рекомендуется* документировать все свойства и методы (экспортируемые/публичные или нет), назначение которых, по мнению вашего рецензента, не сразу очевидно из их названия.

Исключение: элементы, которые экспортируются только для использования инструментальными программами, например классы @NgModule, не требуют комментариев.

#### Исключите те комментарии, которые излишни в TypeScript
Для примера, не указывайте типы в `@param` или `@return` блоках, не пишите `@implements`, `@enum`, `@private` в коде, который использует `implements`, `enum`, `private` и пр. ключевые слова.

#### Не используйте @override
Не используйте `@override` в исходном коде TypeScript.
`@override` не применяется компилятором, что может стать неожиданным сюрпризом и привести к несогласованности аннотаций и реализации. Использование @override только для документирования может привести к путанице.

#### Делайте комментарии, которые действительно добавляют информацию
Для неэкспортируемых элементов иногда достаточно имени и типа функции или параметра. Хотя код *обычно* выигрывает от большего документирования, чем просто имена переменных!
- Избегайте комментариев, в которых просто повторяется имя и тип параметра.
  ```ts
  /** @param fooBarService Сервис "The Bar" для приложения "the Foo". */
  ```
- Исходя из этого правила, строки `@param` и `@return` требуются только тогда, когда они добавляют новую информацию, а иначе их можно исключить.
  ```ts
  /**
   * Отправляет POST-запрос для начала варки кофе.
   * @param amountLitres Количество для заваривания. Должно соответствовать размеру емкости!
   */
  brew(amountLitres: number, logger: Logger) {
    // ...
  }
  ```

#### Комментарии к параметризованным свойствам
Параметризованное свойство — это когда класс объявляет поле и параметр конструктора в одном объявлении путем пометки параметра как свойства в конструкторе. Например `constructor(private readonly foo: Foo)`, объявляет, что класс имеет поле `foo`.
Чтобы задокументировать эти поля, используйте JSDoc `@param` аннотацию. Редакторы отображают описание при вызовах конструктора и доступе к свойствам.

```ts
/** Этот класс демонстрирует, как документируются параметризованные свойства. */
class ParamProps {
  /**
   * @param percolator Кофеварка, используемая для варки.
   * @param beans Зерна для варки.
   */
  constructor(
    private readonly percolator: Percolator,
    private readonly beans: CoffeeBean[]) {}
}
```

```ts
/** Этот класс демонстрирует, как документируются обычные поля. */
class OrdinaryClass {
  /** Кофейные зерна, которые будут использоваться в следующем вызове brew(). */
  nextBean: CoffeeBean;

  constructor(initialBean: CoffeeBean) {
    this.nextBean = initialBean;
  }
}
```

#### Комментарии при вызове функции
При необходимости, документируйте параметры в местах вызова при помощи встраивания блочных комментариев. При этом нет каких-либо четких правил, касательно точного форматирования и размещения комментария. Также рассмотрите возможность применения именованных параметров с использованием литералов объекта и деструктуризации.

```ts
// Встраивание блочных комментариев для параметров, которые трудны для понимания:
new Percolator().brew(/* amountLitres= */ 5);
// Также рассмотрите возможность использования именованных аргументов и деструктуризации параметров (в объявлении метода "brew"):
new Percolator().brew({amountLitres: 5});
```

```ts
/** An ancient {@link CoffeeBrewer} */
export class Percolator implements CoffeeBrewer {
  /**
   * Сварить кофе.
   * @param amountLitres Количество, которое надо сварить. Должен соответствовать объему кофейника!
   */
  brew(amountLitres: number) {
    // Так или иначе, эта реализация создает ужасный кофе.
    // TODO(b/12345): Улучшить процесс варки кофе в кофеварке.
  }
}
```

#### Размещайте документацию перед декораторами
Когда класс, метод или свойство имеют и декораторы вида `@Component` и JsDoc, убедитесь, что JsDoc написан перед декоратором.
- Не пишите JsDoc между декоратором и декорируемым выражением.
  ```ts
  @Component({
    selector: 'foo',
    template: 'bar',
  })
  /** Компонент, который печатает "bar". */
  export class FooComponent {}
  ```
- Пишите блок с JsDoc перед декоратором.
  ```ts
  /** Компонент, который печатает "bar". */
  @Component({
    selector: 'foo',
    template: 'bar',
  })
  export class FooComponent {}
  ```

## Языковые правила
### Видимость

Ограничение видимости свойств, методов и целых типов помогает сохранить код слабо связанным.
- Максимально ограничивайте область видимости обозначений.
- Рассмотрите возможность преобразования приватных методов в неэкспортируемые функции в том же файле, но вне какого-либо класса, а также перемещение приватных свойств в отдельные, неэкспортируемые классы.
- В TypeScript все обозначения по умолчанию публичные. Никогда не используйте модификатор public за исключением случаев объявления публичных свойств параметров, недоступных только для чтения.
```ts
class Foo {
  public bar = new Bar();  // ПЛОХО: нет необходимости в модификаторе "public"

  constructor(public readonly baz: Baz) {}  // ПЛОХО: модификатор "readonly" подразумевает, что это свойство имеет по умолчанию модификатор "public"
}
```

```ts
class Foo {
  bar = new Bar();  // ХОРОШО: нет необходимости в модификаторе "public"

  constructor(public baz: Baz) {}  // допускается модификатор "public"
}
```

См. также [Область видимости экспортируемых элементов](/#export-visibility) ниже.

### Конструкторы
При вызове конструктора всегда должны использоваться скобки, даже если никакие аргументы не передаются:
```ts
const x = new Foo;
```

```ts
const x = new Foo();
```

Нет необходимости предоставлять пустой конструктор или конструктор, который просто делегирует в родительский класс, поскольку ES2015 предоставляет конструктор класса по умолчанию, если он не указан. Однако не следует убирать конструкторы со свойствами параметров, модификаторами или декораторами параметров, даже если тело конструктора пустое.
```ts
class UnnecessaryConstructor {
  constructor() {}
}
```

```ts
class UnnecessaryConstructorOverride extends Base {
    constructor(value: number) {
      super(value);
    }
}
```

```ts
class DefaultConstructor {
}

class ParameterProperties {
  constructor(private myService) {}
}

class ParameterDecorators {
  constructor(@SideEffectDecorator myService) {}
}

class NoInstantiation {
  private constructor() {}
}
```

### Члены класса
#### Не используйте приватные поля вида `#private`
Не используйте приватные поля (также известные как приватные идентификаторы):
```ts
class Clazz {
  #ident = 1;
}
```
Вместо этого используйте поддерживаемые TypeScript аннотации видимости:
```ts
class Clazz {
  private ident = 1;
}
```

Почему?
Приватные идентификаторы вызывают существенные проблемы с размером и производительностью при понижении версии стандарта ECMAScript, в которую будет скомпилирован код TypeScript и не поддерживаются до ES2015. Они могут быть понижены только до уровня ES2015, но не ниже. В то же время, они не дают существенных преимуществ, когда для контроля области видимости используется статическая проверка типов.

#### Используйте модификатор `readonly`
Пометьте модификатором `readonly` те свойства, которые никогда не переназначаются вне конструктора (они не обязательно должны быть глубоко неизменяемыми).

#### Параметризованные свойства
Вместо того чтобы просто передавать очевидный инициализатор в член класса, используйте [параметризованные свойства](/#parameter-properties) TypeScript.

```ts
class Foo {
  private readonly barService: BarService;

  constructor(barService: BarService) {
    this.barService = barService;
  }
}
```

```ts
class Foo {
  constructor(private readonly barService: BarService) {}
}
```

Если параметризованное свойство нуждается в документировании [используйте JSDoc тег `@param`](/#parameter-property-comments).

#### Инициализаторы полей

Если элемент класса не является параметризованным свойством,инициализируйте его там, где он объявлен, что иногда позволяет совсем отбросить конструктор.

```ts
class Foo {
  private readonly userList: string[];
  constructor() {
    this.userList = [];
  }
}
```

```ts
class Foo {
  private readonly userList: string[] = [];
}
```

#### Свойства, используемые за пределами лексической области класса

Для свойств, используемых вне лексической области видимости содержащего их класса, например, для свойств контроллера AngularJS, используемых из шаблона, не должна использоваться приватная (`private`) область видимости, поскольку они используются вне лексической области видимости содержащего их класса.

Для этих свойств предпочтительна публичная (`public`) видимость, однако при необходимости можно использовать и защищенную (`protected`) видимость. Например, для свойств используемых в шаблонах Angular и Polymer следует использовать `public`, а в AngularJS - `protected`.

В TypeScript коде не должны использоваться `obj['foo']` для обхода видимости свойства

Почему?
Когда свойство является приватным (`private`), вы объявляете автоматизированным системам и людям, что доступ к свойству ограничен методами объявленного класса, и они будут полагаться на это. Например, проверка на неиспользуемый код отметит приватное свойство, которое может посчитаться неиспользуемым, даже если какому-то коду из другого файла удастся обойти ограничение видимости.

Хотя может показаться, что `obj['foo']` может обойти область видимости в компиляторе TypeScript, эта схема может быть нарушена путем изменения правил сборки, а также нарушается согласованность с оптимизациями.

#### Геттеры и Сеттеры (Аксессоры)

Для членов класса можно иcпользовать геттеры и сеттеры. Методы-геттеры должен быть [чистыми функциями](https://en.wikipedia.org/wiki/Pure_function) (т.е. не имеет побочных эффектов и каждый раз возвращает одинаковый результат при одних и тех же параметрах). Они также полезны как средство ограничения видимости внутренних или подробных деталей реализации (показано ниже).

```ts
class Foo {
  constructor(private readonly someService: SomeService) {}

  get someMember(): string {
    return this.someService.someVariable;
  }

  set someMember(newValue: string) {
    this.someService.someVariable = newValue;
  }
}
```

Если аксессор используется для сокрытия свойства класса, скрытое свойство может иметь префикс или суффикс с любым целым словом, например `internal` или `wrapped`. При использовании этих приватных свойств по возможности обращайтесь к их значению через аксессор. По крайней мере один аксессор к свойству должен быть нетривиальным: не определяйте сквозные аксессоры только для того, чтобы скрыть свойство. Вместо этого сделайте свойство публичным (или подумайте о том, чтобы сделать его доступным только для чтения (`readonly`), чем просто определять геттер без сеттера).

```ts
class Foo {
  private wrappedBar = '';
  get bar() {
    return this.wrappedBar || 'bar';
  }

  set bar(wrapped: string) {
    this.wrappedBar = wrapped.trim();
  }
}
```

```ts
class Bar {
  private barInternal = '';
  // Ни один из этих аксессоров не имеет логики, поэтому просто сделайте bar публичным
  get bar() {
    return this.barInternal;
  }

  set bar(value: string) {
    this.barInternal = value;
  }
}
```

### Примитивные типы & Классы-обертки

Код TypeScript не должен создавать экземпляры классов-оболочек для примитивных типов `String`, `Boolean`, и `Number`. Классы-оболочки имеют удивляющее поведение, такое как `new Boolean(false)` равное `true`.

```ts
const s = new String('hello');
const b = new Boolean(false);
const n = new Number(5);
```

```ts
const s = 'hello';
const b = false;
const n = 5;
```

### Конструктор массива

В коде на Typescript не должны использоваться `Array()` конструкторы, с или без `new`. Его применение неоднозначно и сбивает с толку:

```ts
const a = new Array(2); // [undefined, undefined]
const b = new Array(2, 3); // [2, 3];
```

Вместо этого всегда используйте скобки для инициализации массивов , или `from` для инициализации `Array` с определенным размером:

```ts
const a = [2];
const b = [2, 3];

// Эквивалент для Array(2):
const c = [];
c.length = 2;

// [0, 0, 0, 0, 0]
Array.from<number>({length: 5}).fill(0);
```

### Преобразование типов

В TypeScript коде можно использовать `String()` и `Boolean()` (примечание: без `new`!) функции, строковые шаблонные литералы, или `!!` для преобразования типов.

```ts
const bool = Boolean(false);
const str = String(aNumber);
const bool2 = !!str;
const str2 = `result: ${bool2}`;
```

Не приветствуется для приведения к строке использовать конкатенацию строк, так как при проверке кода мы отслеживаем, чтобы операнды оператора «плюс» имели совпадающие типы.

Код должен использовать `Number()` для парсинга числовых значений, и должен явно проверять его возврат на значения `NaN`, за исключением случаев, когда из контекста точно известно, что сбой парсинга невозможен.

Примечание: `Number('')`, `Number(' ')`, и `Number('\t')` могут вернуть `0` вместо `NaN`. `Number('Infinity')` и `Number('-Infinity')` могут вернуть `Infinity` и `-Infinity` соответственно. Эти случаи могут потребовать особого обращения.

```ts
const aNumber = Number('123');
if (isNaN(aNumber)) throw new Error(...);  // Обрабатываем NaN, если в строке может не быть чисел
assertFinite(aNumber, ...);                // Необязательно: если NaN не может возникнуть, потому что он был проверен ранее.
```

В коде не должен использоваться унарный плюс (`+`) для преобразования строки в число. Парсинг чисел может привести к неудаче, иметь неожиданные исключительные ситуации и может быть признаком дурно пахнущего кода (парсинг чисел не на том уровне). Учитывая это, унарный плюс слишком легко пропустить при проверке кода.

```ts
const x = +y;
```

Код также не должен использовать `parseInt` или `parseFloat` для парсинга чисел, за исключением строк не с десятичными значениями (см. ниже). Обе эти функции игнорируют конечные символы в строке, что может привести к возникновению ошибочного состояния (например, парсинг `12 гномов` как `12`).

```ts
const n = parseInt(someString, 10);  // Подвержено ошибкам,
const f = parseFloat(someString);    // независимо от передачи основания системы счисления.
```

Код, который должен выполнять парсинг числа с использованием системы счисления, должен проверять, является ли его ввод числом, прежде чем вызывать `parseInt`;

```ts
if (!/^[a-fA-F0-9]+$/.test(someString)) throw new Error(...);
  // Требуется для парсинга восьмеричного числа.
// tslint:disable-next-line:ban
const n = parseInt(someString, 16);  // Допустимо только для основания числа != 10
```

Используйте `Number()`, а затем `Math.floor` или `Math.trunc` (там, где это возможно) для парсинга целых чисел:

```ts
let f = Number(someString);
if (isNaN(f)) handleError();
f = Math.floor(f);
```

Не используйте явное булево преобразование в условиях, в которых уже имеется неявное булево преобразование. Это условия в операторах `if`, `for` и `while`.

```ts
const foo: MyInterface|null = ...;
if (!!foo) {...}
while (!!foo) {...}
```

```ts
const foo: MyInterface|null = ...;
if (foo) {...}
while (foo) {...}
```

В коде можно использовать явные сравнения:

```ts
// Явное сравнение > 0 это хорошо:
if (arr.length > 0) {...}
// так же как и полагаться на неявное булево преобразование:
if (arr.length) {...}
```

### Переменные

Всегда используйте `const` или `let` для обьявления переменных. По умолчанию используйте `const`, если не требуется переназначение переменной. Никогда не используйте `var`.

```ts
const foo = otherValue;  // Используйте, если "foo" никогда не меняется.
let bar = someValue;     // Используйте, если для "bar" когда-либо позднее будет присвоено значение 
```

`const` и `let` имеют блочную область видимости, как и переменные в большинстве других языков. `var` в JavaScript ограничен областью действия функции, что может вызвать трудные для понимания ошибки. Не используйте его.

```ts
var foo = someValue;     // Не используйте - область видимости var сложна и подвержена ошибкам.
```

Переменные не должны использоваться до их объявления.

### Исключения

Всегда используйте `new Error()` при создании исключений вместо простого вызова `Error()`. В обоих случаях создается новый экземпляр `Error`, но использование `new` более согласуется с тем, как создаются экземпляры других объектов.

```ts
throw new Error('Foo is not a valid bar.');
```

```ts
throw Error('Foo is not a valid bar.');
```

### Итерация объектов

Итерация объектов с помощью `for (... in ...)` подвержена вероятным ошибкам, т.к. это включает в себя все перечисляемые свойства из цепочки прототипов.

Не используйте не фильтрованные `for (... in ...)` выражения:

```ts
for (const x in someObj) {
  // x может происходить от некоторого родительского прототипа!
}
```

Либо явно отфильтруйте значения с помощью оператора `if`, либо используйте `for (... of Object.keys(...))`.

```ts
for (const x in someObj) {
  if (!someObj.hasOwnProperty(x)) continue;
  // сейчас x был точно определен в принадлежности someObj
}
for (const x of Object.keys(someObj)) { // примечание: for _of_!
  // сейчас x был точно определен в принадлежности someObj
}
for (const [key, value] of Object.entries(someObj)) { // примечание: for _of_!
  // сейчас key был точно определен в принадлежности someObj
}
```

### Итерация массивов

Не используйте `for (... in ...)` для итерации по массивам. Это будет контринтуитивно давать индексы массива (в виде строк!), а не значения:

```ts
for (const x in someArray) {
  // x - это индекс!
}
```

Для итерации по массивам используйте `for (... of someArr)` или обычные циклы `for` с индексами.

```ts
for (const x of someArr) {
  // x - ссылается на значение из someArr
}

for (let i = 0; i < someArr.length; i++) {
  // Если необходим индекс, то используйте явный пересчет, а иначе используйте форму for/of.
  const x = someArr[i];
  // ...
}
for (const [i, x] of someArr.entries()) {
  // Альтернативная версия предыдущего.
}
```

Не используйте `Array.prototype.forEach`, `Set.prototype.forEach`, и `Map.prototype.forEach`. Они усложняют отладку кода и препятствуют некоторым полезным проверкам компилятора (например, проверку достижимости).

```ts
someArr.forEach((item, index) => {
  someFn(item, index);
});
```

Почему?
Рассмотрим следующий код:

```ts
let x: string|null = 'abc';
myArray.forEach(() => { x.charAt(0); });
```

Вы можете видеть, что этот код вполне в порядке: `x` не является null и не изменяется до обращения к нему. Но компилятор не может знать, что этот вызов `.forEach()` не привязан к переданному замыканию и не вызовет его позже, возможно, после того, как `x` будет установлен в null, поэтому он помечает этот код как ошибку. Эквивалентный цикл for-of работает нормально.

[Посмотреть в песочнице ошибочный и безошибочный варианты](https://www.typescriptlang.org/play?#code/DYUwLgBAHgXBDOYBOBLAdgcwD5oK7GAgF4IByAQwCMBjUgbgCgBtAXQDoAzAeyQFFzqACwAUwgJTEAfBADeDCNDZDySAIJhhABjGMAvjoYNQkAJ5xEqTDnyESFGvQbckEYdS5pEEAPoQuHCFYJOQUTJUEVdS0DXQYgA)

На практике различные варианты этих ограничений анализа потока управления проявляются в более сложных путях выполнения кода, где это может быть более неожиданно.

### Использование spread-операторов

Использование spread-оператора `[...foo]; {...bar}` является удобным сокращением для копирования массивов и объектов. При использовании spread-оператора для объектов, более поздние значения заменяют более ранние с тем же ключом.

```ts
const foo = {
  num: 1,
};

const foo2 = {
  ...foo,
  num: 5,
};

const foo3 = {
  num: 5,
  ...foo,
}

foo2.num === 5;
foo3.num === 1;
```

При использовании spread-оператора раскладываемое значение должно соответствовать создаваемому. Т.е. при создании объекта с spread-оператором можно использовать только объекты, а при создании массива раскладывайте только итерируемые объекты. Примитивы, включая `null` и `undefined`, никогда не могут быть разложены.

```ts
const foo = {num: 7};
const bar = {num: 5, ...(shouldUseFoo && foo)}; // может быть undefined

// Creates {0: 'a', 1: 'b', 2: 'c'} but has no length
const fooStrings = ['a', 'b', 'c'];
const ids = {...fooStrings};
```

```ts
const foo = shouldUseFoo ? {num: 7} : {};
const bar = {num: 5, ...foo};
const fooStrings = ['a', 'b', 'c'];
const ids = [...fooStrings, 'd', 'e'];
```

### Операторы управления потоком & блоки

Операторы управления потоком, охватывающие несколько строк, всегда используют блоки для размещения содержащегося в них кода.

```ts
for (let i = 0; i < x; i++) {
  doSomethingWith(i);
  andSomeMore();
}
if (x) {
  doSomethingWithALongMethodName(x);
}
```

```ts
if (x)
  x.doFoo();
for (let i = 0; i < x; i++)
  doSomethingWithALongMethodName(i);
```

Исключением являются операторы `if`, которые помещаются на одной строке и могут не использовать блоки.

```ts
if (x) x.doFoo();
```

### Switch оператор

Каждый `switch` оператор должен включать в себя блок по умолчанию (`default`), даже если там не содержится кода.

```ts
switch (x) {
  case Y:
    doSomethingElse();
    break;
  default:
    // ничего не делать.
}
```

Непустые группы операторов (`case ...`) могут не проваливаться (обеспечивается настройками компилятора):

```ts
switch (x) {
  case X:
    doSomething();
    // дальнейший пропуск - не разрешен!
  case Y:
    // ...
}
```

Допускается пропуск пустых групп операторов:

```ts
switch (x) {
  case X:
  case Y:
    doSomething();
    break;
  default: // ничего не делать.
}
```

### Проверка равенства

Всегда используйте тройное равенство (`===`) и неравенство (`!==`). Операторы двойного равенства вызывают склонные к ошибкам приведения типов, которые трудны для понимания и работают медленнее в реализации виртуальных машин JavaScript. Смотрите также [JavaScript таблицу равенства](https://dorey.github.io/JavaScript-Equality-Table/).

```ts
if (foo == 'bar' || baz != bam) {
  // Трудное для понимания поведение из-за преобразования типов.
}
```

```ts
if (foo === 'bar' || baz !== bam) {
  // Здесь все хорошо и понятно.
}
```

**Исключение**: При сравнении с `null` значением можно использовать `==` и `!=` операторы для общего охвата `null` и `undefined` значений.

```ts
if (foo == null) {
  // Будет срабатывать, когда foo равен null или undefined. 
}
```

### Объявление функции

Используйте `function foo() { ... }` для объявления именованных функций, включая функции во вложенных областях, например внутри другой функции.

Используйте объявления функций вместо присваивания функционального выражения локальной переменной (`const x = function() {...};`). TypeScript уже запрещает переназначение функций, поэтому предотвращение перезаписи объявления функции с помощью `const` не требуется.

Исключение: Если функция обращается к `this` внешней области видимости, используйте назначаемые переменным стрелочные функции вместо объявления функции.

```ts
function foo() { ... }
```

```ts
// Учитывая приведенное выше объявление, это не будет компилироваться:
foo = () => 3;  // ОШИБКА: Недопустимая левая часть выражения присваивания.

// Так что такие объявления излишни.
const foo = function() { ... }
```

> Обратите внимание на разницу между объявлениями функций (`function foo() {}`) обсуждаемыми здесь, и функциональными выражениями (`doSomethingWith(function() {});`) которые обсуждаются [ниже](/#function-expressions).

Стрелочные функции верхнего уровня *могут* использоваться для явного объявления того, что функция реализует интерфейс.

```ts
interface SearchFunction {
  (source: string, subString: string): boolean;
}

const fooSearch: SearchFunction = (source, subString) => { ... };
```

### Функциональные выражения

#### Использование стрелочных функций в выражениях

Всегда используйте стрелочные функции вместо функциональных выражений которые были до ES6 и задавались с помощью ключевого слова `function`.

```ts
bar(() => { this.doSomething(); })
```

```ts
bar(function() { ... })
```

Функциональные выражения (определенные с помощью ключевого слова `function`) могут использоваться только в том случае, если код должен динамически перепривязать `this`, но в коде в принципе *не рекомендуется* перепривязывать `this`. В коде обычных функций (в отличие от стрелочных функций и методов) *не рекомендуется* обращаться к `this`.

#### Использование выражений или блоков в качестве тела функции

Используйте стрелочные функции с выражениями или блоками в качестве тела там, где это целесообразно.

```ts
// Для объявления функции верхнего уровня используйте Function Declarations.
function someFunction() {
  // Вполне подходит использование блочных тел стрелочных функций, т.е. у которых тело функции представляет => { } :
  const receipts = books.map((b: Book) => {
    const receipt = payMoney(b.price);
    recordTransaction(receipt);
    return receipt;
  });

  // Использование выражения в качестве тела функции тоже подходит, если возвращаемое значение будет использоваться:
  const longThings = myValues.filter(v => v.length > 1000).map(v => String(v));

  function payMoney(amount: number) {
    // Function Declarations - это хорошо, но не обращайтесь к `this` в них. 
  }
}
```

Используйте выражения в качестве тела функции только в том случае, если возвращаемое значение функции действительно используется.

```ts
// ПЛОХО: используйте блочное тело функции ({ ... }) если возвращаемое значение функции не используется.
myPromise.then(v => console.log(v));
```

```ts
// ХОРОШО: возвращаемое значение не используется, поэтому используйте блочное тело функции.
myPromise.then(v => {
  console.log(v);
});
// ХОРОШО: в коде можно использовать блочное тело функции для повышения удобочитаемости.
const transformed = [1, 2, 3].map(v => {
  const intermediate = someComplicatedExpr(v);
  const more = acrossManyLines(intermediate);
  return worthWrapping(more);
});
```

#### Перепривязывание `this`

Функциональные выражения не должны использовать `this` если только они не существуют специально для перепривязки `this`. В большинстве случаев перепривязки `this` можно избежать, используя стрелочные функции или явно заданные параметры.

```ts
function clickHandler() {
  // Плохо: что такое «this» в этом контексте?
  this.textContent = 'Hello';
}
// Плохо: `this` неявно ссылается на document.body .
document.body.onclick = clickHandler;
```

```ts
// Хорошо: явная ссылка на объект из стрелочной функции.
document.body.onclick = () => { document.body.textContent = 'hello'; };
// Альтернатива: взять явно заданный параметр
const setTextFn = (e: HTMLElement) => { e.textContent = 'hello'; };
document.body.onclick = setTextFn.bind(null, document.body);
```

#### Стрелочные функции как свойства

В классах обычно *не рекомендуется* содержать свойства, которые проинициализированы как стрелочные функции. Использование стрелочных функций как свойств требует, чтобы вызывающая их функция корректно понимала, что у вызываемой функции уже есть привязанный `this`, что увеличивает путаницу в понимании того, что такое `this`, а сами места вызовов и ссылки использующие эти функции, могут смотреться некорректно работающими (т.к. это требует дополнительных знаний из-за пределов локального пространства вызывающей функции, чтобы определить, что они корректны). В коде *рекомендуется* всегда использовать стрелочные функции для вызова методов экземпляра (`const handler = (x) => { this.listener(x); };`), и *не рекомендуется* получать или передавать ссылки на методы экземпляра (~`const handler = this.listener; handler(x);`~).

> Примечание: в некоторых специфических ситуациях, например, в случае привязки функций к шаблонам, стрелочные функции в качестве свойств полезны и создают гораздо более читабельный код. Руководствуйтесь здравым смыслом при использовании этого правила. Также см. раздел [`Обработчики событий`](/#event-handlers) ниже.

```ts
class DelayHandler {
  constructor() {
    // Проблема: `this` не сохраняется в функции обратного вызова. `this` в обратном вызове
    // не будет экземпляром DelayHandler.
    setTimeout(this.patienceTracker, 5000);
  }
  private patienceTracker() {
    this.waitedPatiently = true;
  }
}
```

```ts
// Стрелочные функции обычно не рекомендуется задавать свойствам.
class DelayHandler {
  constructor() {
    // Плохо: этот код выглядит так, как будто ту забыли привязать `this`. 
    setTimeout(this.patienceTracker, 5000);
  }
  private patienceTracker = () => {
    this.waitedPatiently = true;
  }
}
```

```ts
// Явное управление `this` во время вызова.
class DelayHandler {
  constructor() {
    // По возможности используйте анонимные функции.
    setTimeout(() => {
      this.patienceTracker();
    }, 5000);
  }
  private patienceTracker() {
    this.waitedPatiently = true;
  }
}
```

#### Обработчики событий

Обработчики событий *могут* использовать стрелочные функции, когда нет необходимости удалять обработчик (например, если событие генерируется самим классом). Если обработчик впоследствии должен быть удален, тогда правильным подходом будет использование назначенной свойству стрелочной функции, поскольку они автоматически захватывают `this` и при этом обеспечивается постоянная ссылка на обработчик для его последующего удаления.

```ts
// Обработчики событий могут быть анонимными функциями или назначенные свойствам стрелочными функциями.
class Component {
  onAttached() {
    // Событие генерируется этим классом, удалять его не нужно.
    this.addEventListener('click', () => {
      this.listener();
    });
    // this.listener это постоянная ссылка на функцию-обработчик, которую мы позже можем удалить.
    window.addEventListener('onbeforeunload', this.listener);
  }
  onDetached() {
    // Событие генерируется окном (window). Если мы не удалим функцию-обработчик (this.listener), то она
    // сохранит ссылку на `this` к которой привязана, что приведет к утечке памяти.
    window.removeEventListener('onbeforeunload', this.listener);
  }
  // Стрелочная функция, хранящаяся в свойстве, автоматически привязывается к `this`.
  private listener = () => {
    confirm('Вы хотите покинуть страницу?');
  }
}
```

Не используйте `bind` в выражениях, которые устанавливают обработчики событий, потому что это создает временную ссылку, которую нельзя удалить.

```ts
// Привязка слушателей создает временную ссылку, которая недоступна для удаления.
class Component {
  onAttached() {
    // Это создает временную ссылку, которая нам не будет доступна для удаления.
    window.addEventListener('onbeforeunload', this.listener.bind(this));
  }
  onDetached() {
    // метод bind каждый раз создает новую ссылку, поэтому эта строка не делает ничего.
    window.removeEventListener('onbeforeunload', this.listener.bind(this));
  }
  private listener() {
    confirm('Вы хотите покинуть страницу?');
  }
}
```

### Автоматическая вставка точки с запятой

