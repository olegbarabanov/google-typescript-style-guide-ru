<html lang="ru" data-color-mode="auto" data-light-theme="light" data-dark-theme="dark_dimmed"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>Руководство Google по стилю написания кода на языке TypeScript (перевод)</title><link rel="canonical" href="https://olegbarabanov.github.io/google-typescript-style-guide-ru/"/><link rel="icon" href="favicon.ico"><script defer="defer" src="main.js"></script><link href="main.css" rel="stylesheet"></head><body class="d-flex flex-column height-full"><header class="header p-1 p-md-2 p-lg-3 d-flex flex-items-center flex-justify-between flex-nowrap flex-shrink-0"><div class="f3-mktg text-bold mx-2 text-left text-sm-center"><a class="title-link">Руководство Google по стилю написания кода на языке TypeScript (перевод)</a></div><div class="d-flex flex-nowrap mx-2"><details class="details-reset details-overlay"><summary><div class="btn d-flex flex-items-center flex-row flex-nowrap"><svg height="16" viewBox="0 0 16 16" version="1.1" width="16" fill="currentColor"><path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path></svg> <span class="ml-2 d-none d-md-inline">Содержание</span></div></summary><div class="selectmenu right-0"><div class="selectmenu-modal"><nav class="selectmenu-list"></nav></div></div></details></div></header><div class="markdown-body p-5 overflow-auto mt-1"><h1 id="%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-google-%D0%BF%D0%BE-%D1%81%D1%82%D0%B8%D0%BB%D1%8E-%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA%D0%BE%D0%B4%D0%B0-%D0%BD%D0%B0-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5-typescript-(%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%B0-%22google-typescript-style-guide%22)" tabindex="-1"><a class="header-anchor" href="#%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-google-%D0%BF%D0%BE-%D1%81%D1%82%D0%B8%D0%BB%D1%8E-%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA%D0%BE%D0%B4%D0%B0-%D0%BD%D0%B0-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5-typescript-(%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%B0-%22google-typescript-style-guide%22)"><span>Руководство Google по стилю написания кода на языке TypeScript (перевод руководства &quot;Google TypeScript Style Guide&quot;)</span></a></h1><h2 id="%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4%D1%83" tabindex="-1"><a class="header-anchor" href="#%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4%D1%83"><span>Дополнительная информация по переводу</span></a></h2><p>Репозиторий текущего перевода расположен по адресу: <a href="https://github.com/olegbarabanov/google-typescript-style-guide-ru">https://github.com/olegbarabanov/google-typescript-style-guide-ru</a>.</p><p>С оригинальным руководством по стилю вы можете ознакомиться по адресу: <a href="https://google.github.io/styleguide/tsguide.html">https://google.github.io/styleguide/tsguide.html</a>.</p><p>Перевод основан на <a href="https://github.com/google/styleguide/blob/4d9a47834bfbadeb00a3dcf3d9808ffe49e43aeb/tsguide.html">версии оригинального руководства от <em><strong>21.10.2023</strong></em></a>.</p><p>Хотя данный перевод и стремится быть максимально соответствующим оригинальному тексту, в текст перевода были добавлены сноски на комментарии и примечания переводчика, которые дополняют или разъясняют суть конкретного выражения. Также подобные сноски присутствуют в местах исправления <em>явных</em> ошибок, которые присутствовали в оригинале и которые могли бы ввести в заблуждение.</p><p>Если Вы нашли несоответствие, ошибку или неточность в переводе, вы можете оформить это в виде <em><a href="https://github.com/olegbarabanov/google-typescript-style-guide-ru/issues">issue</a></em> или предложить собственное исправление в виде <em><a href="https://github.com/olegbarabanov/google-typescript-style-guide-ru/pulls">pull request</a></em> в репозиторий проекта, либо написать переводчику по адресу <a href="mailto:mail@olegbarabanov.ru">mail@olegbarabanov.ru</a>.</p><h2 id="%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5" tabindex="-1"><a class="header-anchor" href="#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5"><span>Введение</span></a></h2><p>Данное руководство основано на внутреннем руководстве Google по стилю написания кода на языке TypeScript, но при этом оно было незначительно скорректировано с целью удаления разделов предназначенных для внутреннего пользования Google. Внутренняя среда Google предусматривает иные ограничения на TypeScript, чем те, что вы могли бы встретить за пределами Google. Приведенные здесь советы особенно полезны для людей, создающих код, который они намерены импортировать в Google, однако в других случаях они могут и не применяться в вашей внешней по отношению к Google среде.</p><p>Для этой версии руководства не существует какого-либо механизма автоматического развертывания, поскольку она предоставляется волонтерами в ответ на запросы пользователей.</p><h3 id="%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%87%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BA-%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%87%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BA-%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8"><span>Примечание к терминологии</span></a></h3><p>Данное руководство ссылается на терминологию стандарта <a href="https://tools.ietf.org/html/rfc2119">RFC 2119</a> при использовании фраз <em>ДОЛЖЕН</em>, <em>НЕ ДОЛЖЕН</em>, <em>РЕКОМЕНДУЕТСЯ</em>, <em>НЕ РЕКОМЕНДУЕТСЯ</em> и <em>ВОЗМОЖНО</em> <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>. Термины <em>ПРЕДПОЧИТАТЬ</em> и <em>ИЗБЕГАТЬ</em> соответствуют терминам <em>РЕКОМЕНДУЕТСЯ</em> и <em>НЕ РЕКОМЕНДУЕТСЯ</em> соответственно. Императивные и декларативные высказывания носят предписывающий характер и соответствуют термину <em>ДОЛЖЕН</em>.</p><h3 id="%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%87%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BA-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D1%83" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%87%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BA-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D1%83"><span>Примечание к руководству</span></a></h3><p>Все приведенные примеры <strong>не носят нормативного характера</strong> и служат лишь для иллюстрации стандартных формулировок из данного руководства по стилю. Т.е. хоть примеры и выполнены в стиле текущего руководства, они могут не иллюстрировать представление кода <em>исключительно</em> в этом стиле. Любые дополнительные решения в отношении форматирования кода, представленные в примерах, не должны рассматриваться в качестве правил руководства.</p><h2 id="%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D1%85-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D1%85-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2"><span>Основы исходных файлов</span></a></h2><h3 id="%D0%BA%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%3A-utf-8" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%3A-utf-8"><span>Кодировка файлов: UTF-8</span></a></h3><p>Исходные файлы кодируются в UTF-8.</p><h3 id="%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8B"><span>Специальные символы</span></a></h3><h4 id="%D0%BF%D1%80%D0%BE%D0%B1%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%BE%D0%B1%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8B"><span>Пробельные символы</span></a></h4><p>Помимо последовательности символов перевода строки, ASCII-символ горизонтального пробела (<code>0x20</code>) является единственным допустимым пробельным символом, который может появляться где-либо в исходном коде. Это также подразумевает, что в строковых литералах все прочие пробельные символы экранируются.</p><h4 id="%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B5-%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B5-%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8"><span>Специальные экранирующие последовательности</span></a></h4><p>Для каждого символа, для которого существует специальная экранирующая последовательность (<code>\'</code>, <code>\&quot;</code>, <code>\\</code>, <code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>, <code>\t</code>, <code>\v</code>) предпочтительнее использовать именно ее вместо соответствующего числового экранирования (например, <code>\x0a</code>, <code>\u000a</code> или <code>\u{a}</code>). Устаревшие восьмеричные символы экранирования не используются.</p><h4 id="%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8B-%D0%BD%D0%B5-%D0%B8%D0%B7-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B-ascii" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8B-%D0%BD%D0%B5-%D0%B8%D0%B7-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B-ascii"><span>Символы не из таблицы ASCII</span></a></h4><p>Для остальных символов, которые не из таблицы ASCII, используйте подходящий символ Unicode (например <code>∞</code>). Для непечатаемых символов можно использовать эквивалентный шестнадцатеричный код или экранирование Unicode-символов (например <code>\u221e</code>) вместе с пояснительным комментарием.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Совершенно ясно даже без комментария</span>
<span class="hljs-keyword">const</span> units = <span class="hljs-string">&#x27;μs&#x27;</span>;

<span class="hljs-comment">// Используйте Unicode-экранирование для непечатаемых символов</span>
<span class="hljs-keyword">const</span> output = <span class="hljs-string">&#x27;\ufeff&#x27;</span> + content; <span class="hljs-comment">// это маркер последовательности байтов (Unicode BOM)</span>
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Даже с комментарием, это сложно для чтения и подвержено потенциальным ошибкам.</span>
<span class="hljs-keyword">const</span> units = <span class="hljs-string">&#x27;\u03bcs&#x27;</span>; <span class="hljs-comment">// Греческая буква mu, &#x27;s&#x27;</span>

<span class="hljs-comment">// Читающий код не поймет, что это такое</span>
<span class="hljs-keyword">const</span> output = <span class="hljs-string">&#x27;\ufeff&#x27;</span> + content;
</code></pre><h2 id="%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0"><span>Структура исходного файла</span></a></h2><p>Исходный файл состоит из следующих <strong>по порядку</strong> частей:</p><ul><li>Информация об авторских правах, при наличии</li><li>JSDoc с <code>@fileoverview</code>, при наличии</li><li>Объявление импортов, при наличии</li><li>Реализация файла</li></ul><p>Для разделения перечисленных частей друг от друга используется <strong>только одна пустая строка</strong>.</p><h3 id="%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F-%D0%BE%D0%B1-%D0%B0%D0%B2%D1%82%D0%BE%D1%80%D1%81%D0%BA%D0%B8%D1%85-%D0%BF%D1%80%D0%B0%D0%B2%D0%B0%D1%85" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F-%D0%BE%D0%B1-%D0%B0%D0%B2%D1%82%D0%BE%D1%80%D1%81%D0%BA%D0%B8%D1%85-%D0%BF%D1%80%D0%B0%D0%B2%D0%B0%D1%85"><span>Информация об авторских правах</span></a></h3><p>Если необходимо указать в файле информацию о лицензии или авторских правах, добавьте ее в JSDoc в верхней части файла<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</p><h3 id="jsdoc-%D1%82%D0%B5%D0%B3-%40fileoverview" tabindex="-1"><a class="header-anchor" href="#jsdoc-%D1%82%D0%B5%D0%B3-%40fileoverview"><span>JSDoc тег <code>@fileoverview</code></span></a></h3><p>Файл может иметь на верхнем уровне JSDoc с тегом <code>@fileoverview</code>. При наличии, в нем может быть представлено описание содержимого файла, его применение, а также информация о его зависимостях.</p><p>Пример<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@fileoverview</span> Описание файла. Lorem ipsum dolor sit amet, consectetur
 * adipiscing elit, sed do eiusmod tempor incididunt.
 */</span>
</code></pre><h3 id="%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D1%8B"><span>Импорты</span></a></h3><p>В ES6 и TypeScript есть четыре варианта операторов импорта:</p><table><thead><tr><th>Вид импорта</th><th>Пример</th><th>Назначение</th></tr></thead><tbody><tr><td>модульный</td><td><code>import * as foo from '...';</code></td><td>Импорты TypeScript</td></tr><tr><td>именованный (деструктурированный)</td><td><code>import {SomeThing} from '...';</code></td><td>Импорты TypeScript</td></tr><tr><td>по умолчанию</td><td><code>import SomeThing from '...';</code></td><td>Только для поддержки стороннего кода, который их требует</td></tr><tr><td>для использования побочных эффектов</td><td><code>import '...';</code></td><td>Только для импорта библиотек ради получения их побочных эффектов при загрузке (таких как пользовательские элементы)</td></tr></tbody></table><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Хорошо: выберите один из двух вариантов в зависимости от ситуации (см. ниже).</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ng <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">Foo</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo&#x27;</span>;

<span class="hljs-comment">// Только при необходимости: импорт по умолчанию.</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;Button&#x27;</span>;

<span class="hljs-comment">// Иногда необходимо импортировать библиотеки для получения их вспомогательных эффектов:</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;jasmine&#x27;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@polymer/paper-button&#x27;</span>;
</code></pre><h4 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%83%D1%82%D0%B5%D0%B9-%D0%B2-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D0%B0%D1%85" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%83%D1%82%D0%B5%D0%B9-%D0%B2-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D0%B0%D1%85"><span>Использование путей в импортах</span></a></h4><p>В TypeScript коде обязательно <em>должны</em> указываться пути при импорте другого TypeScript кода. <em>Возможно</em> указывать относительные пути, т.е. начинающиеся с <code>.</code> или <code>..</code> или с базовой директории, как например <code>root/path/to/file</code>.</p><p>В коде <em>рекомендуется</em> использовать относительные импорты (<code>./foo</code>) вместо абсолютных импортов <code>path/to/foo</code> при ссылке на файлы в пределах одного и того же (в логическом смысле) проекта, т.к. это позволяет перемещать весь проект без внесения изменений в эти импорты.</p><p>Рассмотрите возможность ограничения количества родительских шагов (<code>../../../</code>), т.к. это может затруднить понимание структуры модулей и путей.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">import</span> {<span class="hljs-title class_">Symbol1</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path/from/root&#x27;</span>;
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">Symbol2</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../parent/file&#x27;</span>;
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">Symbol3</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./sibling&#x27;</span>;
</code></pre><h4 id="%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D1%8B-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2-%D0%B8%D0%BC%D0%B5%D0%BD-%D0%B2-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B8-%D1%81-%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC%D0%B8-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D0%B0%D0%BC%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D1%8B-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2-%D0%B8%D0%BC%D0%B5%D0%BD-%D0%B2-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B8-%D1%81-%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC%D0%B8-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D0%B0%D0%BC%D0%B8"><span>Импорты пространств имен в сравнении с именованными импортами</span></a></h4><p>Могут использоваться как импорты пространств имен<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>, так и именованные импорты<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>.</p><p>Именованные импорты предпочтительны для элементов, часто используемых в файле, а также для элементов, имеющих понятное название, как например, <code>describe</code> и <code>it</code> в Jasmine. При необходимости с помощью оператора <code>as</code> именованные импорты могут быть переименованы в более понятные названия.</p><p>Импорты пространств имен предпочтительны при использовании множества различных элементов из больших API. Импорт пространства имен, несмотря на <code>*</code>, не сопоставим с &quot;подстановочным&quot; (wildcard) импортом, который встречается в других языках. Вместо этого, импорт пространства имен присваивает имя всему экспорту модуля и каждый экспортируемый элемент из модуля становится свойством этого имени модуля. Импорты пространств имен могут поспособствовать удобочитаемости в случае экспортируемых элементов, которые имеют распространенные имена, наподобие <code>Model</code> или <code>Controller</code>, без необходимости объявлять для них псевдонимы.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Плохо: слишком длинный оператор импорта с излишними пространствами имен.</span>
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">Item</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">TableviewItem</span>, <span class="hljs-title class_">Header</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">TableviewHeader</span>, <span class="hljs-title class_">Row</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">TableviewRow</span>,
  <span class="hljs-title class_">Model</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">TableviewModel</span>, <span class="hljs-title class_">Renderer</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">TableviewRenderer</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./tableview&#x27;</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">item</span>: <span class="hljs-title class_">TableviewItem</span>|<span class="hljs-literal">undefined</span>;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Лучше: используйте модуль для пространства имен. </span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> tableview <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./tableview&#x27;</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">item</span>: tableview.<span class="hljs-property">Item</span>|<span class="hljs-literal">undefined</span>;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> testing <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./testing&#x27;</span>;

<span class="hljs-comment">// Плохо: Имя модуля не способствует удобочитаемости.</span>
testing.<span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  testing.<span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    testing.<span class="hljs-title function_">expect</span>(<span class="hljs-literal">null</span>).<span class="hljs-title function_">toBeNull</span>();
    testing.<span class="hljs-title function_">expect</span>(<span class="hljs-literal">undefined</span>).<span class="hljs-title function_">toBeUndefined</span>();
  });
});
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Лучше: дайте локальные имена распространенным функциям.</span>
<span class="hljs-keyword">import</span> {describe, it, expect} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./testing&#x27;</span>;

<span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">expect</span>(<span class="hljs-literal">null</span>).<span class="hljs-title function_">toBeNull</span>();
    <span class="hljs-title function_">expect</span>(<span class="hljs-literal">undefined</span>).<span class="hljs-title function_">toBeUndefined</span>();
  });
});
</code></pre><h5 id="%D0%BE%D1%81%D0%BE%D0%B1%D1%8B%D0%B9-%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B9%3A-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8E%D1%89%D0%B8%D0%B5-jspb-proto-%D1%84%D0%B0%D0%B9%D0%BB%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D1%81%D0%BE%D0%B1%D1%8B%D0%B9-%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B9%3A-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8E%D1%89%D0%B8%D0%B5-jspb-proto-%D1%84%D0%B0%D0%B9%D0%BB%D1%8B"><span>Особый случай: Приложения использующие JSPB proto-файлы</span></a></h5><p>Приложения использующие JSPB proto-файлы должны использовать для них именованный импорт, даже если это приводит к возникновению длинных строк импорта<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>.</p><p>Это правило существует для повышения производительности сборки и избавления от мертвого кода, поскольку часто файлы <code>.proto</code> содержат множество &quot;сообщений&quot; (<code>message</code>), которые не всегда нужны все вместе. Используя деструктурированный импорт, система сборки может создавать более точную структуру зависимостей от &quot;сообщений&quot; JSPB в приложении их использующем, сохраняя при этом удобство импорта на основе путей.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// ХОРОШО: Импортируйте из proto-файла именно тот набор элементов, который вам нужен.</span>
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">Foo</span>, <span class="hljs-title class_">Bar</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.proto&#x27;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">copyFooBar</span>(<span class="hljs-params">foo: Foo, bar: Bar</span>) {...}
</code></pre><h4 id="%D0%BF%D0%B5%D1%80%D0%B5%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2"><span>Переименование импортов</span></a></h4><p>В коде <em>рекомендуется</em> устранять возможные конфликты имен используя импорт пространств имен или переименовывая сами экспорты. При необходимости в коде <em>можно</em> переименовывать импорты (<code>import {SomeThing as SomeOtherThing}</code>).</p><p>Три примера, когда переименование может быть полезным:</p><ol><li>Если необходимо избежать коллизий с другими импортируемыми элементами;</li><li>Если имя импортированного элемента генерируется;</li><li>При импорте элементов, имена которых сами по себе неясны, переименование может улучшить ясность кода. Например, при использовании RxJS функция <code>from</code> может быть более удобочитаемой, если ее переименовать в <code>observableFrom</code>.</li></ol><h3 id="%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D1%8B"><span>Экспорты</span></a></h3><p>По всему коду используйте именованные экспорты:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Использование именованного экспорта:</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> { ... }
</code></pre><p>Не используйте экспорт по умолчанию. Это гарантирует, что все импорты будут следовать единому шаблону.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Не используйте экспорт по умолчанию:</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> { ... } <span class="hljs-comment">// ПЛОХО!</span>
</code></pre><blockquote><p>Почему?</p><p>Экспорт по умолчанию не предоставляет канонического имени, что затрудняет централизованное обслуживание при относительно небольшой пользе для владельцев кода, причем возможно ухудшение читабельности:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./bar&#x27;</span>;  <span class="hljs-comment">// Валидно.</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Bar</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./bar&#x27;</span>;  <span class="hljs-comment">// Также валидно.</span>
</code></pre><p>Преимущество именованного экспорта заключается в том, что оно приводит к ошибкам, когда операторы импорта пытаются импортировать что-то, что не было объявлено. В <code>foo.ts</code>:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;blah&#x27;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> foo;
</code></pre><p>И в <code>bar.ts</code>:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">import</span> {fizz} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo&#x27;</span>;
</code></pre><p>В результате возникает ошибка <code>error TS2614: Module '&quot;./foo&quot;' has no exported member 'fizz'</code>. Если указать в <code>bar.ts</code>:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">import</span> fizz <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo&#x27;</span>;
</code></pre><p>В результате получается <code>fizz === foo</code>, что может быть неожиданным и затрудняющим отладку.</p><p>Кроме того, экспорт по умолчанию побуждает людей помещать все в один большой объект, чтобы разместить все вместе в пространстве имен:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-variable constant_">SOME_CONSTANT</span> = ...
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">someHelpfulFunction</span>(<span class="hljs-params"></span>) { ... }
  ...
}
</code></pre><p>В приведенном выше примере у нас есть область видимости файла, которая может использоваться как пространство имен. У нас также есть, возможно, ненужная вторая область видимости (класс <code>Foo</code>), которая в других файлах может двусмысленно использоваться и как тип, и как значение.</p><p>Вместо этого предпочтительно использовать файловую область видимости для пространства имен, а также именованный экспорт:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SOME_CONSTANT</span> = ...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">someHelpfulFunction</span>(<span class="hljs-params"></span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-comment">// тут только элементы класса</span>
}
</code></pre></blockquote><h4 id="%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D1%85-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D1%85-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2"><span>Область видимости экспортируемых элементов</span></a></h4><p>TypeScript не поддерживает ограничение видимости экспортируемых элементов. Экспортируйте только те элементы, которые используются вне модуля. В целом, минимизируйте экспортируемую часть API модулей.</p><h4 id="%D0%BC%D1%83%D1%82%D0%B0%D0%B1%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BC%D1%83%D1%82%D0%B0%D0%B1%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2"><span>Мутабельность экспортов</span></a></h4><p>Независимо от технической стороны, мутабельные экспорты могут создавать трудно понимаемый и отлаживаемый код, особенно при реэкспорте в различных модулях. Если по другому сформулировать это правило, то <code>export let</code> не допускается.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> foo = <span class="hljs-number">3</span>;
<span class="hljs-comment">// В чистом ES6 foo является мутабельным, и импортеры будут видеть изменение его значения уже через секунду.</span>
<span class="hljs-comment">// В TS (прим. пер.: в версии TS &lt; 3.9, при использовании модулей CommonJS), если foo реэкспортируется вторым файлом,</span>
<span class="hljs-comment">// импортеры не увидят изменения значения.</span>
<span class="hljs-comment">// Прим. пер.: В версии TS &gt;= 3.9, это будет работать по аналогии с ES6.</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  foo = <span class="hljs-number">4</span>;
}, <span class="hljs-number">1000</span> <span class="hljs-comment">/* миллисекунды */</span>);

</code></pre><p>Если необходимо поддерживать доступные извне мутабельные привязки, то вместо этого <em>рекомендуется</em> явно использовать функции-геттеры.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">let</span> foo = <span class="hljs-number">3</span>;
<span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  foo = <span class="hljs-number">4</span>;
}, <span class="hljs-number">1000</span> <span class="hljs-comment">/* миллисекунды */</span>);
<span class="hljs-comment">// Используйте явно заданный геттер для доступа к мутабельному экспорту.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFoo</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> foo; };
</code></pre><p>При экспорте одного из двух значений в зависимости от условий, в качестве стандартного шаблона, сначала выполняется проверка условий, а затем экспорт. Убедитесь, что все экспортируемые значения являются окончательными после выполнения всего тела модуля.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">pickApi</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">useOtherApi</span>()) <span class="hljs-keyword">return</span> <span class="hljs-title class_">OtherApi</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">RegularApi</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">SomeApi</span> = <span class="hljs-title function_">pickApi</span>();
</code></pre><h4 id="%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B"><span>Классы-контейнеры</span></a></h4><p>Не создавайте классы-контейнеры со статическими методами или свойствами ради пространства имен.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-variable constant_">FOO</span> = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; }
}
</code></pre><p>Вместо этого экспортируйте отдельные константы и функции:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FOO</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; }
</code></pre><h3 id="%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82-%D0%B8-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82-%D0%B8-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2"><span>Импорт и экспорт типов</span></a></h3><h4 id="%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82-%D1%82%D0%B8%D0%BF%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82-%D1%82%D0%B8%D0%BF%D0%B0"><span>Импорт типа</span></a></h4><p>Вы можете использовать <code>import type {...}</code> если вы используете импортируемый элемент только в качестве типа. Для значений используйте обычный импорт:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {<span class="hljs-title class_">Foo</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo&#x27;</span>;
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">Bar</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo&#x27;</span>;

<span class="hljs-keyword">import</span> {<span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span>, <span class="hljs-title class_">Bar</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo&#x27;</span>;
</code></pre><blockquote><p>Почему?</p><p>Компилятор TypeScript автоматически определяет различия и не внедряет динамическую (runtime) загрузку для обращений к типам. Так зачем же тогда аннотировать импорт типов?</p><p>Компилятор TypeScript может работать в двух режимах:</p><ul><li>В режиме разработки (development mode) мы обычно хотим получить быстрые итерации циклов выполнения. Компилятор транспилирует код в JavaScript без полной информации о типе. Это работает намного быстрее, запрашивая <code>import type</code> лишь в некоторых случаях.</li><li>В режиме эксплуатации (production mode) мы хотим обеспечить корректность. Компилятор проверяет типы для всех элементов, а также проверяет использование корректного <code>import type</code>.</li></ul><p>Совет: Если вам необходима обязательная динамическая (runtime) загрузка для получения сторонних эффектов, используйте <code>import '...';</code>. См. <a href="#%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D1%8B">импорты</a>.</p></blockquote><h4 id="%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82-%D1%82%D0%B8%D0%BF%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82-%D1%82%D0%B8%D0%BF%D0%B0"><span>Экспорт типа</span></a></h4><p>Используйте <code>export type</code> при реэкспорте типа, например:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> {<span class="hljs-title class_">AnInterface</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo&#x27;</span>;
</code></pre><blockquote><p>Почему?</p><p><code>export type</code> полезен тем, что позволяет использовать реэкспорт типов при пофайловой транспиляции. См. <a href="https://www.typescriptlang.org/tsconfig#exports-of-non-value-identifiers">документацию по <code>isolatedModules</code></a>.</p><p>Также <code>export type</code> может показаться полезным, чтобы избежать какого-либо экспортирования значения элемента в API. Однако и это не дает гарантий, т.к. последующий код может по-прежнему импортировать API другим путем. Лучший способ для разделения и гарантии использования API по типу и значению - разделить элементы, например, на <code>UserService</code> и <code>AjaxUserService</code>. Это менее подвержено ошибкам и лучше передает смысл.</p></blockquote><h4 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B8%2C-%D0%B0-%D0%BD%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B0-%D0%B8%D0%BC%D0%B5%D0%BD" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B8%2C-%D0%B0-%D0%BD%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B0-%D0%B8%D0%BC%D0%B5%D0%BD"><span>Используйте модули, а не пространства имен</span></a></h4><p>TypeScript поддерживает два метода организации кода: пространства имен (<em>namespaces</em>) и модули, но использование пространств имен необходимо избегать. Т.е. ваш код <em>должен</em> ссылаться на код в других файлах с помощью импорта и экспорта вида <code>import {foo} from 'bar';</code></p><p>В вашем коде <em>не должны</em> использоваться <code>namespace Foo { ... }</code> конструкции. Пространства имен (<code>namespace</code>) <em>возможно</em> использовать только тогда, когда это необходимо для взаимодействия с внешним сторонним кодом. Чтобы семантически разделить пространство имен вашего кода, используйте отдельные файлы.</p><p>В коде <em>не должны</em> использоваться <code>require</code> (как в <code>import x = require('...');</code>) для импортов. Используйте синтаксис модулей ES6.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Плохо: не используйте пространства имен:</span>
<span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Rocket</span> {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">launch</span>(<span class="hljs-params"></span>) { ... }
}

<span class="hljs-comment">// Плохо: не используйте &lt;reference&gt;</span>
<span class="hljs-comment">/// &lt;reference path=&quot;...&quot;/&gt;</span>

<span class="hljs-comment">// Плохо: не используйте require()</span>
<span class="hljs-keyword">import</span> x = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mydep&#x27;</span>);
</code></pre><blockquote><p>Примечание: В TypeScript пространства имен (<code>namespace</code>) раньше назывались внутренними модулями и использовали ключевое слово <code>module</code> в виде <code>module Foo { ... }</code>. Не используйте такую форму. Всегда используйте ES6 импорты.</p></blockquote><h2 id="%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8"><span>Языковые особенности</span></a></h2><p>В этом разделе указывается, какие особенности можно или нельзя использовать, а также прочие ограничения на их применение.</p><p>Языковые особенности, которые не рассматриваются в данном руководстве по стилю, могут быть использованы без каких-либо рекомендаций по их применению.</p><h3 id="%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D1%85-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D1%85-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85"><span>Объявление локальных переменных</span></a></h3><h4 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-const-%D0%B8-let" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-const-%D0%B8-let"><span>Используйте const и let</span></a></h4><p>Всегда используйте <code>const</code> или <code>let</code> для объявления переменных. По умолчанию используйте <code>const</code>, если не требуется переназначение переменной. Никогда не используйте <code>var</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> foo = otherValue;  <span class="hljs-comment">// Используйте, если &quot;foo&quot; никогда не меняется.</span>
<span class="hljs-keyword">let</span> bar = someValue;     <span class="hljs-comment">// Используйте, если для &quot;bar&quot; когда-либо позднее будет присвоено значение </span>
</code></pre><p><code>const</code> и <code>let</code> имеют блочную область видимости, как и переменные в большинстве других языков. <code>var</code> в JavaScript ограничен областью действия функции, что может вызвать трудные для понимания ошибки. Не используйте его.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">var</span> foo = someValue;     <span class="hljs-comment">// Не используйте - область видимости var сложна и подвержена ошибкам.</span>
</code></pre><p>Переменные <em>не должны</em> использоваться до их объявления.</p><h4 id="%D0%BF%D1%80%D0%B8-%D0%BA%D0%B0%D0%B6%D0%B4%D0%BE%D0%BC-%D0%BE%D0%B1%D1%8C%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B8-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D0%B7%D0%B0%D0%B4%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%BE%D0%B4%D0%BD%D0%B0-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%B8-%D0%BA%D0%B0%D0%B6%D0%B4%D0%BE%D0%BC-%D0%BE%D0%B1%D1%8C%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B8-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D0%B7%D0%B0%D0%B4%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%BE%D0%B4%D0%BD%D0%B0-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F"><span>При каждом обьявлении переменных задается только одна переменная</span></a></h4><p>При каждом объявлении локальных переменных задается только одна переменная: т.е. такие объявления, как <code>let a = 1, b = 2</code>, не используются.</p><h3 id="%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0"><span>Литералы массива</span></a></h3><h4 id="%D0%BD%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80-array" tabindex="-1"><a class="header-anchor" href="#%D0%BD%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80-array"><span>Не используйте конструктор <code>Array</code></span></a></h4><p>В коде <em>не должен</em> использоваться конструктор <code>Array()</code>, с или без <code>new</code>. Его применение неоднозначно и сбивает с толку:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// [undefined, undefined]</span>
<span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [2, 3];</span>
</code></pre><p>Вместо этого всегда используйте скобки для инициализации массивов или <code>from</code> для инициализации <code>Array</code> с определенным размером:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> a = [<span class="hljs-number">2</span>];
<span class="hljs-keyword">const</span> b = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-comment">// Эквивалент для Array(2):</span>
<span class="hljs-keyword">const</span> c = [];
c.<span class="hljs-property">length</span> = <span class="hljs-number">2</span>;

<span class="hljs-comment">// [0, 0, 0, 0, 0]</span>
<span class="hljs-title class_">Array</span>.<span class="hljs-property">from</span>&lt;<span class="hljs-built_in">number</span>&gt;({<span class="hljs-attr">length</span>: <span class="hljs-number">5</span>}).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);
</code></pre><h4 id="%D0%BD%D0%B5-%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9%D1%82%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0-%D0%B2-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D1%85" tabindex="-1"><a class="header-anchor" href="#%D0%BD%D0%B5-%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9%D1%82%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0-%D0%B2-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D1%85"><span>Не определяйте свойства в массивах</span></a></h4><p>Не определяйте и не используйте нечисловые свойства массива (кроме <code>length</code>). Вместо этого используйте <code>Map</code> (или <code>Object</code>).</p><h4 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81%D0%B0-spread-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81%D0%B0-spread-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0"><span>Использование синтаксиса spread-оператора</span></a></h4><p>Использование синтаксиса spread-оператора <code>[...foo]; {...bar}</code> является удобным сокращением для неглубокого копирования или конкатенации итерируемых структур.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> foo = [
  <span class="hljs-number">1</span>,
];

<span class="hljs-keyword">const</span> foo2 = [
  ...foo,
  <span class="hljs-number">6</span>,
  <span class="hljs-number">7</span>,
];

<span class="hljs-keyword">const</span> foo3 = [
  <span class="hljs-number">5</span>,
  ...foo,
];

foo2[<span class="hljs-number">1</span>] === <span class="hljs-number">6</span>;
foo3[<span class="hljs-number">1</span>] === <span class="hljs-number">1</span>;
</code></pre><p>При использовании синтаксиса spread-оператора раскладываемое значение <em>должно</em> соответствовать создаваемому. При создании массива раскладывайте только итерируемые структуры. Примитивы, включая <code>null</code> и <code>undefined</code>, <em>не должны</em> раскладываться.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> foo = [<span class="hljs-number">7</span>];
<span class="hljs-keyword">const</span> bar = [<span class="hljs-number">5</span>, ...(shouldUseFoo &amp;&amp; foo)]; <span class="hljs-comment">// может быть undefined</span>

<span class="hljs-comment">// Создает {0: &#x27;a&#x27;, 1: &#x27;b&#x27;, 2: &#x27;c&#x27;} но при этом не содержит длины (length)</span>
<span class="hljs-keyword">const</span> fooStrings = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];
<span class="hljs-keyword">const</span> ids = {...fooStrings};
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> foo = shouldUseFoo ? [<span class="hljs-number">7</span>] : [];
<span class="hljs-keyword">const</span> bar = [<span class="hljs-number">5</span>, ...foo];
<span class="hljs-keyword">const</span> fooStrings = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];
<span class="hljs-keyword">const</span> ids = [...fooStrings, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>];
</code></pre><h4 id="%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0"><span>Деструктуризация массива</span></a></h4><p>Литералы массивов могут использоваться в левой части присваивания для выполнения деструктуризации (например, при распаковке нескольких значений из одного массива или итерируемого элемента). В конце можно указать переменную (без пробела между <code>...</code> и именем переменной) для присвоения оставшихся элементов (прим. пер.: переменная <code>rest</code> на примере ниже). Неиспользуемые элементы следует пропускать.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> [a, b, c, ...rest] = <span class="hljs-title function_">generateResults</span>();
<span class="hljs-keyword">let</span> [, b,, d] = someArray;
</code></pre><p>Деструктуризация может также использоваться и для параметров функций. Если деструктурированный массив как параметр является необязательным, в таких случаях всегда указывайте <code>[]</code> в качестве значения по умолчанию, а в левой части указывайте значения по умолчанию:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">destructured</span>(<span class="hljs-params">[a = <span class="hljs-number">4</span>, b = <span class="hljs-number">2</span>] = []</span>) { … }
</code></pre><p>Запрещено:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">badDestructuring</span>(<span class="hljs-params">[a, b] = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>]</span>) { … }
</code></pre><blockquote><p>Совет: Для упаковки/распаковки нескольких значений в параметр или в возврат функции (<code>return</code>) по возможности следует предпочесть деструктуризацию объекта вместо деструктуризации массива, поскольку это позволяет присваивать имена отдельным элементам и задавать для каждого из них свой тип.</p></blockquote><h3 id="%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B"><span>Объектные литералы</span></a></h3><h4 id="%D0%BD%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80-object" tabindex="-1"><a class="header-anchor" href="#%D0%BD%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80-object"><span>Не используйте конструктор <code>Object</code></span></a></h4><p>Конструктор <code>Object</code> запрещен. Вместо этого используйте объектные литералы (<code>{}</code> или <code>{a: 0, b: 1, c: 2}</code>).</p><h4 id="%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0%D0%BC" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0%D0%BC"><span>Итерация по объектам</span></a></h4><p>Итерация по объектам с помощью <code>for (... in ...)</code> подвержена вероятным ошибкам, т.к. это включает в себя все перечисляемые свойства из цепочки прототипов.</p><p>Не используйте не фильтрованные <code>for (... in ...)</code> выражения:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">in</span> someObj) {
  <span class="hljs-comment">// x может происходить от некоторого родительского прототипа!</span>
}
</code></pre><p>Либо явно отфильтруйте значения с помощью оператора <code>if</code>, либо используйте <code>for (... of Object.keys(...))</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">in</span> someObj) {
  <span class="hljs-keyword">if</span> (!someObj.<span class="hljs-title function_">hasOwnProperty</span>(x)) <span class="hljs-keyword">continue</span>;
  <span class="hljs-comment">// сейчас x был точно определен в принадлежности someObj</span>
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(someObj)) { <span class="hljs-comment">// примечание: for _of_!</span>
  <span class="hljs-comment">// сейчас x был точно определен в принадлежности someObj</span>
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(someObj)) { <span class="hljs-comment">// примечание: for _of_!</span>
  <span class="hljs-comment">// сейчас key был точно определен в принадлежности someObj</span>
}
</code></pre><h4 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81%D0%B0-spread-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0-1" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81%D0%B0-spread-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0-1"><span>Использование синтаксиса spread-оператора</span></a></h4><p>Использование синтаксиса spread-оператора <code>[...foo]; {...bar}</code> является удобным сокращением для неглубокого копирования объекта. При использовании синтаксиса spread-оператора для инициализации объектов, более поздние значения заменяют более ранние с тем же ключом.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> foo = {
  <span class="hljs-attr">num</span>: <span class="hljs-number">1</span>,
};

<span class="hljs-keyword">const</span> foo2 = {
  ...foo,
  <span class="hljs-attr">num</span>: <span class="hljs-number">5</span>,
};

<span class="hljs-keyword">const</span> foo3 = {
  <span class="hljs-attr">num</span>: <span class="hljs-number">5</span>,
  ...foo,
}

foo2.<span class="hljs-property">num</span> === <span class="hljs-number">5</span>;
foo3.<span class="hljs-property">num</span> === <span class="hljs-number">1</span>;
</code></pre><p>При использовании синтаксиса spread-оператора, раскладываемое значение <em>должно</em> соответствовать создаваемому. Т.е. при создании объекта, spread-оператор может использоваться только на объектах и <em>не должен</em> использоваться на массивах и примитивах (включая <code>null</code> и <code>undefined</code>). Избегайте использовать spread-оператор на объектах, имеющих прототипы, отличные от прототипа Object (например, определений классов, экземпляров классов, функций), так как их поведение неинтуитивно (поверхностно копируются только перечислимые свойства, не относящиеся к прототипу).</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> foo = {<span class="hljs-attr">num</span>: <span class="hljs-number">7</span>};
<span class="hljs-keyword">const</span> bar = {<span class="hljs-attr">num</span>: <span class="hljs-number">5</span>, ...(shouldUseFoo &amp;&amp; foo)}; <span class="hljs-comment">// может быть undefined</span>

<span class="hljs-comment">// Создает {0: &#x27;a&#x27;, 1: &#x27;b&#x27;, 2: &#x27;c&#x27;} но при этом не содержит длины (length)</span>
<span class="hljs-keyword">const</span> fooStrings = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];
<span class="hljs-keyword">const</span> ids = {...fooStrings};
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> foo = shouldUseFoo ? {<span class="hljs-attr">num</span>: <span class="hljs-number">7</span>} : {};
<span class="hljs-keyword">const</span> bar = {<span class="hljs-attr">num</span>: <span class="hljs-number">5</span>, ...foo};
</code></pre><h4 id="%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2"><span>Вычисленные имена свойств</span></a></h4><p>Вычисляемые имена свойств (например, <code>{['key' + foo()]: 42}</code>) разрешены, заключаются в кавычки и рассматриваются в стиле ключей словаря (т.е. не должны смешиваться с ключами без кавычек), если только вычисляемое свойство не принадлежит типу <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>symbol</code></a> (например, <code>[Symbol.iterator]</code>).</p><h4 id="%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0"><span>Деструктуризация объекта</span></a></h4><p>Шаблоны деструктуризации объектов могут использоваться в левой части присваивания для выполнения деструктуризации и распаковки множества значений из отдельного объекта.</p><p>Деструктурированные объекты также могут использоваться в качестве параметров функции, но при этом их следует делать как можно более простыми, с одним уровнем вложенности состоящем из коротких свойств без кавычек. Более глубокие уровни вложенности и вычисляемые свойства не следует использовать при деструктуризации параметров. Любые значения по умолчанию указываются в левой части деструктурируемого параметра (<code>{str = 'some default'} = {}</code>, а не <code>{str} = {str: 'some default'}</code>), а если деструктурируемый объект сам по себе необязателен, то по умолчанию он должен иметь значение <code>{}</code>.</p><p>Например:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Options</span> {
  <span class="hljs-comment">/** Сколько раз выполнять то или иное действие. */</span>
  num?: <span class="hljs-built_in">number</span>;

  <span class="hljs-comment">/** Строка для обработки. */</span>
  str?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">destructured</span>(<span class="hljs-params">{num, str = <span class="hljs-string">&#x27;default&#x27;</span>}: Options = {}</span>) {}
</code></pre><p>Запрещено:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">nestedTooDeeply</span>(<span class="hljs-params">{x: {num, str}}: {x: Options}</span>) {}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">nontrivialDefault</span>(<span class="hljs-params">{num, str}: Options = {num: <span class="hljs-number">42</span>, str: <span class="hljs-string">&#x27;default&#x27;</span>}</span>) {}
</code></pre><h3 id="%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B"><span>Классы</span></a></h3><h4 id="%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2"><span>Объявления классов</span></a></h4><p>Объявления классов <em>не должны</em> завершаться точкой с запятой:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
}; <span class="hljs-comment">// Ненужная точка с запятой</span>
</code></pre><p>В отличие от этого, инструкции, содержащие выражения классов, <em>должны</em> завершаться точкой с запятой:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Baz</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Bar</span> {
  <span class="hljs-title function_">method</span>(): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>;
  }
}; <span class="hljs-comment">// Здесь точка с запятой, поскольку это инструкция, а не объявление класса</span>
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-built_in">exports</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Baz</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Bar</span> {
  <span class="hljs-title function_">method</span>(): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>;
  }
}
</code></pre><p>По поводу использования пустых строк, отделяющих скобки объявления класса от остального содержимого класса, нет никаких особых рекомендаций или запретов:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Никаких пустых строк возле скобок — хорошо.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Baz</span> {
  <span class="hljs-title function_">method</span>(): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>;
  }
}

<span class="hljs-comment">// Одна пустая строка возле обоих скобок - тоже хорошо</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {

  <span class="hljs-title function_">method</span>(): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>;
  }

}
</code></pre><h4 id="%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%B2-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%B2-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0"><span>Объявления методов класса</span></a></h4><p>В объявлениях методов классов <em>не должна</em> использоваться точка с запятой для разделения отдельных объявлений методов:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-title function_">doThing</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;A&quot;</span>);
  }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-title function_">doThing</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;A&quot;</span>);
  }; <span class="hljs-comment">// &lt;-- ненужно</span>
}
</code></pre><p>Объявления методов рекомендуется отделять от окружающего кода одной пустой строкой:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-title function_">doThing</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;A&quot;</span>);
  }

  <span class="hljs-title function_">getOtherThing</span>(): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;
  }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-title function_">doThing</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;A&quot;</span>);
  }
  <span class="hljs-title function_">getOtherThing</span>(): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;
  }
}
</code></pre><h5 id="%D0%BF%D0%B5%D1%80%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0-tostring" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0-tostring"><span>Переопределение метода toString</span></a></h5><p>Метод <code>toString</code> может быть переопределен, но всегда должен срабатывать успешно и не иметь ощутимых побочных эффектов.</p><blockquote><p>Совет: Остерегайтесь, в частности, вызывать другие методы из <code>toString</code>, поскольку при исключительных условиях это может привести к бесконечному циклу.</p></blockquote><h4 id="%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B"><span>Статические методы</span></a></h4><h5 id="%D0%B8%D0%B7%D0%B1%D0%B5%D0%B3%D0%B0%D0%B9%D1%82%D0%B5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B0%D1%82%D0%BD%D1%8B%D1%85-%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%B7%D0%B1%D0%B5%D0%B3%D0%B0%D0%B9%D1%82%D0%B5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B0%D1%82%D0%BD%D1%8B%D1%85-%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%B2"><span>Избегайте приватных статических методов</span></a></h5><p>Отдавайте предпочтение локальным функциям внутри модуля, а не приватным статическим методам, в случаях, когда это не мешает удобочитаемости.</p><h5 id="%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BB%D0%B0%D0%B3%D0%B0%D0%B9%D1%82%D0%B5%D1%81%D1%8C-%D0%BD%D0%B0-%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D1%83%D1%8E-%D0%B4%D0%B8%D1%81%D0%BF%D0%B5%D1%82%D1%87%D0%B5%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8E" tabindex="-1"><a class="header-anchor" href="#%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BB%D0%B0%D0%B3%D0%B0%D0%B9%D1%82%D0%B5%D1%81%D1%8C-%D0%BD%D0%B0-%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D1%83%D1%8E-%D0%B4%D0%B8%D1%81%D0%BF%D0%B5%D1%82%D1%87%D0%B5%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8E"><span>Не полагайтесь на динамическую диспетчеризацию</span></a></h5><p>В коде <em>не рекомендуется</em> полагаться на динамическую диспетчеризацию статических методов. Статические методы <em>рекомендуется</em> вызывать только непосредственно на базовом классе (в котором они определены). Статические методы <em>не рекомендуется</em> вызывать на переменных, содержащих динамический экземпляр, который может быть конструктором как самого класса, так и конструктором его подкласса (и <em>должен</em> быть определен с помощью <code>@nocollapse</code><sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>, если он существует), а также <em>не должны</em> вызываться непосредственно на подклассе, который не определяет данный метод.</p><p>Запрещено:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Контекст для примеров ниже (этот класс вполне приемлем сам по себе)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {
  <span class="hljs-comment">/** <span class="hljs-doctag">@nocollapse</span> */</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {}
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Base</span> {}

<span class="hljs-comment">// Предостережение: не вызывайте статические методы динамически</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">callFoo</span>(<span class="hljs-params">cls: <span class="hljs-keyword">typeof</span> Base</span>) {
  cls.<span class="hljs-title function_">foo</span>();
}

<span class="hljs-comment">// Запрещено: не вызывайте статические методы в подклассах, которые сами их не определяют</span>
<span class="hljs-title class_">Sub</span>.<span class="hljs-title function_">foo</span>();

<span class="hljs-comment">// Запрещено: не обращайтесь к `this` в статических методах</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">staticField</span>;
  }
}
<span class="hljs-title class_">MyClass</span>.<span class="hljs-property">staticField</span> = <span class="hljs-number">1</span>;
</code></pre><h5 id="%D0%B8%D0%B7%D0%B1%D0%B5%D0%B3%D0%B0%D0%B9%D1%82%D0%B5-this-%D0%B2-%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%BC-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B5" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%B7%D0%B1%D0%B5%D0%B3%D0%B0%D0%B9%D1%82%D0%B5-this-%D0%B2-%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%BC-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B5"><span>Избегайте <code>this</code> в статическом контексте</span></a></h5><p>В коде <em>не должен</em> использоваться <code>this</code> в статическом контексте.</p><p>JavaScript позволяет обращаться к статическим полям через <code>this</code>. Кроме того, в отличие от других языков, статические поля являются наследуемыми.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoeStore</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-attr">storage</span>: <span class="hljs-title class_">Storage</span> = ...;

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">isAvailable</span>(<span class="hljs-params">s: Shoe</span>) {
    <span class="hljs-comment">// Плохо: не используйте `this` в статическом методе.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">storage</span>.<span class="hljs-title function_">has</span>(s.<span class="hljs-property">id</span>);
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EmptyShoeStore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ShoeStore</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-attr">storage</span>: <span class="hljs-title class_">Storage</span> = <span class="hljs-variable constant_">EMPTY_STORE</span>;  <span class="hljs-comment">// переопределяет storage из ShoeStore</span>
}
</code></pre><blockquote><p>Почему?</p><p>Этот код может привести к неожиданностям: авторы могут не ожидать, что к статическим полям можно обращаться через указатель <code>this</code> и могут быть удивлены, обнаружив, что они могут быть переопределены — подобная функциональность используется не часто.</p><p>Этот код также поощряет использование антипаттерна, заключающегося в наличии значительного статического состояния, что вызывает проблемы с тестируемостью.</p></blockquote><h4 id="%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80%D1%8B"><span>Конструкторы</span></a></h4><p>При вызове конструктора всегда <em>должны</em> использоваться скобки, даже если никакие аргументы не передаются:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();
</code></pre><p>Отсутствие скобок может привести к трудноуловимым ошибкам. Эти две строки не эквивалентны:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title class_">Bar</span>();
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>.<span class="hljs-title class_">Bar</span>();
</code></pre><p>Нет необходимости предоставлять пустой конструктор или конструктор, который просто делегирует в родительский класс, поскольку ES2015 предоставляет конструктор класса по умолчанию, если он не указан. Однако <em>не рекомендуется</em> убирать конструкторы с параметризованными свойствами, модификаторами области видимости или декораторами параметров, даже если тело конструктора пустое.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UnnecessaryConstructor</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UnnecessaryConstructorOverride</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Base</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value: <span class="hljs-built_in">number</span></span>) {
      <span class="hljs-variable language_">super</span>(value);
    }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultConstructor</span> {
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ParameterProperties</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> myService</span>) {}
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ParameterDecorators</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@SideEffectDecorator</span> myService</span>) {}
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">NoInstantiation</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}
}
</code></pre><p>Конструктор рекомендуется отделять от окружающего кода как сверху, так и снизу одной пустой строкой:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  myField = <span class="hljs-number">10</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ctorParam</span>) {}

  <span class="hljs-title function_">doThing</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ctorParam.<span class="hljs-title function_">getThing</span>() + myField);
  }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  myField = <span class="hljs-number">10</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ctorParam</span>) {}
  <span class="hljs-title function_">doThing</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ctorParam.<span class="hljs-title function_">getThing</span>() + myField);
  }
}
</code></pre><h4 id="%D1%87%D0%BB%D0%B5%D0%BD%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D1%87%D0%BB%D0%B5%D0%BD%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0"><span>Члены класса</span></a></h4><h5 id="%D0%BD%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B0%D1%82%D0%BD%D1%8B%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8F-%D0%B2%D0%B8%D0%B4%D0%B0-%23private" tabindex="-1"><a class="header-anchor" href="#%D0%BD%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B0%D1%82%D0%BD%D1%8B%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8F-%D0%B2%D0%B8%D0%B4%D0%B0-%23private"><span>Не используйте приватные поля вида <code>#private</code></span></a></h5><p>Не используйте приватные поля (также известные как приватные идентификаторы):</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Clazz</span> {
  #ident = <span class="hljs-number">1</span>;
}
</code></pre><p>Вместо этого используйте поддерживаемые TypeScript аннотации видимости:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Clazz</span> {
  <span class="hljs-keyword">private</span> ident = <span class="hljs-number">1</span>;
}
</code></pre><blockquote><p>Почему?</p><p>Приватные идентификаторы вызывают существенные проблемы с размером и производительностью при понижении версии стандарта ECMAScript, в которую будет скомпилирован код TypeScript и не поддерживаются до ES2015. Они могут быть понижены только до уровня ES2015, но не ниже. В то же время, они не дают существенных преимуществ, когда для контроля области видимости используется статическая проверка типов.</p></blockquote><h5 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80-readonly" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80-readonly"><span>Используйте модификатор <code>readonly</code></span></a></h5><p>Пометьте модификатором <code>readonly</code> те свойства, которые никогда не переназначаются вне конструктора (они не обязательно должны быть глубоко неизменяемыми).</p><h5 id="%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0"><span>Параметризованные свойства</span></a></h5><p>Вместо того чтобы просто передавать очевидный инициализатор в член класса, используйте <a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties">параметризованные свойства</a> TypeScript.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">barService</span>: <span class="hljs-title class_">BarService</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">barService: BarService</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">barService</span> = barService;
  }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> barService: BarService</span>) {}
}
</code></pre><p>Если параметризованное свойство нуждается в документировании, то <a href="#%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%BA-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%D0%BC">используйте JSDoc тег <code>@param</code></a>.</p><h5 id="%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BF%D0%BE%D0%BB%D0%B5%D0%B9" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BF%D0%BE%D0%BB%D0%B5%D0%B9"><span>Инициализаторы полей</span></a></h5><p>Если элемент класса не является параметризованным свойством, инициализируйте его там, где он объявлен, что иногда позволяет совсем отбросить конструктор.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">userList</span>: <span class="hljs-built_in">string</span>[];

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">userList</span> = [];
  }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">userList</span>: <span class="hljs-built_in">string</span>[] = [];
}
</code></pre><blockquote><p>Совет: Свойства никогда не должны добавляться или удаляться из экземпляра после завершения работы конструктора, поскольку это существенно ограничивает возможности виртуальной машины в плане оптимизации структуры классов. Необязательные поля, которые могут быть заполнены позже, должны быть явно инициализированы значением <code>undefined</code>, чтобы предотвратить последующее изменение структуры.</p></blockquote><h5 id="%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%2C-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D0%BC%D1%8B%D0%B5-%D0%B7%D0%B0-%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B0%D0%BC%D0%B8-%D0%BB%D0%B5%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B9-%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%2C-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D0%BC%D1%8B%D0%B5-%D0%B7%D0%B0-%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B0%D0%BC%D0%B8-%D0%BB%D0%B5%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B9-%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0"><span>Свойства, используемые за пределами лексической области класса</span></a></h5><p>Для свойств, так или иначе задействованных вне лексической области видимости содержащего их класса, например, для свойств контроллера Angular используемых из шаблона, <em>не должна</em> использоваться приватная (<code>private</code>) область видимости, т.к. к этим свойствам потребуется доступ за пределами лексической области видимости их класса.</p><p>Для этих свойств используйте либо <code>protected</code>, либо <code>public</code>, в зависимости от того, что подходит. Для свойств используемых в шаблонах Angular и AngularJS следует использовать <code>protected</code>, а в Polymer - <code>public</code>.</p><p>В TypeScript коде <em>не должны</em> использоваться <code>obj['foo']</code> для обхода ограничения видимости свойства.</p><blockquote><p>Почему?</p><p>Когда свойство является приватным (<code>private</code>), вы объявляете автоматизированным системам и людям, что доступ к свойству ограничен методами объявленного класса, и они будут полагаться на это. Например, проверка на неиспользуемый код отметит приватное свойство, которое может посчитаться неиспользуемым, даже если какому-то коду из другого файла удастся обойти ограничение видимости.</p><p>Хотя это и кажется, что <code>obj['foo']</code> может обойти область видимости в компиляторе TypeScript, эта схема может быть нарушена путем изменения правил сборки, а также нарушается согласованность с оптимизациями.</p></blockquote><h5 id="%D0%B3%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B-%D0%B8-%D1%81%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%B3%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B-%D0%B8-%D1%81%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B"><span>Геттеры и Сеттеры</span></a></h5><p>Для членов класса <em>возможно</em> иcпользовать геттеры и сеттеры, также известные как аксессоры. Методы-геттеры <em>должны</em> быть <a href="https://en.wikipedia.org/wiki/Pure_function">чистыми функциями</a> (т.е. не иметь побочных эффектов и каждый раз возвращать одинаковый результат при одних и тех же параметрах, при этом геттеры не должны изменять наблюдаемое состояние). Они также полезны как средство ограничения видимости внутренних или подробных деталей реализации (показано ниже).</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> someService: SomeService</span>) {}

  <span class="hljs-keyword">get</span> <span class="hljs-title function_">someMember</span>(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">someService</span>.<span class="hljs-property">someVariable</span>;
  }

  <span class="hljs-keyword">set</span> <span class="hljs-title function_">someMember</span>(<span class="hljs-params">newValue: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">someService</span>.<span class="hljs-property">someVariable</span> = newValue;
  }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  nextId = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">next</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextId</span>++; <span class="hljs-comment">// Плохо: геттер изменяет наблюдаемое состояние]</span>
  }
}
</code></pre><p>Если аксессор используется для сокрытия свойства класса, то для скрытого свойства <em>возможно</em> указать префикс или суффикс с любым целым словом, например <code>internal</code> или <code>wrapped</code>. При использовании этих приватных свойств по возможности обращайтесь к их значению через аксессор. По крайней мере один аксессор к свойству <em>должен</em> быть нетривиальным: не определяйте сквозные аксессоры только для того, чтобы скрыть свойство. Вместо этого сделайте свойство публичным (или подумайте о том, чтобы сделать его доступным только для чтения (<code>readonly</code>), чем просто определять геттер без сеттера).</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">private</span> wrappedBar = <span class="hljs-string">&#x27;&#x27;</span>;
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">bar</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">wrappedBar</span> || <span class="hljs-string">&#x27;bar&#x27;</span>;
  }

  <span class="hljs-keyword">set</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">wrapped: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">wrappedBar</span> = wrapped.<span class="hljs-title function_">trim</span>();
  }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> {
  <span class="hljs-keyword">private</span> barInternal = <span class="hljs-string">&#x27;&#x27;</span>;
  <span class="hljs-comment">// Ни один из этих аксессоров не имеет логики, поэтому просто сделайте bar публичным</span>
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">bar</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">barInternal</span>;
  }

  <span class="hljs-keyword">set</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">barInternal</span> = value;
  }
}
</code></pre><p>Геттеры и сеттеры <em>не должны</em> задаваться с помощью <code>Object.defineProperty</code>, так как это препятствует переименованию свойств.</p><h5 id="%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D1%8F%D0%B5%D0%BC%D1%8B%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D1%8F%D0%B5%D0%BC%D1%8B%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0"><span>Вычисляемые свойства</span></a></h5><p>Вычисляемые свойства могут использоваться в классах только в том случае, если свойство имеет тип <code>symbol</code>. Свойства в словарном стиле (т.е. заключенные в кавычки или не являющиеся типом <code>symbol</code> в качестве ключа) не допускаются. Метод <code>[Symbol.iterator]</code> рекомендуется определять для любых классов которые логически итерируемы. В остальном, <code>Symbol</code> рекомендуется использовать умеренно.</p><blockquote><p>Совет: Будьте осторожны с использованием других встроенных свойств типа <code>symbol</code> (например <code>Symbol.isConcatSpreadable</code>), поскольку они не полифиллятся компилятором и следовательно не будут работать в старых браузерах.</p></blockquote><h4 id="%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C" tabindex="-1"><a class="header-anchor" href="#%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C"><span>Видимость</span></a></h4><p>Ограничение видимости свойств, методов и целых типов помогает сохранить код слабо связанным.</p><ul><li>Максимально ограничивайте область видимости обозначений.</li><li>Рассмотрите возможность преобразования приватных методов в неэкспортируемые функции в том же файле, но вне какого-либо класса, а также перемещение приватных свойств в отдельные, неэкспортируемые классы.</li><li>В TypeScript все обозначения по умолчанию публичные. Никогда не используйте модификатор <code>public</code>, за исключением случаев объявления доступных для чтения и записи (т.е. не <code>readonly</code>) публичных параметризованных свойств (в конструкторе).</li></ul><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">public</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>();  <span class="hljs-comment">// ПЛОХО: нет необходимости в модификаторе &quot;public&quot;</span>

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> baz: Baz</span>) {}  <span class="hljs-comment">// ПЛОХО: модификатор &quot;readonly&quot; подразумевает, что это свойство имеет по умолчанию модификатор &quot;public&quot;</span>
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  bar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>();  <span class="hljs-comment">// ХОРОШО: нет необходимости в модификаторе &quot;public&quot;</span>

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> baz: Baz</span>) {}  <span class="hljs-comment">// допускается модификатор &quot;public&quot;</span>
}
</code></pre><p>См. также <a href="#%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D1%85-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2">Область видимости экспортируемых элементов</a>.</p><h4 id="%D0%BD%D0%B5%D0%B4%D0%BE%D0%BF%D1%83%D1%81%D1%82%D0%B8%D0%BC%D1%8B%D0%B5-%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BF%D1%80%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5-%D1%81-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%D0%BC%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%BD%D0%B5%D0%B4%D0%BE%D0%BF%D1%83%D1%81%D1%82%D0%B8%D0%BC%D1%8B%D0%B5-%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BF%D1%80%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5-%D1%81-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%D0%BC%D0%B8"><span>Недопустимые паттерны при работе с классами</span></a></h4><h5 id="%D0%BD%D0%B5-%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D1%83%D0%B9%D1%82%D0%B5-%D0%BD%D0%B0%D0%BF%D1%80%D1%8F%D0%BC%D1%83%D1%8E-%D1%81-%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF%D0%B0%D0%BC%D0%B8-(prototype)" tabindex="-1"><a class="header-anchor" href="#%D0%BD%D0%B5-%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D1%83%D0%B9%D1%82%D0%B5-%D0%BD%D0%B0%D0%BF%D1%80%D1%8F%D0%BC%D1%83%D1%8E-%D1%81-%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF%D0%B0%D0%BC%D0%B8-(prototype)"><span>Не взаимодействуйте напрямую с прототипами (<code>prototype</code>)</span></a></h5><p>Ключевое слово <code>class</code> позволяет создавать более понятные и читаемые определения классов, чем определение свойств в прототипах (<code>prototype</code>). В обычном прикладном коде нет необходимости манипулировать этими объектами. Миксины и модификация прототипов встроенных объектов однозначно запрещены.</p><p><strong>Исключение:</strong> В коде фреймворков (например, Polymer или Angular) вполне может потребоваться использование прототипов (<code>prototype</code>) и в таком случае не рекомендуется прибегать к еще более худшим обходным путям, которые позволяют избежать этого.</p><h3 id="%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8"><span>Функции</span></a></h3><h4 id="%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F" tabindex="-1"><a class="header-anchor" href="#%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F"><span>Терминология</span></a></h4><p>Существует множество различных типов функций со своими характерными различиями между ними. В этом руководстве используется приведенная ниже терминология, которая соответствует <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions">MDN</a>:</p><ul><li>&quot;Объявление функции&quot;: объявление (т.е. не выражение) с использованием ключевого слова <code>function</code></li><li>&quot;Функциональное выражение&quot;: выражение, обычно используемое в качестве значения при присваивании или передаваемое в качестве параметра, также с использованием ключевого слова <code>function</code></li><li>&quot;Стрелочная функция&quot;: выражение, использующее <code>=&gt;</code> синтаксис</li><li>&quot;Блочное тело функции&quot;: правая часть стрелочной функции со скобками</li><li>&quot;Краткое тело функции&quot;: правая часть стрелочной функции без скобок</li></ul><p>Методы и классы/конструкторы в этом разделе не рассматриваются.</p><h4 id="%D0%B4%D0%BB%D1%8F-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9-%D0%BF%D1%80%D0%B5%D0%B4%D0%BF%D0%BE%D1%87%D1%82%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9-(function-declaration)" tabindex="-1"><a class="header-anchor" href="#%D0%B4%D0%BB%D1%8F-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9-%D0%BF%D1%80%D0%B5%D0%B4%D0%BF%D0%BE%D1%87%D1%82%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9-(function-declaration)"><span>Для создания именованных функций предпочтительно использовать объявления функций (Function Declaration)</span></a></h4><p>При определении именованных функций отдавайте предпочтение объявлениям функций, а не стрелочным функциям или функциональным выражениям.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-title function_">foo</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-number">42</span>;
</code></pre><p>Стрелочные функции <em>возможны</em> к использованию в тех случаях, когда например требуется явное указание типа.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">SearchFunction</span> {
  (<span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">fooSearch</span>: <span class="hljs-title class_">SearchFunction</span> = <span class="hljs-function">(<span class="hljs-params">source, subString</span>) =&gt;</span> { ... };
</code></pre><h4 id="%D0%B2%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%B2%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8"><span>Вложенные функции</span></a></h4><p>В зависимости от ситуации, для тех функций, которые вложены в другие методы или функции, <em>возможно</em> использование объявлений функций или стрелочных функций. В частности, в теле метода предпочтительнее использовать стрелочные функции, поскольку они имеют доступ к внешнему <code>this</code>.</p><h4 id="%D0%BD%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F." tabindex="-1"><a class="header-anchor" href="#%D0%BD%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F."><span>Не используйте функциональные выражения.</span></a></h4><p>Не используйте функциональные выражения. Вместо этого используйте стрелочные функции.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-title function_">bar</span>(<span class="hljs-function">() =&gt;</span> { <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">doSomething</span>(); })
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-title function_">bar</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... })
</code></pre><p><strong>Исключение:</strong> Функциональные выражения <em>возможно</em> использовать <em>только в тех случаях</em>, когда код должен динамически перепривязывать <code>this</code> (но это <a href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-this">не приветствуется</a>) или для функций-генераторов (которые не поддерживают стрелочный синтаксис).</p><h4 id="%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D1%85-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9" tabindex="-1"><a class="header-anchor" href="#%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D1%85-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9"><span>Формы стрелочных функций</span></a></h4><p>Используйте стрелочные функции с кратким (т.е. в виде выражения) или блочным телом функции там гдн это целесообразно.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Для объявления функции верхнего уровня используйте Function Declarations.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">someFunction</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Блочное тело функции - это хорошо</span>
  <span class="hljs-keyword">const</span> receipts = books.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">b: Book</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> receipt = <span class="hljs-title function_">payMoney</span>(b.<span class="hljs-property">price</span>);
    <span class="hljs-title function_">recordTransaction</span>(receipt);
    <span class="hljs-keyword">return</span> receipt;
  });

  <span class="hljs-comment">// Использование краткого тела функции является хорошим подходом, если возвращаемое значение будет использоваться:</span>
  <span class="hljs-keyword">const</span> longThings = myValues.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1000</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-title class_">String</span>(v));

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">payMoney</span>(<span class="hljs-params">amount: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-comment">// Function Declarations - это хорошо, но при этом вы не должны в них обращаться к `this`. </span>
  }

  <span class="hljs-comment">// Вложенные стрелочные функции могут быть назначены константе</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">computeTax</span> = (<span class="hljs-params">amount: <span class="hljs-built_in">number</span></span>) =&gt; amount * <span class="hljs-number">0.12</span>;
}
</code></pre><p>Используйте краткое тело функции только в том случае, если возвращаемое значение функции будет действительно использоваться. Блочное тело функции обеспечивает то, что возвращаемый тип является <code>void</code>, тем самым предотвращая возможные побочные эффекты.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// ПЛОХО: используйте блочное тело функции, если возвращаемое значение не используется.</span>
myPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v));
<span class="hljs-comment">// ПЛОХО: Хоть тут и есть проверка типа, это не защищает от нежелательного возврата значения.</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">f</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
f = <span class="hljs-function">() =&gt;</span> <span class="hljs-number">1</span>;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// ХОРОШО: используется блочное тело функции поскольку возвращаемое значение не используется.</span>
myPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v);
});
<span class="hljs-comment">// ХОРОШО: в коде могут использоваться блоки для удобочитаемости.</span>
<span class="hljs-keyword">const</span> transformed = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> intermediate = <span class="hljs-title function_">someComplicatedExpr</span>(v);
  <span class="hljs-keyword">const</span> more = <span class="hljs-title function_">acrossManyLines</span>(intermediate);
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">worthWrapping</span>(more);
});
<span class="hljs-comment">// ХОРОШО: явный `void` обеспечивает защиту от нежелательного возврата значения</span>
myPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">void</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v));
</code></pre><blockquote><p>Совет: Оператор <code>void</code> можно использовать для обеспечения гарантии того, что стрелочная функция c коротким телом функции всегда будет возвращать <code>undefined</code> для тех случаев, когда результат не планируется использовать.</p></blockquote><h4 id="%D0%BF%D0%B5%D1%80%D0%B5%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-this" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-this"><span>Перепривязывание <code>this</code></span></a></h4><p>Функциональные выражения и объявления функций <em>не должны</em> использовать <code>this</code>, если только они не существуют специально для перепривязки <code>this</code>. В большинстве случаев перепривязки <code>this</code> можно избежать, используя стрелочные функции или явно заданные параметры.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">clickHandler</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Плохо: что такое «this» в этом контексте?</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;Hello&#x27;</span>;
}
<span class="hljs-comment">// Плохо: `this` неявно ссылается на document.body .</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">onclick</span> = clickHandler;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Хорошо: явная ссылка на объект из стрелочной функции.</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> { <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;hello&#x27;</span>; };
<span class="hljs-comment">// Альтернатива: взять явно заданный параметр</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">setTextFn</span> = (<span class="hljs-params">e: HTMLElement</span>) =&gt; { e.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;hello&#x27;</span>; };
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">onclick</span> = setTextFn.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>);
</code></pre><p>Предпочтительно использовать стрелочные функции по сравнению с другими подходами к привязыванию <code>this</code>, такими как <code>f.bind(this)</code>, <code>goog.bind(f, this)</code> или <code>const self = this</code>.</p><h4 id="%D0%B2-%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0-(callback)-%D0%BF%D1%80%D0%B5%D0%B4%D0%BF%D0%BE%D1%87%D1%82%D0%B8%D1%82%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D0%B2%D0%B0%D1%82%D1%8C-%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BD%D1%83%D1%8E-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8E" tabindex="-1"><a class="header-anchor" href="#%D0%B2-%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0-(callback)-%D0%BF%D1%80%D0%B5%D0%B4%D0%BF%D0%BE%D1%87%D1%82%D0%B8%D1%82%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D0%B2%D0%B0%D1%82%D1%8C-%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BD%D1%83%D1%8E-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8E"><span>В качестве функции обратного вызова (callback) предпочтите передавать стрелочную функцию</span></a></h4><p>Обратные вызовы могут быть вызваны с непредусмотренными аргументами, которые могут пройти проверку типов, но при этом все равно приведут к логическим ошибкам.</p><p>Избегайте передачи именованной функции обратного вызова в функцию более высокого порядка, если вы не уверены в стабильности сигнатур вызовов обеих функций. Остерегайтесь, в частности, редко используемых необязательных параметров.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// ПЛОХО: Аргументы не передаются явно, что приводит к нежелательному поведению, </span>
<span class="hljs-comment">// поскольку необязательный аргумент функции parseInt, задающий основание счисления,</span>
<span class="hljs-comment">// получает индексы массивов 0, 1 и 2.</span>
<span class="hljs-keyword">const</span> numbers = [<span class="hljs-string">&#x27;11&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>].<span class="hljs-title function_">map</span>(<span class="hljs-built_in">parseInt</span>);
<span class="hljs-comment">// &gt; [11, NaN, 2];</span>
</code></pre><p>Вместо этого предпочтительно передавать стрелочную функцию, которая в свою очередь явно передает параметры в именованную функцию обратного вызова.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// ХОРОШО: Аргументы явно передаются в функцию обратного вызова</span>
<span class="hljs-keyword">const</span> numbers = [<span class="hljs-string">&#x27;11&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> <span class="hljs-built_in">parseInt</span>(n));
<span class="hljs-comment">// &gt; [11, 5, 3]</span>

<span class="hljs-comment">// ХОРОШО: Функция определена локально и предназначена для использования в качестве функции обратного вызова</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">dayFilter</span>(<span class="hljs-params">element: <span class="hljs-built_in">string</span>|<span class="hljs-literal">null</span>|<span class="hljs-literal">undefined</span></span>) {
  <span class="hljs-keyword">return</span> element != <span class="hljs-literal">null</span> &amp;&amp; element.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;day&#x27;</span>);
}

<span class="hljs-keyword">const</span> days = [<span class="hljs-string">&#x27;tuesday&#x27;</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;juice&#x27;</span>, <span class="hljs-string">&#x27;wednesday&#x27;</span>].<span class="hljs-title function_">filter</span>(dayFilter);
</code></pre><h4 id="%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BA%D0%B0%D0%BA-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BA%D0%B0%D0%BA-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0"><span>Стрелочные функции как свойства</span></a></h4><p>В классах обычно <em>не рекомендуется</em> содержать свойства, которые проинициализированы как стрелочные функции. Использование стрелочных функций как свойств требует чтобы вызывающая их функция корректно понимала, что у вызываемой функции уже есть привязанный <code>this</code>, что увеличивает путаницу в понимании того, что такое <code>this</code>, а сами места вызовов и ссылки использующие эти функции могут смотреться некорректно работающими (т.к. это требует дополнительных знаний об окружении за пределами локальной области вызывающей функции, чтобы определить, что они корректны). В коде <em>рекомендуется</em> всегда использовать стрелочные функции для вызова методов экземпляра (<code>const handler = (x) =&gt; { this.listener(x); };</code>) и <em>не рекомендуется</em> получать или передавать ссылки на методы экземпляра (<s><code>const handler = this.listener; handler(x);</code></s>).</p><blockquote><p>Примечание: в некоторых специфических ситуациях, например, в случае привязки функций к шаблонам, стрелочные функции в качестве свойств полезны и создают гораздо более читабельный код. Руководствуйтесь здравым смыслом при использовании этого правила. Также см. раздел <a href="#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B8-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9">Обработчики событий</a> ниже.</p></blockquote><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayHandler</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Проблема: `this` не сохраняется в функции обратного вызова. `this` в обратном вызове</span>
    <span class="hljs-comment">// не будет экземпляром DelayHandler.</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">patienceTracker</span>, <span class="hljs-number">5000</span>);
  }
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">patienceTracker</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">waitedPatiently</span> = <span class="hljs-literal">true</span>;
  }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Стрелочные функции обычно не рекомендуется задавать свойствам.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayHandler</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Плохо: этот код выглядит так, как будто тут забыли привязать `this`. </span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">patienceTracker</span>, <span class="hljs-number">5000</span>);
  }
  <span class="hljs-keyword">private</span> patienceTracker = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">waitedPatiently</span> = <span class="hljs-literal">true</span>;
  }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Явное управление `this` во время вызова.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayHandler</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// По возможности используйте анонимные функции.</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">patienceTracker</span>();
    }, <span class="hljs-number">5000</span>);
  }
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">patienceTracker</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">waitedPatiently</span> = <span class="hljs-literal">true</span>;
  }
}
</code></pre><h4 id="%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B8-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B8-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9"><span>Обработчики событий</span></a></h4><p>Обработчики событий <em>могут</em> использовать стрелочные функции, когда нет необходимости удалять обработчик (например, если событие генерируется самим классом). Если для обработчика впоследствии требуется удаление, тогда правильным подходом будет использование назначенной свойству стрелочной функции, поскольку они автоматически захватывают <code>this</code> и при этом обеспечивается постоянная ссылка на обработчик для его последующего удаления.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Обработчики событий могут быть анонимными функциями или назначенные свойствам стрелочными функциями.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> {
  <span class="hljs-title function_">onAttached</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Событие генерируется этим классом, удалять его не нужно.</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">listener</span>();
    });
    <span class="hljs-comment">// this.listener это постоянная ссылка на функцию-обработчик, которую мы позже можем удалить.</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;onbeforeunload&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">listener</span>);
  }
  <span class="hljs-title function_">onDetached</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Событие генерируется окном (window). Если мы не удалим функцию-обработчик (this.listener), то она</span>
    <span class="hljs-comment">// сохранит ссылку на `this` к которой привязана, что приведет к утечке памяти.</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;onbeforeunload&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">listener</span>);
  }
  <span class="hljs-comment">// Стрелочная функция, хранящаяся в свойстве, автоматически привязывается к `this`.</span>
  <span class="hljs-keyword">private</span> listener = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">confirm</span>(<span class="hljs-string">&#x27;Вы хотите покинуть страницу?&#x27;</span>);
  }
}
</code></pre><p>Не используйте <code>bind</code> в выражениях, которые устанавливают обработчики событий, потому что это создает временную ссылку, которую нельзя удалить.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Привязка слушателей создает временную ссылку, которая недоступна для удаления.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> {
  <span class="hljs-title function_">onAttached</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Это создает временную ссылку, которая нам не будет доступна для удаления.</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;onbeforeunload&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">listener</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));
  }
  <span class="hljs-title function_">onDetached</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// метод bind каждый раз создает новую ссылку, поэтому эта строка не делает ничего.</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;onbeforeunload&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">listener</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));
  }
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">listener</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">confirm</span>(<span class="hljs-string">&#x27;Вы хотите покинуть страницу?&#x27;</span>);
  }
}
</code></pre><h4 id="%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2-(%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E)" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2-(%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E)"><span>Инициализаторы параметров (значения параметров по умолчанию)</span></a></h4><p>Необязательным параметрам функции может быть задано значение-инициализатор по умолчанию, который будет использоваться, когда аргумент опущен. Инициализаторы не должны иметь каких-либо заметных побочных эффектов. Инициализаторы рекомендуется делать как можно более простыми.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, extraContext: <span class="hljs-built_in">string</span>[] = []</span>) {}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">activate</span>(<span class="hljs-params">index = <span class="hljs-number">0</span></span>) {}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// ПЛОХО: побочный эффект инкрементирования счетчика</span>
<span class="hljs-keyword">let</span> globalCounter = <span class="hljs-number">0</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">newId</span>(<span class="hljs-params">index = globalCounter++</span>) {}

<span class="hljs-comment">// ПЛОХО: раскрывает общее мутабельное состояние, что может привести к непреднамеренной связанности между вызовами функций</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">defaultPaths</span>: <span class="hljs-built_in">string</span>[];
  <span class="hljs-title function_">frobnicate</span>(<span class="hljs-params">paths = defaultPaths</span>) {}
}
</code></pre><p>Используйте параметры по умолчанию умеренно. Предпочтительно использовать <a href="#%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0">деструктуризацию</a> для создания читабельных API, в случае если имеется более чем несколько необязательных параметров, которые не имеют определенного порядка расположения друг за другом.</p><h4 id="%D0%BF%D1%80%D0%B5%D0%B4%D0%BF%D0%BE%D1%87%D1%82%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-rest-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D0%B8-spread-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D0%B2-%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B5-%D0%B5%D1%81%D0%BB%D0%B8-%D1%8D%D1%82%D0%BE-%D0%B2%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5-%D1%83%D0%BC%D0%B5%D1%81%D1%82%D0%BD%D0%BE" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%B5%D0%B4%D0%BF%D0%BE%D1%87%D1%82%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-rest-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D0%B8-spread-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D0%B2-%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B5-%D0%B5%D1%81%D0%BB%D0%B8-%D1%8D%D1%82%D0%BE-%D0%B2%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5-%D1%83%D0%BC%D0%B5%D1%81%D1%82%D0%BD%D0%BE"><span>Предпочтительно использовать rest-оператор и spread-оператор в случае если это вполне уместно</span></a></h4><p>Используйте rest-параметр вместо доступа к переменной <code>arguments</code>. Никогда не называйте локальную переменную или параметр как <code>arguments</code>, поскольку это вносит путаницу, перекрывая встроенное имя.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">variadic</span>(<span class="hljs-params">array: <span class="hljs-built_in">string</span>[], ...numbers: <span class="hljs-built_in">number</span>[]</span>) {}
</code></pre><p>Вместо <code>Function.prototype.apply</code> используйте функционал spread-оператора.</p><h4 id="%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9" tabindex="-1"><a class="header-anchor" href="#%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9"><span>Форматирование функций</span></a></h4><p>Пустые строки в начале или конце тела функции не допускаются.</p><p>В отдельных случаях для создания логических групп выражений в теле функции <code>возможно</code> использование одинарной пустой строки.</p><p>В генераторах рекомендуется добавлять символ <code>*</code> к ключевым словам <code>function</code> и <code>yield</code>, т.е. <code>function* foo()</code> и <code>yield* iter</code>, а не <code>function *foo()</code> или <code>yield *iter</code>.</p><p>Скобки вокруг левой части одноаргументной стрелочной функции рекомендуются, но не обязательны.</p><p>Не ставьте пробел после <code>...</code> в синтаксисе rest-оператора или spread-оператора.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params">...elements: <span class="hljs-built_in">number</span>[]</span>) {}
<span class="hljs-title function_">myFunction</span>(...array, ...iterable, ...<span class="hljs-title function_">generator</span>());
</code></pre><h4 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-this" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-this"><span>Использование this</span></a></h4><p>Используйте <code>this</code> только в конструкторах и методах классов, в функциях, в которых явно объявлен тип <code>this</code> (например, <code>function func(this: ThisType, ...)</code>), или в стрелочных функциях, определенных в той области видимости, в которой может использоваться <code>this</code>.</p><p>Никогда не используйте <code>this</code> в качестве ссылки на глобальный объект, контекст <code>eval</code>, цель события, или (если нет в этом явной необходимости) на вызываемые через методы <code>call()</code> и <code>apply()</code> функции.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);
</code></pre><h3 id="%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B"><span>Примитивные литералы</span></a></h3><h4 id="%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B"><span>Строковые литералы</span></a></h4><h5 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BE%D0%B4%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B5-%D0%BA%D0%B0%D0%B2%D1%8B%D1%87%D0%BA%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BE%D0%B4%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B5-%D0%BA%D0%B0%D0%B2%D1%8B%D1%87%D0%BA%D0%B8"><span>Используйте одинарные кавычки</span></a></h5><p>Обычные строковые литералы заключаются в одинарные кавычки (<code>'</code>), а не в двойные (<code>&quot;</code>).</p><blockquote><p>Совет: если строка содержит в себе символ одинарной кавычки, рассмотрите возможность использования шаблонной строки, чтобы избежать необходимости экранирования кавычек.</p></blockquote><h5 id="%D0%BD%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BF%D1%80%D0%BE%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-%D1%81%D1%82%D1%80%D0%BE%D0%BA" tabindex="-1"><a class="header-anchor" href="#%D0%BD%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BF%D1%80%D0%BE%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-%D1%81%D1%82%D1%80%D0%BE%D0%BA"><span>Не используйте продолжения строк</span></a></h5><p>Не используйте <em>продолжения строк</em> (то есть завершение строки внутри строкового литерала обратным слешем) ни в обычных, ни в шаблонных строковых литералах. Хотя ES5 позволяет это, это может привести к неожиданным ошибкам, если любой пробельный символ стоит после косой черты — к тому же, он является менее очевидным для читателей.</p><p>Запрещено:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> longString = <span class="hljs-string">&#x27;Это очень длинная строка, которая превышает лимит в \
    80 символов. К сожалению, она содержит длинные отрезки пустого пространства, так \
    как имеются отступы для поддержания форматирования.&#x27;</span>;
</code></pre><p>Вместо этого напишите:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> longString = <span class="hljs-string">&#x27;Это очень длинная строка, которая превышает лимит в &#x27;</span> +
    <span class="hljs-string">&#x27;80 символов. К сожалению, она содержит длинные отрезки пустого пространства, так &#x27;</span> +
    <span class="hljs-string">&#x27;как имеются отступы для поддержания форматирования.&#x27;</span>;

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SINGLE_STRING</span> =
    <span class="hljs-string">&#x27;http://тут.также/допустимо_использовать_единую_длинную_строку_если_разрыв_этой_строки_затруднит_ее_обнаружение_при_поиске&#x27;</span>;
</code></pre><h5 id="%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B"><span>Шаблонные литералы</span></a></h5><p>Используйте шаблонные литералы (разделенные <code>`</code>) вместо сложной конкатенации строк, особенно если речь идет о многострочных литералах. Шаблонные литералы могут занимать несколько строк.</p><p>Если шаблонный литерал охватывает несколько строк, ему не обязательно соблюдать окружающие отступы в блоке, хотя это и можно сделать, в случае если добавленные пробелы не имеют значения.</p><p>Пример:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">arithmetic</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`Это таблица с арифметическими операторами:
<span class="hljs-subst">${a}</span> + <span class="hljs-subst">${b}</span> = <span class="hljs-subst">${a + b}</span>
<span class="hljs-subst">${a}</span> - <span class="hljs-subst">${b}</span> = <span class="hljs-subst">${a - b}</span>
<span class="hljs-subst">${a}</span> * <span class="hljs-subst">${b}</span> = <span class="hljs-subst">${a * b}</span>
<span class="hljs-subst">${a}</span> / <span class="hljs-subst">${b}</span> = <span class="hljs-subst">${a / b}</span>`</span>;
}
</code></pre><h4 id="%D1%87%D0%B8%D1%81%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D1%87%D0%B8%D1%81%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B"><span>Числовые литералы</span></a></h4><p>Числа могут быть указаны в десятичной, шестнадцатеричной, восьмеричной или двоичной форме. Используйте соответствующие префиксы <code>0x</code>, <code>0o</code> и <code>0b</code> со строчными буквами для шестнадцатеричных, восьмеричных и двоичных форм соответственно. Никогда не включайте ведущий ноль, если за ним не следуют <code>x</code>, <code>o</code> или <code>b</code>.</p><h4 id="%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2"><span>Преобразование типов</span></a></h4><p>В TypeScript коде <em>возможно</em> использовать <code>String()</code> и <code>Boolean()</code> (примечание: без <code>new</code>!) функции, строковые шаблонные литералы или <code>!!</code> для преобразования типов.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> bool = <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">false</span>);
<span class="hljs-keyword">const</span> str = <span class="hljs-title class_">String</span>(aNumber);
<span class="hljs-keyword">const</span> bool2 = !!str;
<span class="hljs-keyword">const</span> str2 = <span class="hljs-string">`result: <span class="hljs-subst">${bool2}</span>`</span>;
</code></pre><p>Значения перечислений (<code>enum</code>) (включая объединения перечислений и других типов) <em>не должны</em> преобразовываться в булевы значения с помощью <code>Boolean()</code> или <code>!!</code>, а должны вместо этого сравниваться явным образом с помощью операторов сравнения.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">enum</span> <span class="hljs-title class_">SupportLevel</span> {
  <span class="hljs-variable constant_">NONE</span>,
  <span class="hljs-variable constant_">BASIC</span>,
  <span class="hljs-variable constant_">ADVANCED</span>,
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">level</span>: <span class="hljs-title class_">SupportLevel</span> = ...;
<span class="hljs-keyword">let</span> enabled = <span class="hljs-title class_">Boolean</span>(level);

<span class="hljs-keyword">const</span> <span class="hljs-attr">maybeLevel</span>: <span class="hljs-title class_">SupportLevel</span>|<span class="hljs-literal">undefined</span> = ...;
enabled = !!maybeLevel;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">enum</span> <span class="hljs-title class_">SupportLevel</span> {
  <span class="hljs-variable constant_">NONE</span>,
  <span class="hljs-variable constant_">BASIC</span>,
  <span class="hljs-variable constant_">ADVANCED</span>,
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">level</span>: <span class="hljs-title class_">SupportLevel</span> = ...;
<span class="hljs-keyword">let</span> enabled = level !== <span class="hljs-title class_">SupportLevel</span>.<span class="hljs-property">NONE</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">maybeLevel</span>: <span class="hljs-title class_">SupportLevel</span>|<span class="hljs-literal">undefined</span> = ...;
enabled = level !== <span class="hljs-literal">undefined</span> &amp;&amp; level !== <span class="hljs-title class_">SupportLevel</span>.<span class="hljs-property">NONE</span>;
</code></pre><blockquote><p>Почему?</p><p>Для большинства задач не имеет значения, числовое или строковое значение сопоставлено с именем перечисления во время выполнения программы, поскольку значения перечислений указываются в исходном коде по имени. Следовательно, инженеры привыкли не задумываться об этом, а потому нежелательны ситуации, когда это <em>действительно</em> важно, так как они будут приводить к неожиданностям. Так происходит и в случае преобразования перечислений в булевы значения; в частности, вероятно может быть неожиданным, что по умолчанию первое объявленное значение перечисления является ложным (потому что оно равно 0), в то время как остальные значения являются истинными. Пользователи, читающие код, в котором используется значение перечисления, могут даже не знать, является ли оно первым объявленным значением или нет.</p></blockquote><p>Не приветствуется для приведения к строке использовать конкатенацию строк, так как при проверке кода мы отслеживаем, чтобы операнды оператора «плюс» имели совпадающие типы.</p><p>Код <em>должен</em> использовать <code>Number()</code> для парсинга числовых значений и <em>должен</em> явно проверять его возврат на значения <code>NaN</code>, за исключением случаев, когда из контекста точно известно, что сбой парсинга невозможен.</p><p>Примечание: <code>Number('')</code>, <code>Number(' ')</code>, и <code>Number('\t')</code> могут вернуть <code>0</code> вместо <code>NaN</code>. <code>Number('Infinity')</code> и <code>Number('-Infinity')</code> могут вернуть <code>Infinity</code> и <code>-Infinity</code> соответственно. Кроме того, экспоненциальная запись, такая как <code>Number('1e+309')</code> и <code>Number('-1e+309')</code>, может привести к переполнению и преобразованию в <code>Infinity</code>. Подобные случаи могут потребовать особого обращения.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> aNumber = <span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;123&#x27;</span>);
<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isFinite</span>(aNumber)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(...);
</code></pre><p>В коде <em>не должен</em> использоваться унарный плюс (<code>+</code>) для преобразования строки в число. Парсинг чисел может привести к неудаче, иметь неожиданные исключительные ситуации и может быть признаком дурно пахнущего кода (парсинг чисел не на том уровне). Учитывая это, унарный плюс слишком легко пропустить при проверке кода.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> x = +y;
</code></pre><p>В коде также <em>не должны</em> использоваться <code>parseInt</code> или <code>parseFloat</code> для парсинга чисел, за исключением случаев парсинга в строках недесятичных числовых значений (см. ниже). Обе эти функции игнорируют конечные символы в строке, что может привести к возникновению ошибочного состояния (например, парсинг <code>12 гномов</code> как <code>12</code>).</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(someString, <span class="hljs-number">10</span>);  <span class="hljs-comment">// Подвержено ошибкам,</span>
<span class="hljs-keyword">const</span> f = <span class="hljs-built_in">parseFloat</span>(someString);    <span class="hljs-comment">// независимо от передачи основания системы счисления.</span>
</code></pre><p>Код, требующий выполнить парсинг числа с указанием системы счисления, перед вызовом <code>parseInt</code> <em>должен</em> проверить, что входные данные содержат только подходящие для этой системы счисления цифры;</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^[a-fA-F0-9]+$/</span>.<span class="hljs-title function_">test</span>(someString)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(...);
  <span class="hljs-comment">// Требуется для парсинга восьмеричного числа.</span>
<span class="hljs-comment">// tslint:disable-next-line:ban</span>
<span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(someString, <span class="hljs-number">16</span>);  <span class="hljs-comment">// Допустимо только для основания числа != 10</span>
</code></pre><p>Используйте <code>Number()</code>, а затем <code>Math.floor</code> или <code>Math.trunc</code> (там, где это возможно) для парсинга целых чисел:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">let</span> f = <span class="hljs-title class_">Number</span>(someString);
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(f)) <span class="hljs-title function_">handleError</span>();
f = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(f);
</code></pre><h5 id="%D0%BD%D0%B5%D1%8F%D0%B2%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BD%D0%B5%D1%8F%D0%B2%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2"><span>Неявное преобразование типов</span></a></h5><p>Не используйте явное булево преобразование в условиях, в которых уже имеется неявное булево преобразование. Это условия в операторах <code>if</code>, <code>for</code> и <code>while</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-title class_">MyInterface</span>|<span class="hljs-literal">null</span> = ...;
<span class="hljs-keyword">if</span> (!!foo) {...}
<span class="hljs-keyword">while</span> (!!foo) {...}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-title class_">MyInterface</span>|<span class="hljs-literal">null</span> = ...;
<span class="hljs-keyword">if</span> (foo) {...}
<span class="hljs-keyword">while</span> (foo) {...}
</code></pre><p><a href="#%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2">Как и в случае явных преобразований</a>, значения перечислений (включая объединения перечислений и других типов) не должны неявно приводиться к булевым значениям, а должны сравниваться явным образом с помощью операторов сравнения.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">enum</span> <span class="hljs-title class_">SupportLevel</span> {
  <span class="hljs-variable constant_">NONE</span>,
  <span class="hljs-variable constant_">BASIC</span>,
  <span class="hljs-variable constant_">ADVANCED</span>,
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">level</span>: <span class="hljs-title class_">SupportLevel</span> = ...;
<span class="hljs-keyword">if</span> (level) {...}

<span class="hljs-keyword">const</span> <span class="hljs-attr">maybeLevel</span>: <span class="hljs-title class_">SupportLevel</span>|<span class="hljs-literal">undefined</span> = ...;
<span class="hljs-keyword">if</span> (level) {...}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">enum</span> <span class="hljs-title class_">SupportLevel</span> {
  <span class="hljs-variable constant_">NONE</span>,
  <span class="hljs-variable constant_">BASIC</span>,
  <span class="hljs-variable constant_">ADVANCED</span>,
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">level</span>: <span class="hljs-title class_">SupportLevel</span> = ...;
<span class="hljs-keyword">if</span> (level !== <span class="hljs-title class_">SupportLevel</span>.<span class="hljs-property">NONE</span>) {...}

<span class="hljs-keyword">const</span> <span class="hljs-attr">maybeLevel</span>: <span class="hljs-title class_">SupportLevel</span>|<span class="hljs-literal">undefined</span> = ...;
<span class="hljs-keyword">if</span> (level !== <span class="hljs-literal">undefined</span> &amp;&amp; level !== <span class="hljs-title class_">SupportLevel</span>.<span class="hljs-property">NONE</span>) {...}
</code></pre><p>Другие типы значений могут быть либо неявно преобразованы в булевы значения, либо явно сравнены с помощью операторов сравнения:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Явное сравнение &gt; 0 это хорошо:</span>
<span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {...}
<span class="hljs-comment">// так же как и полагаться на неявное булево преобразование:</span>
<span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span>) {...}
</code></pre><h3 id="%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E%D1%89%D0%B8%D0%B5-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E%D1%89%D0%B8%D0%B5-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B"><span>Управляющие структуры</span></a></h3><h4 id="%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BC-%26-%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BC-%26-%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8"><span>Операторы управления потоком &amp; блоки</span></a></h4><p>Операторы управления потоком (<code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, <code>while</code> и т.д.) всегда используют блоки со скобками для размещения содержащегося в них кода, даже если тело состоит из одного выражения.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; x; i++) {
  <span class="hljs-title function_">doSomethingWith</span>(i);
}

<span class="hljs-keyword">if</span> (x) {
  <span class="hljs-title function_">doSomethingWithALongMethodNameThatForcesANewLine</span>(x);
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">if</span> (x)
  <span class="hljs-title function_">doSomethingWithALongMethodNameThatForcesANewLine</span>(x);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; x; i++) <span class="hljs-title function_">doSomethingWith</span>(i);
</code></pre><p><strong>Исключение:</strong> <em>возможно</em> не использовать блоки если оператор <code>if</code> умещается на одной строке.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">if</span> (x) x.<span class="hljs-title function_">doFoo</span>();
</code></pre><h5 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%B0%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0%D1%85-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%B0%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0%D1%85-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F"><span>Использование присваивания в операторах управления</span></a></h5><p>Предпочитайте избегать присваивания значений переменных внутри операторов управления. Присваивание легко спутать с проверкой на равенство внутри этих операторов.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">if</span> (x = <span class="hljs-title function_">someFunction</span>()) {
  <span class="hljs-comment">// Присваивание легко перепутать с проверкой на равенство</span>
  <span class="hljs-comment">// ...</span>
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

x = <span class="hljs-title function_">someFunction</span>();
<span class="hljs-keyword">if</span> (x) {
  <span class="hljs-comment">// ...</span>
}
</code></pre><p>В тех случаях, когда присваивание внутри оператора управления более предпочтительно, заключите это присваивание в дополнительные круглые скобки, чтобы указать, что оно сделано намеренно.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">while</span> ((x = <span class="hljs-title function_">someFunction</span>())) {
  <span class="hljs-comment">// Двойная скобка указывает на то, что присваивание сделано намеренно</span>
  <span class="hljs-comment">// ...</span>
}
</code></pre><h5 id="%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D0%BC" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D0%BC"><span>Итерация по массивам</span></a></h5><p>Для итерации по массивам предпочтительно использовать <code>for (... of someArr)</code>. Также приемлемо использовать <code>Array.prototype.forEach</code> или обычные циклы <code>for</code>:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> someArr) {
  <span class="hljs-comment">// x - ссылается на значение из someArr</span>
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; someArr.<span class="hljs-property">length</span>; i++) {
  <span class="hljs-comment">// Если необходим индекс, то используйте явный пересчет, а иначе используйте форму for/of.</span>
  <span class="hljs-keyword">const</span> x = someArr[i];
  <span class="hljs-comment">// ...</span>
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [i, x] <span class="hljs-keyword">of</span> someArr.<span class="hljs-title function_">entries</span>()) {
  <span class="hljs-comment">// Альтернативная версия предыдущего.</span>
}
</code></pre><p>Циклы <code>for</code>-<code>in</code> можно использовать только для объектов со словарными ключами. Не используйте <code>for (... in ...)</code> для итерации по массивам, т.к. это будет контринтуитивно давать индексы массива (в виде строк!), а не значения:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">in</span> someArray) {
  <span class="hljs-comment">// x - это индекс!</span>
}
</code></pre><p>В циклах <code>for</code>-<code>in</code> рекомендуется использовать <code>Object.prototype.hasOwnProperty</code> для исключения нежелательных свойств прототипа. По возможности, вместо <code>for</code>-<code>in</code> предпочтительно использовать <code>for</code>-<code>of</code> с <code>Object.keys</code>, <code>Object.values</code> или <code>Object.entries</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) {
  <span class="hljs-keyword">if</span> (!obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) <span class="hljs-keyword">continue</span>;
  <span class="hljs-title function_">doWork</span>(key, obj[key]);
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)) {
  <span class="hljs-title function_">doWork</span>(key, obj[key]);
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(obj)) {
  <span class="hljs-title function_">doWorkValOnly</span>(value);
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj)) {
  <span class="hljs-title function_">doWork</span>(key, value);
}
</code></pre><h4 id="%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B5-%D0%BA%D1%80%D1%83%D0%B3%D0%BB%D1%8B%D0%B5-%D1%81%D0%BA%D0%BE%D0%B1%D0%BA%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B5-%D0%BA%D1%80%D1%83%D0%B3%D0%BB%D1%8B%D0%B5-%D1%81%D0%BA%D0%BE%D0%B1%D0%BA%D0%B8"><span>Группирующие круглые скобки</span></a></h4><p>Необязательные группирующие круглые скобки опускаются только в том случае, если автор кода и рецензент согласны с тем, что нет никакой разумной вероятности того, что без них код будет неправильно истолкован или что они не сделали бы код более удобочитаемым. Неразумно предполагать, что каждый кто читает код знает наизусть всю таблицу приоритета операторов.</p><p>Не используйте лишние круглые скобки вокруг всего выражения, следующего за <code>delete</code>, <code>typeof</code>, <code>void</code>, <code>return</code>, <code>throw</code>, <code>case</code>, <code>in</code>, <code>of</code> или <code>yield</code>.</p><h4 id="%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B9" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B9"><span>Обработка исключений</span></a></h4><p>Исключения являются важной частью языка и их рекомендуется использовать везде, где случаются исключительные ситуации.</p><p>Пользовательские исключения являются отличным способом передачи из функций дополнительной информации об ошибках. Их рекомендуется определять и использовать везде, где недостаточно встроенного типа <code>Error</code>.</p><p>Предпочтение отдается выбрасыванию исключений, а не специальным подходам к обработке ошибок (таким как передача ссылки на тип контейнера ошибки или возврат объекта со свойством ошибки).</p><h5 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-new-%D0%BF%D1%80%D0%B8-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B8-%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%BE%D0%B2-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0-error" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-new-%D0%BF%D1%80%D0%B8-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B8-%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%BE%D0%B2-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0-error"><span>Использование <code>new</code> при создании экземпляров класса <code>Error</code></span></a></h5><p>Всегда используйте <code>new Error()</code> при создании исключений вместо простого вызова <code>Error()</code>. В обоих случаях создается новый экземпляр <code>Error</code>, но использование <code>new</code> более согласуется с тем, как создаются экземпляры других объектов.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Foo is not a valid bar.&#x27;</span>);
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Foo is not a valid bar.&#x27;</span>);
</code></pre><h5 id="%D0%BF%D1%80%D0%B8-%D0%B2%D1%8B%D0%B1%D1%80%D0%B0%D1%81%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0-error-%D0%B8-%D0%B5%D0%B3%D0%BE-%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%B8-%D0%B2%D1%8B%D0%B1%D1%80%D0%B0%D1%81%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0-error-%D0%B8-%D0%B5%D0%B3%D0%BE-%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2"><span>При выбрасывании исключений используйте только экземпляры класса <code>Error</code> и его подклассов</span></a></h5><p>JavaScript (и соответственно TypeScript) позволяет бросать исключения или отклонять промисы (<code>Promise</code>) с произвольными значениями. Однако если выброшенное значение не является экземпляром класса <code>Error</code>, то оно не получит записи трассировки стека, что затруднит отладку. Это правило распространяется и на отклоняемые значения <code>Promise</code>, поскольку <code>Promise.reject(obj)</code> эквивалентен <code>throw obj;</code> в асинхронных функциях.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// плохо: не позволяет получить трассировку стека.</span>
<span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;ой, ошибка!&#x27;</span>;
<span class="hljs-comment">// Для промисов</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;ой, ошибка!&#x27;</span>));
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>();
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;ой, ошибка!&#x27;</span>);
</code></pre><p>Вместо этого, при выбрасывании исключений используйте только экземпляры класса (или подкласса) <code>Error</code>:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// При выбрасывании исключений используйте только экземпляры класса Error</span>
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;ой, ошибка!&#x27;</span>);
<span class="hljs-comment">// ... или подтипы класса Error</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> {}
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyError</span>(<span class="hljs-string">&#x27;моя &quot;ой, ошибка!&quot;&#x27;</span>);
<span class="hljs-comment">// Для промисов</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>()); <span class="hljs-comment">// Отсутствие отклонения - это нормально</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;ой, ошибка!&#x27;</span>)));
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;ой, ошибка!&#x27;</span>));
</code></pre><h5 id="%D0%BF%D0%B5%D1%80%D0%B5%D1%85%D0%B2%D0%B0%D1%82-%D0%B8-%D0%BF%D1%80%D0%BE%D0%B1%D1%80%D0%BE%D1%81-%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B9" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%B5%D1%80%D0%B5%D1%85%D0%B2%D0%B0%D1%82-%D0%B8-%D0%BF%D1%80%D0%BE%D0%B1%D1%80%D0%BE%D1%81-%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B9"><span>Перехват и проброс исключений</span></a></h5><p>В коде, при перехвате исключений, <em>рекомендуется</em> рассматривать все бросаемые исключения как экземпляры класса <code>Error</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">assertIsError</span>(<span class="hljs-params">e: <span class="hljs-built_in">unknown</span></span>): asserts e is <span class="hljs-title class_">Error</span> {
  <span class="hljs-keyword">if</span> (!(e <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span>)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;&quot;e&quot; не принадлежит классу Error&#x27;</span>);
}

<span class="hljs-keyword">try</span> {
  <span class="hljs-title function_">doSomething</span>();
} <span class="hljs-keyword">catch</span> (<span class="hljs-attr">e</span>: <span class="hljs-built_in">unknown</span>) {
  <span class="hljs-comment">// Все выбрасываемые исключения должны быть подтипами класса Error. Не обрабатывайте другие</span>
  <span class="hljs-comment">// возможные значения, кроме случаев, когда вы точно знаете, что именно они будут выброшены.</span>
  <span class="hljs-title function_">assertIsError</span>(e);
  <span class="hljs-title function_">displayError</span>(e.<span class="hljs-property">message</span>);
  <span class="hljs-comment">// или проброс:</span>
  <span class="hljs-keyword">throw</span> e;
}
</code></pre><p>Обработчики исключений <em>не должны</em> защитно обрабатывать типы, отличные от <code>Error</code>, за исключением случаев, когда достоверно известно, что вызываемый API выбрасывает исключения, не соответствующие типу <code>Error</code>, в нарушение вышеуказанного правила. В таком случае рекомендуется добавить комментарий, в котором специально указывается источник возникновения исключения, не соответствующего типу <code>Error</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">try</span> {
  <span class="hljs-title function_">badApiThrowingStrings</span>();
} <span class="hljs-keyword">catch</span> (<span class="hljs-attr">e</span>: <span class="hljs-built_in">unknown</span>) {
  <span class="hljs-comment">// Примечание: это плохое API при выбрасывании исключения передает строку, вместо экземпляра класса Error</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> e === <span class="hljs-string">&#x27;string&#x27;</span>) { ... }
}
</code></pre><blockquote><p>Почему?</p><p>Избегайте <a href="https://en.wikipedia.org/wiki/Defensive_programming#Offensive_programming">чрезмерно защитного программирования</a>. Повторение одних и тех же защитных средств от проблемы, которой не будет существовать в большей части кода, приводит к появлению шаблонного кода, который не является полезным.</p></blockquote><h5 id="%D0%BF%D1%83%D1%81%D1%82%D0%BE%D0%B9-%D0%B1%D0%BB%D0%BE%D0%BA-catch" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%83%D1%81%D1%82%D0%BE%D0%B9-%D0%B1%D0%BB%D0%BE%D0%BA-catch"><span>Пустой блок catch</span></a></h5><p>В редчайших случаях бывает корректным ничего не делать в ответ на пойманное исключение. Когда действительно уместно не выполнять никаких действий в блоке <code>catch</code>, причины, по которым это оправдано, объясняются в комментарии.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">handleNumericResponse</span>(response);
} <span class="hljs-keyword">catch</span> (<span class="hljs-attr">e</span>: <span class="hljs-built_in">unknown</span>) {
  <span class="hljs-comment">// Ответ не является числовым. Продолжаем обрабатывать как текст.</span>
}
<span class="hljs-keyword">return</span> <span class="hljs-title function_">handleTextResponse</span>(response);
</code></pre><p>Запрещено:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">try</span> {
  <span class="hljs-title function_">shouldFail</span>();
  <span class="hljs-title function_">fail</span>(<span class="hljs-string">&#x27;ожидалась ошибка&#x27;</span>);
} <span class="hljs-keyword">catch</span> (<span class="hljs-attr">expected</span>: <span class="hljs-built_in">unknown</span>) {
}
</code></pre><h4 id="%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-switch" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-switch"><span>Оператор <code>switch</code></span></a></h4><p>Каждый <code>switch</code> оператор <em>должен</em> включать в себя блок по умолчанию (<code>default</code>), даже если там не содержится кода. При этом блок <code>default</code> должен размещаться самым последним.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">switch</span> (x) {
  <span class="hljs-keyword">case</span> <span class="hljs-attr">Y</span>:
    <span class="hljs-title function_">doSomethingElse</span>();
    <span class="hljs-keyword">break</span>;
  <span class="hljs-attr">default</span>:
    <span class="hljs-comment">// ничего не делать.</span>
}
</code></pre><p>В блоке <code>switch</code> каждая группа операторов завершается либо оператором <code>break</code>, либо оператором <code>return</code>, либо выбросом исключения. Непустые группы операторов (<code>case ...</code>) <em>не должны</em> проваливаться (обеспечивается настройками компилятора<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>):</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">switch</span> (x) {
  <span class="hljs-keyword">case</span> <span class="hljs-attr">X</span>:
    <span class="hljs-title function_">doSomething</span>();
    <span class="hljs-comment">// дальнейший пропуск - не разрешен!</span>
  <span class="hljs-keyword">case</span> <span class="hljs-attr">Y</span>:
    <span class="hljs-comment">// ...</span>
}
</code></pre><p>Допускается пропуск пустых групп операторов:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">switch</span> (x) {
  <span class="hljs-keyword">case</span> <span class="hljs-attr">X</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-attr">Y</span>:
    <span class="hljs-title function_">doSomething</span>();
    <span class="hljs-keyword">break</span>;
  <span class="hljs-attr">default</span>: <span class="hljs-comment">// ничего не делать.</span>
}
</code></pre><h4 id="%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0-%D1%80%D0%B0%D0%B2%D0%B5%D0%BD%D1%81%D1%82%D0%B2%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0-%D1%80%D0%B0%D0%B2%D0%B5%D0%BD%D1%81%D1%82%D0%B2%D0%B0"><span>Проверка равенства</span></a></h4><p>Всегда используйте тройное равенство (<code>===</code>) и неравенство (<code>!==</code>). Операторы двойного равенства вызывают склонные к ошибкам приведения типов, которые трудны для понимания и работают медленнее в реализации виртуальных машин JavaScript. Смотрите также <a href="https://dorey.github.io/JavaScript-Equality-Table/">JavaScript таблицу равенства</a>.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">if</span> (foo == <span class="hljs-string">&#x27;bar&#x27;</span> || baz != bam) {
  <span class="hljs-comment">// Трудное для понимания поведение из-за преобразования типов.</span>
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">if</span> (foo === <span class="hljs-string">&#x27;bar&#x27;</span> || baz !== bam) {
  <span class="hljs-comment">// Здесь все хорошо и понятно.</span>
}
</code></pre><p><strong>Исключение</strong>: При сравнении с значением <code>null</code> <em>возможно</em> использовать операторы <code>==</code> и <code>!=</code> для общего охвата <code>null</code> и <code>undefined</code> значений.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">if</span> (foo == <span class="hljs-literal">null</span>) {
  <span class="hljs-comment">// Будет срабатывать, когда foo равен null или undefined. </span>
}
</code></pre><h4 id="%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%B0-(type-assertions)-%D0%B8-%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BD%D0%B5%D0%BD%D1%83%D0%BB%D0%B5%D0%B2%D0%BE%D0%B3%D0%BE-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-(non-nullability-assertions)" tabindex="-1"><a class="header-anchor" href="#%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%B0-(type-assertions)-%D0%B8-%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BD%D0%B5%D0%BD%D1%83%D0%BB%D0%B5%D0%B2%D0%BE%D0%B3%D0%BE-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-(non-nullability-assertions)"><span>Утверждения типа (Type Assertions) и утверждения ненулевого значения (Non-nullability Assertions)</span></a></h4><p>Утверждения типа (<code>x as SomeType</code>) и утверждения ненулевого значения (<code>y!</code>) не безопасны. Оба только заглушают компилятор TypeScript, но не вставляют никаких проверок во время выполнения, чтобы соответствовать этим утверждениям, поэтому они могут привести к сбою вашей программы во время выполнения.</p><p>По этой причине, вам <em>не рекомендуется</em> использовать утверждения типа и утверждения ненулевого значения без явной или объяснимой причины.</p><p>Вместо этого:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

(x <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span>).<span class="hljs-title function_">foo</span>();

y!.<span class="hljs-title function_">bar</span>();
</code></pre><p>Когда вы захотите произвести утверждение типа или утверждение ненулевого значения, то лучшим решением будет написать проверку, которая будет работать во время выполнения.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// предположим, что Foo - это класс.</span>
<span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Foo</span>) {
  x.<span class="hljs-title function_">foo</span>();
}

<span class="hljs-keyword">if</span> (y) {
  y.<span class="hljs-title function_">bar</span>();
}
</code></pre><p>Иногда из-за некоторых внутренних особенностей вашего кода вы можете быть уверены, что форма утверждения безопасна. В таких ситуациях <em>рекомендуется</em> добавить пояснение, объясняющее, почему вы согласны с небезопасным поведением:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// x это Foo, потому что ...</span>
(x <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span>).<span class="hljs-title function_">foo</span>();

<span class="hljs-comment">// y не может быть null, потому что ...</span>
y!.<span class="hljs-title function_">bar</span>();
</code></pre><p><em>Возможно</em> обойтись без комментариев, если очевидны причины, лежащие в основе применения утверждения типа или утверждения ненулевого значения. Например, сгенерированный код-прототип всегда допускает значение <code>null</code>, но, возможно, в контексте кода хорошо известно, что определенные поля всегда предоставляются серверной частью. В таком случае, принимайте решение руководствуясь своим профессиональным видением.</p><h5 id="%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81-%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81-%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%B0"><span>Синтаксис утверждения типа</span></a></h5><p>Утверждения типа <em>должны</em> использовать синтаксис <code>as</code> (в отличие от синтаксиса угловых скобок). Это позволяет заключить утверждение в круглые скобки при обращении к элементу.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> x = (&lt;<span class="hljs-title class_">Foo</span>&gt;z).<span class="hljs-property">length</span>;
<span class="hljs-keyword">const</span> y = &lt;<span class="hljs-title class_">Foo</span>&gt;z.<span class="hljs-property">length</span>;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// z должен быть Foo, потому что ...</span>
<span class="hljs-keyword">const</span> x = (z <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span>).<span class="hljs-property">length</span>;
</code></pre><h5 id="%D0%B4%D0%B2%D0%BE%D0%B9%D0%BD%D1%8B%D0%B5-%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%B4%D0%B2%D0%BE%D0%B9%D0%BD%D1%8B%D0%B5-%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%B0"><span>Двойные утверждения типа</span></a></h5><p>Из руководства TypeScript следует, что в TypeScript допускаются только утверждения типа, которые преобразуют тип в его <em>более специфичную</em> или <em>менее специфичную</em> версию. Добавление утверждения типа <code>(x as Foo)</code>, которое не соответствует этому критерию, приведет к ошибке: <em>&quot;Conversion of type 'X' to type 'Y' may be a mistake because neither type sufficiently overlaps with the other.&quot;</em> (что в переводе: <em>&quot;Преобразование типа 'X' в тип 'Y' может быть ошибкой, поскольку ни один из типов в достаточной степени не пересекается с другим.&quot;</em>).</p><p>Если вы уверены, что утверждение типа безопасно, вы можете выполнить двойное утверждение типа. Это предполагает приведение через <code>unknown</code>, поскольку он является наименее специфичным, чем все остальные типы.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Здесь &quot;x&quot; это &quot;Foo&quot;, потому что ...</span>
(x <span class="hljs-keyword">as</span> <span class="hljs-built_in">unknown</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span>).<span class="hljs-title function_">fooMethod</span>();
</code></pre><p>Соответственно, используйте <code>unknown</code> (вместо <code>any</code> или <code>{}</code>) как промежуточный тип.</p><h5 id="%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-%26-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-%26-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B"><span>Утверждение типа &amp; объектные литералы</span></a></h5><p>Используйте аннотации типа (<code>: Foo</code>) вместо утверждения типа (<code>as Foo</code>) для указания типа объектного литерала. Это позволяет обнаружить ошибки рефакторинга, когда поля интерфейса меняются со временем.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-attr">bar</span>: <span class="hljs-built_in">number</span>;
  baz?: <span class="hljs-built_in">string</span>;  <span class="hljs-comment">// был &quot;bam&quot;, но позднее был переименован в &quot;baz&quot;.</span>
}

<span class="hljs-keyword">const</span> foo = {
  <span class="hljs-attr">bar</span>: <span class="hljs-number">123</span>,
  <span class="hljs-attr">bam</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,  <span class="hljs-comment">// нет ошибки!</span>
} <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">bar</span>: <span class="hljs-number">123</span>,
    <span class="hljs-attr">bam</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,  <span class="hljs-comment">// нет ошибки!</span>
  } <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span>;
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-attr">bar</span>: <span class="hljs-built_in">number</span>;
  baz?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-title class_">Foo</span> = {
  <span class="hljs-attr">bar</span>: <span class="hljs-number">123</span>,
  <span class="hljs-attr">bam</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,  <span class="hljs-comment">// жалуется на то, что &quot;bam&quot; не был объявлен в Foo.</span>
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">bar</span>: <span class="hljs-number">123</span>,
    <span class="hljs-attr">bam</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,  <span class="hljs-comment">// жалуется на то, что &quot;bam&quot; не был объявлен в Foo.</span>
  };
}
</code></pre><h4 id="%D1%81%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D1%8F%D0%B9%D1%82%D0%B5-%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8-try-%D1%81%D1%84%D0%BE%D0%BA%D1%83%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D1%8F%D0%B9%D1%82%D0%B5-%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8-try-%D1%81%D1%84%D0%BE%D0%BA%D1%83%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC%D0%B8"><span>Сохраняйте блоки <code>try</code> сфокусированными</span></a></h4><p>Ограничьте количество кода внутри блока <code>try</code>, если это можно сделать без ущерба для читабельности.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">methodThatMayThrow</span>();
  <span class="hljs-title function_">use</span>(result);
} <span class="hljs-keyword">catch</span> (<span class="hljs-attr">error</span>: <span class="hljs-built_in">unknown</span>) {
  <span class="hljs-comment">// ...</span>
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">let</span> result;
<span class="hljs-keyword">try</span> {
  result = <span class="hljs-title function_">methodThatMayThrow</span>();
} <span class="hljs-keyword">catch</span> (<span class="hljs-attr">error</span>: <span class="hljs-built_in">unknown</span>) {
  <span class="hljs-comment">// ...</span>
}
<span class="hljs-title function_">use</span>(result);
</code></pre><p>Вынос не вызывающих исключений строк кода из блока try/catch помогает читающему код понять, какой метод выбрасывает исключения. Некоторые встраиваемые вызовы, которые не выбрасывают исключений, могут оставаться внутри блока, поскольку они могут не стоить дополнительных усложнений кода, связанных с добавлением временной переменной.</p><p><strong>Исключение</strong>: Могут возникнуть проблемы с производительностью, если блоки <code>try</code> находятся внутри цикла. Расширение блоков <code>try</code> для охвата всего цикла — это нормально.</p><h3 id="%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B"><span>Декораторы</span></a></h3><p>Декораторы обозначаются с помощью префикса <code>@</code>, например <code>@MyDecorator</code>.</p><p>Не определяйте новых декораторов. Используйте только те декораторы, которые определены фреймворками:</p><ul><li>Angular (например: <code>@Component</code>, <code>@NgModule</code> и т.д.);</li><li>Polymer (например: <code>@property</code>).</li></ul><blockquote><p>Почему?</p><p>В основном мы предпочитаем избегать декораторов, поскольку они были экспериментальной функцией, которая с тех пор отклонилась от предложения TC39 и имеет известные ошибки, которые вряд ли будут исправлены <sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>.</p></blockquote><p>При использовании декораторов, декоратор <em>должен</em> непосредственно предшествовать элементу, к которому он применяется, без пустых строк между ними:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/** Комментарии JSDoc идут перед декораторами */</span>
<span class="hljs-meta">@Component</span>({...})  <span class="hljs-comment">// Примечание: после декоратора не должно быть пустой строки. </span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComp</span> {
  <span class="hljs-meta">@Input</span>() <span class="hljs-attr">myField</span>: <span class="hljs-built_in">string</span>;  <span class="hljs-comment">// Декораторы полей могут находиться на одной линии... </span>

  <span class="hljs-meta">@Input</span>()
  <span class="hljs-attr">myOtherField</span>: <span class="hljs-built_in">string</span>;  <span class="hljs-comment">// ...  или переноситься.</span>
}
</code></pre><h3 id="%D0%B7%D0%B0%D0%BF%D1%80%D0%B5%D1%89%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%B7%D0%B0%D0%BF%D1%80%D0%B5%D1%89%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8"><span>Запрещенные возможности</span></a></h3><h4 id="%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%BE%D0%B1%D0%B5%D1%80%D1%82%D0%BA%D0%B8-%D0%B4%D0%BB%D1%8F-%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%BE%D0%B1%D0%B5%D1%80%D1%82%D0%BA%D0%B8-%D0%B4%D0%BB%D1%8F-%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2"><span>Классы-обертки для примитивных типов</span></a></h4><p>Код TypeScript <em>не должен</em> создавать экземпляры классов-оберток для примитивных типов <code>String</code>, <code>Boolean</code> и <code>Number</code>. Классы-обертки имеют неожиданное поведение, такое как <code>new Boolean(false)</code> равное <code>true</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);
<span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">false</span>);
<span class="hljs-keyword">const</span> n = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">5</span>);
</code></pre><p>Обертки могут быть вызваны как функции для приведения типа (что предпочтительнее, чем использование <code>+</code> или конкатенации пустой строки) или создания символов (<code>Symbol</code>). См. раздел <a href="#%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2">«Преобразование типов»</a> для дополнительной информации.</p><h4 id="%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F-%D0%B2%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B0-%D1%82%D0%BE%D1%87%D0%BA%D0%B8-%D1%81-%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%BE%D0%B9" tabindex="-1"><a class="header-anchor" href="#%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F-%D0%B2%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B0-%D1%82%D0%BE%D1%87%D0%BA%D0%B8-%D1%81-%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%BE%D0%B9"><span>Автоматическая вставка точки с запятой</span></a></h4><p>Не следует полагаться на автоматическую вставку точки с запятой (ASI<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>). Явно обозначайте завершение всех операторов с помощью точки с запятой. Это предотвращает ошибки, возникающие из-за неправильной вставки точки с запятой, а также обеспечивает совместимость с инструментами, которые имеют ограниченную поддержку ASI (например, clang-format).</p><h4 id="%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D0%BD%D1%8B%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D0%BD%D1%8B%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F"><span>Константные перечисления</span></a></h4><p>В коде <em>не должны</em> использоваться <code>const enum</code>, вместо этого используйте обычный <code>enum</code>.</p><blockquote><p>Почему?</p><p>В TypeScript перечисления и так не могут быть изменены, а <code>const enum</code> — это отдельная особенность языка, связанная с оптимизацией, которая делает перечисление невидимым для пользователей JavaScript модуля.</p></blockquote><h4 id="%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-debugger" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-debugger"><span>Оператор <code>debugger</code></span></a></h4><p>Вызовы отладчика через оператор <code>debugger</code> <em>не должны</em> включаться в рабочий код.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">debugMe</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">debugger</span>;
}
</code></pre><h4 id="%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-with" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-with"><span>Оператор <code>with</code></span></a></h4><p>Не используйте ключевое слово <code>with</code>. Это делает ваш код более трудным для понимания и к тому же он <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with">запрещен в строгом режиме (<code>strict mode</code>) начиная с ES5</a>.</p><h4 id="%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%B4%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%B4%D0%B0"><span>Динамическое выполнение кода</span></a></h4><p>Не используйте <code>eval</code> или конструктор <code>Function(...string)</code> (за исключением загрузчиков кода). Эти функции потенциально опасны и просто не работают в окружениях, использующих строгие политики <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/CSP">CSP (Content Security Policy)</a>.</p><h4 id="%D0%BD%D0%B5%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B5-%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%BD%D0%B5%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B5-%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8"><span>Нестандартные возможности</span></a></h4><p>Не используйте нестандартные возможности ECMAScript или Web-платформы.</p><p>Сюда входят:</p><ul><li>Старый функционал, который был помечен как устаревший или полностью удален из ECMAScript / Web-платформы (см. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Deprecated_and_obsolete_features">MDN</a>)</li><li>Новый функционал ECMAScript, которые еще не стандартизирован<ul><li>Избегайте использования функционала, который в текущем TC39 находится в стадии черновика или в процессе <a href="https://tc39.es/process-document/">подготовки предложения</a>.</li><li>Используйте только функционал ECMAScript, определенный в текущей спецификации ECMA-262</li></ul></li><li>Предлагаемые, но еще не до конца проработанные веб-стандарты:<ul><li>Предложения WHATWG, которые еще не завершили процесс <a href="https://whatwg.org/faq#adding-new-features">подготовки предложения</a></li></ul></li><li>Нестандартные языковые «расширения» (например, те, что предоставляются некоторыми сторонними транспиляторами)</li></ul><p>Проекты, ориентированные на конкретные среды исполнения JavaScript, такие как только последние версии Chrome, расширения Chrome, Node.JS, Electron, очевидно могут использовать эти API. Будьте осторожны при рассмотрении к использованию тех API, которые являются проприетарными и реализованы только в определенных браузерах; изучите, есть ли какая-то общая библиотека, которая может абстрагировать такой API для вас.</p><h4 id="%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F-%D0%B2%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F-%D0%B2%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2"><span>Модификация встроенных объектов</span></a></h4><p>Никогда не модифицируйте встроенные типы, добавляя методы в их конструкторы или прототипы. Избегайте зависимости от библиотек, которые это делают.</p><p>Не добавляйте символы (<code>symbol</code>) в глобальный объект, если это не является абсолютно необходимым (например, по требованию стороннего API).</p><h2 id="%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"><span>Именование</span></a></h2><h3 id="%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D1%8B"><span>Идентификаторы</span></a></h3><p>Идентификаторы <em>должны</em> использовать только ASCII символы, цифры, символы подчеркивания (для констант и названий методов структурных тестов) и (редко) знак <code>$</code>.</p><h4 id="%D1%81%D1%82%D0%B8%D0%BB%D1%8C-%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" tabindex="-1"><a class="header-anchor" href="#%D1%81%D1%82%D0%B8%D0%BB%D1%8C-%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F"><span>Стиль именования</span></a></h4><p>TypeScript отражает информацию в типах, поэтому имена <em>не рекомендуется</em> дополнять информацией, которая включена в тип (см. также <a href="https://testing.googleblog.com/2017/10/code-health-identifiernamingpostforworl.html">Блог о тестировании (Testing Blog)</a> для получения дополнительной информации о том, что не следует включать).</p><p>Несколько конкретных примеров для этого правила:</p><ul><li>Не используйте начальные или завершащие символы подчеркивания для приватных свойств или методов.</li><li>Не используйте префикс <code>opt_</code> для необязательных параметров.<ul><li>Для аксессоров, см. ниже <a href="#%D0%B3%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B-%D0%B8-%D1%81%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B-%D0%B0%D0%BA%D1%81%D0%B5%D1%81%D1%81%D0%BE%D1%80%D1%8B">правила использования аксессоров</a>.</li></ul></li><li>Не стоит специально помечать интерфейсы (<s><code>IMyInterface</code></s> или <s><code>MyFooInterface</code></s>), если только они не идиоматичны в своей среде. Когда вы вводите интерфейс для класса, дайте ему имя, которое выражает причину существования интерфейса (например, <code>class TodoItem</code> и <code>interface TodoItemStorage</code> если интерфейс выражает формат, используемый для хранения/сериализации в JSON).</li><li>Добавление к наблюдаемым элементам (<code>Observable</code>) суффикса <code>$</code> является распространенным внешним соглашением<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup> и может помочь устранить путаницу между наблюдаемыми и конкретными значениями. Решение о том, является ли это полезным соглашением, остается на усмотрение отдельных команд, но <em>рекомендуется</em>, чтобы оно было согласованным в рамках проектов.</li></ul><h4 id="%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F"><span>Описательные названия</span></a></h4><p>Названия <em>должны</em> быть описательными и ясными для новых читателей. Не используйте аббревиатуры, которые могут быть незнакомыми или двусмысленными для читателей за пределами вашего проекта и не сокращайте, удаляя в словах буквы.</p><p><strong>Исключение</strong>: Для переменных, область действия которых составляет не более 10 строк, включая аргументы, которые <em>не</em> являются частью экспортируемого API, <em>возможно</em> использование коротких (например, однобуквенных) имен переменных.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Хорошие идентификаторы:</span>
errorCount          <span class="hljs-comment">// Без сокращений.</span>
dnsConnectionIndex  <span class="hljs-comment">// Большинство людей знают, что означает &quot;DNS&quot;.</span>
referrerUrl         <span class="hljs-comment">// То же самое касается &quot;URL&quot;.</span>
customerId          <span class="hljs-comment">// &quot;Id&quot; распространено повсеместно и вряд ли будет понято неправильно.</span>
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Запрещенные идентификаторы:</span>
n                   <span class="hljs-comment">// Бессмысленный.</span>
nErr                <span class="hljs-comment">// Неясная аббревиатура.</span>
nCompConns          <span class="hljs-comment">// Неясная аббревиатура.</span>
wgcConnections      <span class="hljs-comment">// Только ваша команда разработчиков знает, что это означает.</span>
pcReader            <span class="hljs-comment">// Многие вещи можно назвать как &quot;pc&quot;.</span>
cstmrId             <span class="hljs-comment">// Удалены внутренние символы.</span>
kSecondsPerDay      <span class="hljs-comment">// Не используйте Венгерскую нотацию.</span>
customerID          <span class="hljs-comment">// Регистр букв в слове «ID» не в camelcase стиле</span>
</code></pre><h4 id="%D0%B2%D0%B5%D1%80%D0%B1%D0%BB%D1%8E%D0%B6%D0%B8%D0%B9-%D1%81%D1%82%D0%B8%D0%BB%D1%8C-(camelcase)" tabindex="-1"><a class="header-anchor" href="#%D0%B2%D0%B5%D1%80%D0%B1%D0%BB%D1%8E%D0%B6%D0%B8%D0%B9-%D1%81%D1%82%D0%B8%D0%BB%D1%8C-(camelcase)"><span>Верблюжий стиль (camelcase)</span></a></h4><p>Рассматривайте используемые в именах аббревиатуры типа акронимов как целые слова, т.е. используйте <code>loadHttpUrl</code>, а не <s><code>loadHTTPURL</code></s>, если только это не обусловлено названием конкретной платформы (например <code>XMLHttpRequest</code>).</p><h4 id="%D0%B7%D0%BD%D0%B0%D0%BA-%D0%B4%D0%BE%D0%BB%D0%BB%D0%B0%D1%80%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%B7%D0%BD%D0%B0%D0%BA-%D0%B4%D0%BE%D0%BB%D0%BB%D0%B0%D1%80%D0%B0"><span>Знак доллара</span></a></h4><p>В идентификаторах, как правило, <em>не рекомендуется</em> использовать символ <code>$</code>, за исключением случаев, когда это требуется в соответствии с соглашениями об именовании для сторонних фреймворков. Подробнее об использовании суффикса <code>$</code> для наблюдаемых (<code>Observable</code>) значений <a href="#%D1%81%D1%82%D0%B8%D0%BB%D1%8C-%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">см. ниже</a>.</p><h3 id="%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-%D0%B2-%D1%81%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B8%D0%B8-%D1%81-%D1%82%D0%B8%D0%BF%D0%BE%D0%BC-%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-%D0%B2-%D1%81%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B8%D0%B8-%D1%81-%D1%82%D0%B8%D0%BF%D0%BE%D0%BC-%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D0%B0"><span>Правила в соответствии с типом идентификатора</span></a></h3><p>Большинство имен идентификаторов должны соответствовать регистру, указанному в таблице ниже, в зависимости от типа идентификатора.</p><table><thead><tr><th>Стиль</th><th>Категория</th></tr></thead><tbody><tr><td><code>UpperCamelCase</code></td><td>класс / интерфейс / тип / перечисление / декоратор / параметр типа / функциональные компоненты в TSX / параметр типа JSX.Element</td></tr><tr><td><code>lowerCamelCase</code></td><td>переменная / параметр / функция / метод / свойство / псевдонимы модулей</td></tr><tr><td><code>CONSTANT_CASE</code></td><td>глобальные константы, включая имена элементов перечислений (<code>enum</code>). См. ниже раздел <a href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D1%8B">Константы</a></td></tr><tr><td><code>#ident</code></td><td>подобные приватные идентификаторы не применяются</td></tr></tbody></table><h4 id="%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B-%D1%82%D0%B8%D0%BF%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B-%D1%82%D0%B8%D0%BF%D0%B0"><span>Параметры типа</span></a></h4><p>Для обозначения параметров типа, как например в <code>Array&lt;T&gt;</code>, <em>возможно</em> использовать один символ верхнего регистра (<code>T</code>) или <code>UpperCamelCase</code>.</p><h4 id="%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%82%D0%B5%D1%81%D1%82%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%82%D0%B5%D1%81%D1%82%D0%BE%D0%B2"><span>Названия тестов</span></a></h4><p>Название тестовых методов в xUnit-подобных тестовых фреймворках <em>возможно</em> представлять с разделителями <code>_</code>, например <code>testX_whenY_doesZ()</code>.</p><h4 id="_-%D0%BF%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%2F%D1%81%D1%83%D1%84%D1%84%D0%B8%D0%BA%D1%81" tabindex="-1"><a class="header-anchor" href="#_-%D0%BF%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%2F%D1%81%D1%83%D1%84%D1%84%D0%B8%D0%BA%D1%81"><span><code>_</code> префикс/суффикс</span></a></h4><p>Идентификаторы не должны использовать <code>_</code> в качестве префикса или суффикса.<br>Это также означает что символ <code>_</code> сам по себе <em>не должен</em> быть использован в качестве идентификатора (например, чтобы указать, что параметр не используется).</p><blockquote><p>Совет: Если вам нужны только некоторые элементы из массива (или TypeScript кортежа), вы можете вставить дополнительные запятые в выражение деструктуризации, чтобы игнорировать промежуточные элементы:</p><pre><code class="language-ts">  <span class="hljs-comment">// ✅ ХОРОШО ↴</span>

  <span class="hljs-keyword">const</span> [a, , b] = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>];  <span class="hljs-comment">// a &lt;- 1, b &lt;- 10</span>
</code></pre></blockquote><h4 id="%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D1%8B-1" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D1%8B-1"><span>Импорты</span></a></h4><p>Импорты пространств имен модулей пишутся в стиле <code>lowerCamelCase</code> в то время как файлы именуются в стиле <code>snake_case</code>, что означает, что корректные импорты не будут совпадать по стилю написания с именами файлов. Например:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fooBar <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo_bar&#x27;</span>;
</code></pre><p>Некоторые библиотеки могут широко использовать префиксы для импорта пространств имен, которые противоречат этой схеме именования, но их обширное использование в решениях с открытым исходным кодом делает этот нарушающий стиль более понятным. Единственными библиотеками, которые в настоящее время подпадают под это исключение, являются:</p><ul><li><a href="https://jquery.com">jquery</a>, использует <code>$</code> как префикс;</li><li><a href="https://threejs.org">threejs</a>, использует <code>THREE</code> как префикс.</li></ul><h4 id="%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D1%8B"><span>Константы</span></a></h4><p><strong>Иммутабельность</strong>: Стиль <code>CONSTANT_CASE</code> указывает на то, что значение <em>предназначено</em> быть неизменным и при этом такой стиль также <em>возможно</em> использовать для значений, которые могут быть изменены технически (т.е. значений, которые не являются глубоко замороженными), чтобы явно указать пользователям на то, что эти значения нельзя изменять.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">UNIT_SUFFIXES</span> = {
  <span class="hljs-string">&#x27;milliseconds&#x27;</span>: <span class="hljs-string">&#x27;ms&#x27;</span>,
  <span class="hljs-string">&#x27;seconds&#x27;</span>: <span class="hljs-string">&#x27;s&#x27;</span>,
};
<span class="hljs-comment">// Несмотря на то, что в соответствии с правилами JavaScript UNIT_SUFFIXES является изменяемым,</span>
<span class="hljs-comment">// верхний регистр символов обозначает для пользователей, что они не должны изменять значения.</span>
</code></pre><p>Константой также может быть статическое свойство класса, которое предназначенно только для чтения (<code>static readonly</code>).</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-variable constant_">MY_SPECIAL_NUMBER</span> = <span class="hljs-number">5</span>;

  <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-title class_">Foo</span>.<span class="hljs-property">MY_SPECIAL_NUMBER</span>;
  }
}
</code></pre><p><strong>Глобальность</strong>: Только для элементов, объявленных на уровне модуля, статических полей классов уровня модуля и значений перечислений уровня модуля <em>возможно</em> использовать <code>CONST_CASE</code> стиль. Если во время работы программы значение создается более одного раза (например, локальная переменная, объявленная в функции или статическое поле в классе, вложенном в функцию), тогда <em>должен</em> использоваться <code>lowerCamelCase</code> стиль.</p><p>Если значение представляет собой стрелочную функцию которая реализует интерфейс, тогда это <em>возможно</em> объявлять в <code>lowerCamelCase</code> стиле.</p><h4 id="%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC%D1%8B"><span>Псевдонимы</span></a></h4><p>При создании локального псевдонима существующего элемента, используйте формат уже существующего его обозначения. Локальный псевдоним <em>должен</em> совпадать с существующим именем и форматом источника. Для переменных при создании локальных псевдонимов используйте <code>const</code>, а для полей класса - атрибут <code>readonly</code>.</p><blockquote><p>Примечание: Если вы создаете псевдоним только ради использования его для шаблона в выбранном вами фреймворке, не забудьте также назначить соответствующие <a href="#%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D0%BC%D1%8B%D0%B5-%D0%B7%D0%B0-%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B0%D0%BC%D0%B8-%D0%BB%D0%B5%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B9-%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0">модификаторы доступа</a>.</p></blockquote><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> {<span class="hljs-title class_">BrewStateEnum</span>} = <span class="hljs-title class_">SomeType</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CAPACITY</span> = <span class="hljs-number">5</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teapot</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-title class_">BrewStateEnum</span> = <span class="hljs-title class_">BrewStateEnum</span>;
  <span class="hljs-keyword">readonly</span> <span class="hljs-variable constant_">CAPACITY</span> = <span class="hljs-variable constant_">CAPACITY</span>;
}
</code></pre><h2 id="%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2"><span>Система типов</span></a></h2><h3 id="%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D1%82%D0%B8%D0%BF%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D1%82%D0%B8%D0%BF%D0%B0"><span>Вывод типа</span></a></h3><p>В коде <em>возможно</em> полагаться на вывод типа, реализуемый компилятором TypeScript для всех типов выражений (переменных, полей класса, возвращаемых типов и т.д.).</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> x = <span class="hljs-number">15</span>;  <span class="hljs-comment">// Тип выведен.</span>
</code></pre><p>Не указывайте типы для тривиально выводимых типов: переменных или параметров, инициализированных строковыми (<code>string</code>), числовыми (<code>number</code>), логическими (<code>boolean</code>) литералами, литералами регулярных выражений (<code>RegExp</code>) или выражением <code>new</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// Плохо: &#x27;boolean&#x27; здесь не способствует удобочитаемости</span>
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Плохо: &#x27;Set&#x27; тривиально выводится из инициализации</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
</code></pre><p>Явное указание типов может потребоваться для предотвращения вычисления для дженерика параметров типа как <code>unknown</code>. Например, при инициализации для дженерика типов без заданных значений (например, пустые массивы, объекты, коллекции <code>Map</code> и <code>Set</code>).</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;();
</code></pre><p>Для более сложных выражений, аннотации типов могут улучшить читабельность программы.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Трудно предположить тип &#x27;value&#x27; без аннотации.</span>
<span class="hljs-keyword">const</span> value = <span class="hljs-keyword">await</span> rpc.<span class="hljs-title function_">getSomeValue</span>().<span class="hljs-title function_">transform</span>();
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Можно с первого взгляда определить тип &#x27;value&#x27;.</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>[] = <span class="hljs-keyword">await</span> rpc.<span class="hljs-title function_">getSomeValue</span>().<span class="hljs-title function_">transform</span>();
</code></pre><p>Необходимость аннотации определяется рецензентом кода.</p><h4 id="%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B"><span>Возвращаемые типы</span></a></h4><p>Вопрос о том, следует ли включать аннотации типа возвращаемого значения для функций и методов, зависит от автора кода. Рецензенты <em>могут</em> запросить аннотации для уточнения сложных типов возвращаемых данных, которые трудно понять. В проектах <em>может</em> существовать локальная политика, согласно которой всегда требуется указывать возвращаемые типы, но это не является общим требованием стиля TypeScript.</p><p>Явная типизация неявных возвращаемых значений функций и методов имеет два преимущества:</p><ul><li>Более точная документация для повышения удобства чтения кода.</li><li>Быстрее выявляются потенциальные ошибки типизации в будущем, когда в код вносятся изменения, которые приводят к изменению возвращаемого типа функции.</li></ul><h4 id="undefined-%26-null" tabindex="-1"><a class="header-anchor" href="#undefined-%26-null"><span>Undefined &amp; Null</span></a></h4><p>TypeScript поддерживает типы <code>undefined</code> и <code>null</code>. Nullable-типы могут быть созданы как union-типы (<code>string|null</code>), что также относится и к <code>undefined</code>. Специального синтаксиса для объединений с <code>undefined</code> и <code>null</code> не существует.</p><p>В TypeScript коде для обозначения отсутствия значения можно использовать <code>undefined</code> или <code>null</code>, при этом нет общих рекомендаций для предпочтения одного другому. Множество JavaScript API используют <code>undefined</code> (например, <code>Map.get</code>), в то время как во многих DOM API и Google API используется <code>null</code> (например, <code>Element.getAttribute</code>), поэтому подходящее обозначение отсутствия значения зависит от контекста.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Плохо</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">CoffeeResponse</span> = <span class="hljs-title class_">Latte</span>|<span class="hljs-title class_">Americano</span>|<span class="hljs-literal">undefined</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeService</span> {
  <span class="hljs-title function_">getLatte</span>(): <span class="hljs-title class_">CoffeeResponse</span> { ... };
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Лучше</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">CoffeeResponse</span> = <span class="hljs-title class_">Latte</span>|<span class="hljs-title class_">Americano</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeService</span> {
  <span class="hljs-title function_">getLatte</span>(): <span class="hljs-title class_">CoffeeResponse</span>|<span class="hljs-literal">undefined</span> { ... };
}
</code></pre><h4 id="%D0%BE%D0%BF%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B-%D0%BF%D1%80%D0%B5%D0%B4%D0%BF%D0%BE%D1%87%D1%82%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B5%D0%B5-%7Cundefined" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%BF%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B-%D0%BF%D1%80%D0%B5%D0%B4%D0%BF%D0%BE%D1%87%D1%82%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B5%D0%B5-%7Cundefined"><span>Опциональные параметры предпочтительнее <code>|undefined</code></span></a></h4><p>Также TypeScript поддерживает специальную конструкцию для опциональных параметров и полей, используя <code>?</code>:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">CoffeeOrder</span> {
  <span class="hljs-attr">sugarCubes</span>: <span class="hljs-built_in">number</span>;
  milk?: <span class="hljs-title class_">Whole</span>|<span class="hljs-title class_">LowFat</span>|<span class="hljs-title class_">HalfHalf</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">pourCoffee</span>(<span class="hljs-params">volume?: Milliliter</span>) { ... }
</code></pre><p>Опциональные параметры неявно включают <code>|undefined</code> в свой тип. Однако они отличаются тем, что их можно не указывать при составлении выражения или вызове метода. Например, <code>{sugarCubes: 1}</code> является валидным <code>CoffeeOrder</code> поскольку <code>milk</code> является опциональным.</p><p>Используйте опциональные поля (в интерфейсах или классах) и параметры вместо <code>|undefined</code> типов.</p><p>Для классов лучше вообще избегать этого приёма и инициализировать как можно больше полей.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  field = <span class="hljs-string">&#x27;&#x27;</span>;
}
</code></pre><h4 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%83%D1%8E-%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8E" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%83%D1%8E-%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8E"><span>Используйте структурную типизацию</span></a></h4><p>Система типов TypeScript является структурной, а не номинальной. Т.е. значение соответствует типу, если оно имеет, по крайней мере, все требуемые типом свойства и типы свойств совпадают рекурсивно.</p><p>При предоставлении реализации, основанной на структуре, явно указывайте тип в объявлении элемента (это позволяет более точно проверить тип и сообщить об ошибке).</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-title class_">Foo</span> = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">123</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> badFoo = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">123</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,
}
</code></pre><p>Для определения структурных типов используйте интерфейсы, а не классы.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-title class_">Foo</span> = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">123</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-title class_">Foo</span> = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">123</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,
}
</code></pre><blockquote><p>Почему?</p><p>Приведенный выше объект <code>badFoo</code> полагается на вывод типа. В <code>badFoo</code> могут быть добавлены дополнительные поля, а тип будет выводиться на основе самого объекта.</p><p>При передаче <code>badFoo</code> в функцию, которая принимает <code>Foo</code>, ошибка будет возникать на месте вызова функции, а не на месте объявления объекта. Это также существенно при изменении описания интерфейса в обширной кодовой базе.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">sound</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">makeSound</span>(<span class="hljs-params">animal: Animal</span>) {}

<span class="hljs-comment">/**
 * &#x27;cat&#x27; имеет выводимый тип &#x27;{sound: string}&#x27;
 */</span>
<span class="hljs-keyword">const</span> cat = {
  <span class="hljs-attr">sound</span>: <span class="hljs-string">&#x27;meow&#x27;</span>,
};

<span class="hljs-comment">/**
 * &#x27;cat&#x27; не соответствует требуемому для функции типу,
 * поэтому компилятор TypeScript выдает ошибку здесь,
 * что может быть очень далеко от места определения &#x27;cat&#x27;.
 */</span>
<span class="hljs-title function_">makeSound</span>(cat);

<span class="hljs-comment">/**
 * Horse имеет структурный тип, и ошибка типа возникает здесь, а не в вызове функции,
 * поскольку &#x27;horse&#x27; не соответствует требованиям типа &#x27;Animal&#x27;
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">horse</span>: <span class="hljs-title class_">Animal</span> = {
  <span class="hljs-attr">sound</span>: <span class="hljs-string">&#x27;niegh&#x27;</span>,
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">dog</span>: <span class="hljs-title class_">Animal</span> = {
  <span class="hljs-attr">sound</span>: <span class="hljs-string">&#x27;bark&#x27;</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;MrPickles&#x27;</span>,
};

<span class="hljs-title function_">makeSound</span>(dog);
<span class="hljs-title function_">makeSound</span>(horse);
</code></pre></blockquote><h3 id="%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B-%D0%BF%D1%80%D0%B5%D0%B4%D0%BF%D0%BE%D1%81%D1%82%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B5%D0%B5-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0-%D0%B4%D0%BB%D1%8F-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D0%B0-%D1%82%D0%B8%D0%BF%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B-%D0%BF%D1%80%D0%B5%D0%B4%D0%BF%D0%BE%D1%81%D1%82%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B5%D0%B5-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0-%D0%B4%D0%BB%D1%8F-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D0%B0-%D1%82%D0%B8%D0%BF%D0%B0"><span>Интерфейсы предпостительнее создания псевдонима для литерала типа</span></a></h3><p>TypeScript поддерживает <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases">псевдонимы типов</a> для присвоения имени всему выражению описывающему тип. Это может быть использовано для именования примитивов, объединений, кортежей и любых других типов.</p><p>Однако, при объявлении типов для объектов, используйте интерфейсы вместо псевдонима типа, для выражения, представленного объектным литералом.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span>;
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>,
  <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span>,
}
</code></pre><blockquote><p>Почему?</p><p>Эти формы почти эквивалентны, поэтому следуя принципу выбора только одной из двух форм, для предотвращения вариативности, нам стоит выбрать одну из них. Кроме того, существуют также <a href="https://ncjamieson.com/prefer-interfaces/">интересные технические причины, по которым предпочтение отдается интерфейсу</a>. На той странице также приводятся слова руководителя команды разработчиков TypeScript: &quot;Честно говоря, я считаю, что на самом деле это должны быть просто интерфейсы для всего, что они могут моделировать. Нет особой выгоды в псевдонимах типов, когда существует так много проблем с их отображением и производительностью&quot;.</p></blockquote><h3 id="%D1%82%D0%B8%D0%BF-array%3Ct%3E" tabindex="-1"><a class="header-anchor" href="#%D1%82%D0%B8%D0%BF-array%3Ct%3E"><span>Тип <code>Array&lt;T&gt;</code></span></a></h3><p>Для простых типов (содержащих только буквенно-цифровые символы и точку) используйте синтаксический сахар для массивов, т.е. <code>T[]</code> или <code>readonly T[]</code>, а не более длинную форму <code>Array&lt;T&gt;</code> или <code>ReadonlyArray&lt;T&gt;</code>.</p><p>Для многомерных массивов простых типов, не предназначенных только для чтения (т.е. которые не <code>readonly</code>), используйте синтаксический сахар (<code>T[][]</code>, <code>T[][][]</code> и т.д.), а не более длинную форму.</p><p>Для чего-то более сложного используйте более длинную форму <code>Array&lt;T&gt;</code>.</p><p>Эти правила применяются на каждом уровне вложенности, т.е. простой <code>T[]</code>, вложенный в более сложный тип, все равно будет написан как <code>T[]</code>, т.е. с использованием синтаксического сахара.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>[];
<span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span>[];
<span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: ns.<span class="hljs-property">MyObj</span>[];
<span class="hljs-keyword">let</span> <span class="hljs-attr">d</span>: <span class="hljs-built_in">string</span>[][];
<span class="hljs-keyword">let</span> <span class="hljs-attr">e</span>: <span class="hljs-title class_">Array</span>&lt;{<span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>}&gt;;
<span class="hljs-keyword">let</span> <span class="hljs-attr">f</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>&gt;;
<span class="hljs-keyword">let</span> <span class="hljs-attr">g</span>: <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>&gt;;
<span class="hljs-keyword">let</span> <span class="hljs-attr">h</span>: <span class="hljs-title class_">InjectionToken</span>&lt;<span class="hljs-built_in">string</span>[]&gt;;  <span class="hljs-comment">// Используйте синтаксический сахар для вложенных типов</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>: <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">string</span>[]&gt;;
<span class="hljs-keyword">let</span> <span class="hljs-attr">j</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span>[]&gt;;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;;  <span class="hljs-comment">// Синтаксический сахар короче</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">string</span>&gt;;
<span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">Array</span>&lt;ns.<span class="hljs-property">MyObj</span>&gt;;
<span class="hljs-keyword">let</span> <span class="hljs-attr">d</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>[]&gt;;
<span class="hljs-keyword">let</span> <span class="hljs-attr">e</span>: {<span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>}[];  <span class="hljs-comment">// Фигурные скобки ухудшают читабельность</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">f</span>: (<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>)[];         <span class="hljs-comment">// Аналогично и с круглыми скобками</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">g</span>: <span class="hljs-keyword">readonly</span> (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[];
<span class="hljs-keyword">let</span> <span class="hljs-attr">h</span>: <span class="hljs-title class_">InjectionToken</span>&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;;
<span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>: <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span>[][];
<span class="hljs-keyword">let</span> <span class="hljs-attr">j</span>: (<span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span>[])[];
</code></pre><h3 id="%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-%2F-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D1%82%D1%83%D1%80%D1%8B-(%7B%5Bkey%3A-string%5D%3A-t%7D)" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-%2F-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D1%82%D1%83%D1%80%D1%8B-(%7B%5Bkey%3A-string%5D%3A-t%7D)"><span>Индексируемые типы / индексные сигнатуры (<code>{[key: string]: T}</code>)</span></a></h3><p>В JavaScript принято использовать объект в качестве ассоциативного массива (он же карта (map), хеш-таблица, или словарь). В TypeScript такие объекты могут быть типизированы с использованием <a href="https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures">индексной сигнатуры</a> (<code>[k: string]: T</code>):</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">fileSizes</span>: {[<span class="hljs-attr">fileName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>} = {};
fileSizes[<span class="hljs-string">&#x27;readme.txt&#x27;</span>] = <span class="hljs-number">541</span>;
</code></pre><p>В TypeScript укажите осмысленное обозначение для ключа. (Обозначение существует только для документации; в остальном оно не используется.)</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">users</span>: {[<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>} = ...;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">users</span>: {[<span class="hljs-attr">userName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>} = ...;
</code></pre><blockquote><p>Вместо использования одного из тех вариантов, рассмотрите возможность использования <code>Map</code> и <code>Set</code> типов ES6. Объекты JavaScript обладают довольно <a href="http://2ality.com/2012/01/objects-as-maps.html">неожиданным нежелательным поведением</a>, а типы ES6 более явно передают ваши намерения. Также, <code>Set</code> могут хранить значения, а <code>Map</code> еще и ключи, отличные от <code>string</code>.</p></blockquote><p>Встроенный в TypeScript тип <code>Record&lt;Keys, ValueType&gt;</code> позволяет создавать типы с определенным набором ключей. Это отличается от ассоциативных массивов тем, что ключи известны статически. См. рекомендации по этому вопросу <a href="#%D1%81%D0%BE%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-mapped--%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-conditional-%D1%82%D0%B8%D0%BF%D1%8B">ниже</a>.</p><h3 id="%D1%81%D0%BE%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-(mapped)-%D0%B8-%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-(conditional)-%D1%82%D0%B8%D0%BF%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%BE%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-(mapped)-%D0%B8-%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-(conditional)-%D1%82%D0%B8%D0%BF%D1%8B"><span>Сопоставленные (Mapped) и Условные (Conditional) Типы</span></a></h3><p>В TypeScript <a href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html">сопоставленные</a> и <a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html">условные</a> типы позволяют определять новые типы на основе других типов. Стандартная библиотека TypeScript включает в себя ряд основанных на этих операциях типов (<code>Record</code>, <code>Partial</code>, <code>Readonly</code> и др.).</p><p>Эти особенности системы типов позволяют лаконично задавать типы и создавать мощные, но в то же время безопасные абстракции типов. Однако они обладают определенным количеством недостатков:</p><ul><li>По сравнению с явным указанием свойств и взаимосвязей типов (например, с использованием интерфейсов и расширений, пример см. ниже), операции с типами требуют от читателя мысленно просчитывать выражения типа. Это может существенно затруднить чтение программ, особенно в сочетании с выводом типов и выражениями, пересекающими границы файлов.</li><li>Модель оценки сопоставленных и условных типов, особенно в сочетании с выводом типов, недостаточно определена, не всегда хорошо понятна и нередко претерпевает изменения в версиях компилятора TypeScript. Код может скомпилироваться по ошибке или казаться дающим правильные результаты. Это увеличивает стоимость будущей поддержки кода, использующего операции с типами.</li><li>Сопоставленные и условные типы являются наиболее мощными при получении типов на основе комплексных и/или выводимых типов. С другой стороны, это также тот случай, когда они наиболее склонны создавать трудные для понимания и обслуживания программы.</li><li>Некоторые языковые инструменты недостаточно хорошо работают с этими особенностями системы типов. Например, в вашей IDE поиск ссылок (&quot;references&quot;) и, соответственно, переименование свойств при рефакторинге, не найдут свойства в типе Pick&lt;T, Keys&gt;, а Code Search<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup> не будет создавать на них гиперссылки.</li></ul><p>Рекомендация по стилю такова:</p><ul><li>Всегда используйте самую простую конструкцию типа, которая может выразить ваш код.</li><li>Небольшое количество повторений или многословность зачастую обходятся гораздо дешевле, чем долговременные затраты на сложные выражения объявления типов.</li><li>Сопоставленные и условные типы могут быть использованы с учетом перечисленных аспектов.</li></ul><p>Например, встроенный в TypeScript тип <code>Pick&lt;T, Keys&gt;</code> позволяет создать новый тип на основе подмножества другого типа <code>T</code>, но простое расширение интерфейса часто может быть проще для понимания.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">shoeSize</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">favoriteIcecream</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">favoriteChocolate</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// В типе FoodPreferences есть favoriteIcecream и favoriteChocolate, но нет shoeSize.</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">FoodPreferences</span> = <span class="hljs-title class_">Pick</span>&lt;<span class="hljs-title class_">User</span>, <span class="hljs-string">&#x27;favoriteIcecream&#x27;</span>|<span class="hljs-string">&#x27;favoriteChocolate&#x27;</span>&gt;;
</code></pre><p>Это эквивалентно указанию свойств в интерфейсе <code>FoodPreferences</code>:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">FoodPreferences</span> {
  <span class="hljs-attr">favoriteIcecream</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">favoriteChocolate</span>: <span class="hljs-built_in">string</span>;
}
</code></pre><p>Чтобы сократить количество дублирований, <code>User</code> может расширить <code>FoodPreferences</code> или (что, возможно, лучше) вложить отдельное поле для указания предпочтений в еде:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">FoodPreferences</span> { <span class="hljs-comment">/* как описано выше */</span> }
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FoodPreferences</span> {
  <span class="hljs-attr">shoeSize</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">// также включает в себя предпочтения.</span>
}
</code></pre><p>Использование здесь интерфейсов делает группирование свойств более очевидным, улучшает поддержку IDE, обеспечивает лучшую оптимизацию и вполне возможно, сделает код проще для понимания.</p><h3 id="%D1%82%D0%B8%D0%BF-any" tabindex="-1"><a class="header-anchor" href="#%D1%82%D0%B8%D0%BF-any"><span>Тип <code>any</code></span></a></h3><p>В TypeScript тип <code>any</code> является супертипом и подтипом всех других типов и при разыменовании допускает обращение к любым свойствам. Как таковой, <code>any</code> опасен - он может маскировать серьезные программные ошибки и его использование разрушает ценность наличия статических типов, в первую очередь.</p><p><strong>Подумайте о том, чтобы не использовать <code>any</code>.</strong> В тех обстоятельствах, в которых вы захотите использовать <code>any</code>, рассмотрите один из вариантов:</p><ul><li><a href="#%D0%BF%D1%80%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5-%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D1%84%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE-%D1%82%D0%B8%D0%BF%D0%B0">Указать более конкретный тип</a></li><li><a href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-unknown-%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%BE-any">Использовать <code>unknown</code></a></li><li><a href="#%D0%BF%D0%BE%D0%B4%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B5%D0%B4%D1%83%D0%BF%D1%80%D0%B5%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BB%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B0-%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC-any">Подавить предупреждение анализатора кода и задокументировать, почему</a></li></ul><h4 id="%D0%BF%D1%80%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5-%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D1%84%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE-%D1%82%D0%B8%D0%BF%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5-%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D1%84%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE-%D1%82%D0%B8%D0%BF%D0%B0"><span>Предоставление более специфичного типа</span></a></h4><p>Используйте интерфейсы, встраиваемый объектный тип или псевдоним типа:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Используйте декларируемые интерфейсы для представления серверного JSON.</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyUserJson</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// Используйте псевдонимы типов для тех типов, которые приходится писать многократно.</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span> = <span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>;

<span class="hljs-comment">// Или используйте встраиваемый объектный тип для возврата комплексных значений.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getTwoThings</span>(<span class="hljs-params"></span>): {<span class="hljs-attr">something</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">other</span>: <span class="hljs-built_in">string</span>} {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">return</span> {something, other};
}

<span class="hljs-comment">// Используйте дженерик там, где в ином случае библиотека указала бы `any`,</span>
<span class="hljs-comment">// чтобы обозначить, что ей все равно, с каким типом работает пользователь (но обратите </span>
<span class="hljs-comment">// внимание на раздел &quot;Возвращаемый тип представлен только дженериком&quot; представленный ниже).</span>
<span class="hljs-keyword">function</span> nicestElement&lt;T&gt;(<span class="hljs-attr">items</span>: T[]): T {
  <span class="hljs-comment">// Поиск наиболее подходящего элемента в items.</span>
  <span class="hljs-comment">// Код может также накладывать ограничения на T, например &lt;T extends HTMLElement&gt;.</span>
}
</code></pre><h4 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-unknown-%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%BE-any" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-unknown-%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%BE-any"><span>Использование <code>unknown</code> вместо <code>any</code></span></a></h4><p>Тип <code>any</code> позволяет присваивать значение любого другого типа и разыменовывать любые его свойства. Часто такое поведение не является необходимым или желательным и код просто нуждается в обозначении неизвестности типа. В такой ситуации используйте встроенный тип <code>unknown</code> - он точнее описывает суть концепции и гораздо безопаснее, поскольку не позволяет разыменовывать произвольные свойства.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Можно присваивать любое значение (включая null или undefined), но нельзя </span>
<span class="hljs-comment">// использовать его без сужения типа или приведения.</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">val</span>: <span class="hljs-built_in">unknown</span> = value;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">danger</span>: <span class="hljs-built_in">any</span> = value <span class="hljs-comment">/* результат произвольного выражения */</span>;
danger.<span class="hljs-title function_">whoops</span>();  <span class="hljs-comment">//  Этот доступ к переменной абсолютно бесконтролен</span>
</code></pre><p>Чтобы благополучно использовать значения типа <code>unknown</code>, следует сужать тип с помощью <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types">защитников типа (type guards)</a>.</p><h4 id="%D0%BF%D0%BE%D0%B4%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B5%D0%B4%D1%83%D0%BF%D1%80%D0%B5%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BB%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B0%2C-%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC-any" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%BE%D0%B4%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B5%D0%B4%D1%83%D0%BF%D1%80%D0%B5%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BB%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B0%2C-%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC-any"><span>Подавление предупреждений линтера, связанных с использованием <code>any</code></span></a></h4><p>Иногда использование <code>any</code> вполне оправдано, например, в тестах для создания Mock-объектов. В таких случаях добавьте комментарий, который подавляет предупреждение линтера, и задокументируйте, почему это решение оправдано.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Этому тесту нужна только частичная реализация BookService,</span>
<span class="hljs-comment">// и если мы что-то упустили, тест очевидно провалится</span>
<span class="hljs-comment">// Это намеренно небезопасный частичный Mock-объект</span>
<span class="hljs-comment">// tslint:disable-next-line:no-any</span>
<span class="hljs-keyword">const</span> mockBookService = ({<span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> mockBook; }} <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">BookService</span>;
<span class="hljs-comment">// Корзина покупателя (класс ShoppingCart) в этом тесте не используется</span>
<span class="hljs-comment">// tslint:disable-next-line:no-any</span>
<span class="hljs-keyword">const</span> component = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyComponent</span>(mockBookService, <span class="hljs-comment">/* неиспользуемый ShoppingCart */</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>);
</code></pre><h3 id="%D1%82%D0%B8%D0%BF-%7B%7D" tabindex="-1"><a class="header-anchor" href="#%D1%82%D0%B8%D0%BF-%7B%7D"><span>Тип <code>{}</code></span></a></h3><p>Тип {}, также известный как пустой тип интерфейса, представляет собой интерфейс без свойств. Пустой тип интерфейса не имеет заданных свойств, поэтому ему можно присвоить любое значение, не являющееся <code>null</code> или <code>undefined</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">let</span> <span class="hljs-attr">player</span>: {};

player = {
  <span class="hljs-attr">health</span>: <span class="hljs-number">50</span>,
}; <span class="hljs-comment">// Allowed.</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(player.<span class="hljs-property">health</span>) <span class="hljs-comment">// Property &#x27;health&#x27; does not exist on type &#x27;{}&#x27;.</span>
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">takeAnything</span>(<span class="hljs-params">obj:{}</span>) {

}

<span class="hljs-title function_">takeAnything</span>({});
<span class="hljs-title function_">takeAnything</span>({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> });
</code></pre><p>В большинстве случаев в коде Google3<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup> не рекомендуется использовать <code>{}</code>. <code>{}</code> представляет собой любой кроме <code>null</code> и <code>undefined</code> примитив или объектный тип, что редко когда бывает уместно. Предпочтите один из следующих более описательных типов:</p><ul><li><code>unknown</code> может содержать любое значение, включая <code>null</code> или <code>undefined</code>, и обычно больше подходит для значений с непрозрачной структурой данных.</li><li><code>Record&lt;string, T&gt;</code> лучше подходит для подобных словарю объектов и обеспечивает лучшую безопасность типов за счет явного указания типа <code>T</code> для содержащихся значений (которые сами по себе могут иметь тип <code>unknown</code>).</li><li><code>object</code> исключает примитивы, в т.ч. <code>null</code> и <code>undefined</code>, оставляя только функции и объекты, но без каких-либо других предположений о том, какие свойства могут быть доступны.</li></ul><h3 id="%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B"><span>Кортежные типы</span></a></h3><p>Если у вас возникнет соблазн создать парный тип, то используйте вместо него кортежный тип:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Pair</span> {
  <span class="hljs-attr">first</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">second</span>: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">splitInHalf</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Pair</span> {
  ...
  <span class="hljs-keyword">return</span> {<span class="hljs-attr">first</span>: x, <span class="hljs-attr">second</span>: y};
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">splitInHalf</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>): [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>] {
  ...
  <span class="hljs-keyword">return</span> [x, y];
}

<span class="hljs-comment">// Используйте это как:</span>
<span class="hljs-keyword">const</span> [leftHalf, rightHalf] = <span class="hljs-title function_">splitInHalf</span>(<span class="hljs-string">&#x27;my string&#x27;</span>);
</code></pre><p>Однако часто бывает яснее, если свойствам даются осмысленные имена.</p><p>Если объявление интерфейса (<code>interface</code>) слишком обременительно, можно использовать встраиваемый объектным литералом тип:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">splitHostPort</span>(<span class="hljs-params">address: <span class="hljs-built_in">string</span></span>): {<span class="hljs-attr">host</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">port</span>: <span class="hljs-built_in">number</span>} {
  ...
}

<span class="hljs-comment">// Используйте это как:</span>
<span class="hljs-keyword">const</span> address = <span class="hljs-title function_">splitHostPort</span>(userAddress);
<span class="hljs-title function_">use</span>(address.<span class="hljs-property">port</span>);

<span class="hljs-comment">// Вы также можете использовать деструктуризацию, чтобы получить поведение, подобное разложению кортежа на отдельные переменные:</span>
<span class="hljs-keyword">const</span> {host, port} = <span class="hljs-title function_">splitHostPort</span>(userAddress);
</code></pre><h3 id="%D1%82%D0%B8%D0%BF%D1%8B-%D0%BE%D0%B1%D0%B5%D1%80%D1%82%D0%BA%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D1%82%D0%B8%D0%BF%D1%8B-%D0%BE%D0%B1%D0%B5%D1%80%D1%82%D0%BA%D0%B8"><span>Типы-обертки</span></a></h3><p>Есть несколько типов, связанных с JavaScript примитивами, которые <em>не рекомендуется</em> когда-либо использовать:</p><ul><li><code>String</code>, <code>Boolean</code>, и <code>Number</code> имеют несколько иное значение, чем соответствующие примитивные типы <code>string</code>, <code>boolean</code>, and <code>number</code>. Всегда используйте версию со строчными буквами.</li><li><code>Object</code> имеет сходство с <code>{}</code> и <code>object</code>, но является несколько менее строгим. Используйте <code>{}</code> для типа, который включает в себя всё, кроме <code>null</code> и <code>undefined</code>, или строчный <code>object</code> для того, чтобы дополнительно исключить другие примитивные типы (три упомянутых выше, плюс <code>symbol</code> и <code>bigint</code>).</li></ul><p>Кроме того, никогда не вызывайте типы-обертки в качестве конструкторов (с помощью <code>new</code>).</p><h3 id="%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%D1%8B%D0%B9-%D1%82%D0%B8%D0%BF-%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%B4%D0%B6%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D0%BA%D0%BE%D0%BC" tabindex="-1"><a class="header-anchor" href="#%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%D1%8B%D0%B9-%D1%82%D0%B8%D0%BF-%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%B4%D0%B6%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D0%BA%D0%BE%D0%BC"><span>Возвращаемый тип представлен только дженериком</span></a></h3><p>Избегайте создания API у которых возвращаемый тип представлен только дженериком. При работе с существующими API у которых возвращаемый тип представлен только дженериком, всегда явно указывайте дженерик <sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>.</p><h2 id="%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA-%D1%86%D0%B5%D0%BF%D0%BE%D1%87%D0%BA%D0%B5-%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA-%D1%86%D0%B5%D0%BF%D0%BE%D1%87%D0%BA%D0%B5-%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2"><span>Требования к цепочке инструментов</span></a></h2><p>Стиль Google требует использования ряда инструментов определенными способами, описанными здесь.</p><h3 id="%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80-typescript" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80-typescript"><span>Компилятор TypeScript</span></a></h3><p>Все файлы TypeScript должны проходить проверку типов с использованием стандартной цепочки инструментов.</p><h4 id="%40ts-ignore" tabindex="-1"><a class="header-anchor" href="#%40ts-ignore"><span>@ts-ignore</span></a></h4><p>Не используйте <code>@ts-ignore</code>, а также такие варианты, как <code>@ts-expect-error</code> или <code>@ts-nocheck</code>.</p><blockquote><p>Почему?</p><p>На первый взгляд кажется, что это простой способ исправить ошибку компилятора, но на практике конкретная ошибка компилятора часто вызывается более серьезной проблемой, которая может быть исправлена более явным путем.</p><p>Например, если вы используете <code>@ts-ignore</code> для подавления ошибок типизации, то будет трудно предсказать, какие типы в конечном итоге будет видеть окружающий код. Для многих ошибок типизации, полезны советы в разделе <a href="#%D1%82%D0%B8%D0%BF-any">как лучше всего использовать</a> <code>any</code>.</p></blockquote><p>Вы можете использовать <code>@ts-expect-error</code> в юнит-тестах, хотя обычно этого делать не следует. <code>@ts-expect-error</code> подавляет все ошибки. Легко случайно перестараться и подавить более серьезные ошибки. По возможности, рассмотрите какой-либо из этих вариантов:</p><ul><li>При тестировании API, которые должны иметь дело с непроверенными значениями во время выполнения, добавьте приведение к ожидаемому типу или к <code>any</code> и добавьте поясняющий комментарий. Это позволит ограничить подавление ошибок одним выражением.</li><li>Подавите предупреждение линтера и задокументируйте причину, по аналогии с <a href="#%D0%BF%D0%BE%D0%B4%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B5%D0%B4%D1%83%D0%BF%D1%80%D0%B5%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BB%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B0-%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC-any">подавлением предупреждений линтера, связанных с использованием <code>any</code></a>.</li></ul><h3 id="%D1%81%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B8%D1%8F" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B8%D1%8F"><span>Соответствия</span></a></h3><p>Google TypeScript включает в себя несколько <em>фреймворков соответствия</em><sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>: <a href="https://tsetse.info/">tsetse</a> и <a href="https://github.com/google/tsec">tsec</a>.</p><p>Эти правила обычно используются для обеспечения соблюдения критических ограничений (например, определения глобальных переменных, которые могут нарушить кодовую базу) и паттернов безопасности (например, использования <code>eval</code> или назначения <code>innerHTML</code>) или если в более общем плане, то для улучшения качества кода.</p><p>Код TypeScript в стиле Google должен соответствовать всем применимым глобальным или локальным для фреймворков правилам соответствия.</p><h2 id="%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%B8-%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%B8-%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F"><span>Комментарии и Документация</span></a></h2><h3 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-jsdoc-%D0%B2-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B8-%D1%81-%D0%BE%D0%B1%D1%8B%D1%87%D0%BD%D1%8B%D0%BC%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D1%8F%D0%BC%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-jsdoc-%D0%B2-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B8-%D1%81-%D0%BE%D0%B1%D1%8B%D1%87%D0%BD%D1%8B%D0%BC%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D1%8F%D0%BC%D0%B8"><span>Использование JSDoc в сравнении с обычными комментариями</span></a></h3><p>Существует два типа комментариев, JSDoc (<code>/** ... */</code>) и не относящиеся к JSDoc обычные комментарии (<code>// ...</code> или <code>/* ... */</code>).</p><ul><li>Используйте <code>/** JSDoc */</code> комментарии для документации. Это те комментарии, с которыми стоит ознакомиться при использовании кода.</li><li>Используйте <code>// строчные комментарии</code> для комментирования реализации. Эти комментарии которые касаются только реализации самого кода.</li></ul><p>Комментарии JSDoc могут распознаваться различными инструментальными программами, такими как редакторы кода и генераторы документации, в то время как обычные комментарии могут быть распознаны только другими людьми.</p><h3 id="%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D1%81%D1%82%D1%80%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D1%81%D1%82%D1%80%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8"><span>Многострочные комментарии</span></a></h3><p>Многострочные комментарии имеют отступ на том же уровне, что и окружающий код. Они должны использовать несколько однострочных комментариев (т.е. в стиле <code>//</code>), а не блочный стиль комментариев (<code>/* */</code>).</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Это хороший</span>
<span class="hljs-comment">// комментарий</span>
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">/*
 * Тут рекомендуется
 * использовать многочисленные
 * однострочные комментарии
 */</span>

<span class="hljs-comment">/* Тут рекомендуется использовать // */</span>
</code></pre><p>Комментарии не заключаются в рамки, оформленные с помощью звездочек или иных символов.</p><h3 id="%D0%BE%D0%B1%D1%89%D0%B0%D1%8F-%D1%84%D0%BE%D1%80%D0%BC%D0%B0-jsdoc" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%B1%D1%89%D0%B0%D1%8F-%D1%84%D0%BE%D1%80%D0%BC%D0%B0-jsdoc"><span>Общая форма JSDoc</span></a></h3><p>Основное форматирование комментариев JSDoc выглядит так, как показано в этом примере:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/**
 * Множество строк текста JSDoc записанных здесь,
 * переносятся нормально
 * <span class="hljs-doctag">@param</span> arg Число, с которым нужно что-то делать.
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">arg: <span class="hljs-built_in">number</span></span>) { … }
</code></pre><p>или в этом однострочном примере:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/** Этот краткий jsdoc описывает функцию. */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">arg: <span class="hljs-built_in">number</span></span>) { … }
</code></pre><p>Если однострочный комментарий переносится на несколько строк, он должен использовать многострочный стиль с <code>/**</code> и <code>*/</code> в своих строках.</p><p>Многие инструменты извлекают метаданные из комментариев JSDoc для выполнения валидации и оптимизации кода. Поэтому эти комментарии <em>должны</em> быть хорошо сформированы.</p><h3 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-markdown" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-markdown"><span>Использование Markdown</span></a></h3><p>JSDoc написан в формате Markdown, хотя при необходимости <em>возможно</em> добавление HTML.</p><p>Это означает, что инструментарий, обрабатывающий JSDoc, будет игнорировать форматирование обычного текста, поэтому, если вы сделаете это:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">/**
 * Вычисляет вес на основе трех факторов:
 *   элементов отправлено
 *   элементов получено
 *   последняя временная метка
 */</span>
</code></pre><p>Это будет преобразовано подобным образом:</p><pre><code class="language-ts">Вычисляет вес на основе трех факторов: элементов отправлено элементов получено последняя временная метка
</code></pre><p>Вместо этого напишите список в формате Markdown:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/**
 * Вычисляет вес на основе трех факторов:
 *  - элементов отправлено
 *  - элементов получено
 *  - последняя временная метка
 */</span>
</code></pre><h3 id="jsdoc-%D1%82%D0%B5%D0%B3%D0%B8" tabindex="-1"><a class="header-anchor" href="#jsdoc-%D1%82%D0%B5%D0%B3%D0%B8"><span>JSDoc теги</span></a></h3><p>Стиль Google позволяет использовать подмножество тегов JSDoc. Большинство тегов должны занимать отдельную строку, причем тег должен находиться в начале строки.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/**
 * Тэг &quot;param&quot; должен занимать свою собственную строку и не может комбинироваться.
 * <span class="hljs-doctag">@param</span> left Описание левого параметра.
 * <span class="hljs-doctag">@param</span> right Описание правого параметра.
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">left: <span class="hljs-built_in">number</span>, right: <span class="hljs-built_in">number</span></span>) { ... }
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">/**
 * Тэг &quot;param&quot; должен занимать свою собственную строку и не может комбинироваться.
 * <span class="hljs-doctag">@param</span> left <span class="hljs-doctag">@param</span> <span class="hljs-variable">right</span>
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">left: <span class="hljs-built_in">number</span>, right: <span class="hljs-built_in">number</span></span>) { ... }
</code></pre><h3 id="%D0%BF%D0%B5%D1%80%D0%B5%D0%BD%D0%BE%D1%81-%D1%81%D1%82%D1%80%D0%BE%D0%BA" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%BD%D0%BE%D1%81-%D1%81%D1%82%D1%80%D0%BE%D0%BA"><span>Перенос строк</span></a></h3><p>Перенесенные по строкам блоки тегов имеют отступ в четыре пробела. Перенесенный текст описания <em>возможно</em> выровнять с описанием на предыдущих строках, но такое горизонтальное выравнивание не рекомендуется.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">/**
 * Иллюстрирует перенос строк для длинных описаний параметров и возвращаемых значений.
 * <span class="hljs-doctag">@param</span> foo Это параметр с особенно длинным описанием, которое просто 
 *     не помещается в одну строку.
 * <span class="hljs-doctag">@return</span> Возвращает нечно с длинным описанием, которое не помещается
 *     в одну строку.
 */</span>
<span class="hljs-built_in">exports</span>.<span class="hljs-property">method</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">foo</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
};
</code></pre><p>Не делайте отступ при переносе строк в описании @desc или @fileoverview тегов.</p><h3 id="%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2%D1%81%D0%B5%D1%85-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2-%D0%B2%D0%B5%D1%80%D1%85%D0%BD%D0%B5%D0%B3%D0%BE-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D1%8F-%D0%B2-%D1%81%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%B5-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%B9" tabindex="-1"><a class="header-anchor" href="#%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2%D1%81%D0%B5%D1%85-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2-%D0%B2%D0%B5%D1%80%D1%85%D0%BD%D0%B5%D0%B3%D0%BE-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D1%8F-%D0%B2-%D1%81%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%B5-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%B9"><span>Документирование всех экспортов верхнего уровня в составе модулей</span></a></h3><p>Используйте <code>/** JSDoc */</code> комментарии для передачи информации пользователям вашего кода. Избегайте простого повторения имени свойства или параметра. Вам <em>рекомендуется</em> документировать все свойства и методы (экспортируемые/публичные или нет), назначение которых, по мнению вашего рецензента, не сразу очевидно из их названия.</p><p>Исключение: элементы, которые экспортируются только для использования инструментальными программами, например классы @NgModule, не требуют комментариев.</p><h3 id="%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0"><span>Комментарии класса</span></a></h3><p>JSDoc комментарии для классов рекомендуется предоставлять с достаточным объемом информации для понимания читающими того, как и когда использовать класс, а также любые дополнительные моменты, необходимые для корректного использования этого класса.</p><h3 id="%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%B2-%D0%B8-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%B2-%D0%B8-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9"><span>Комментарии методов и функций</span></a></h3><p>Описания методов, параметров и возвращаемых значений можно опустить, если они очевидны из остальной части JSDoc комментария метода или из имени метода и сигнатуры типа.</p><p>Описание метода начинается с глагольного сочетания, которое описывает, что этот метод делает. Это глагольное сочетание не содержит повелительного наклонения, но вместо этого пишется в третьем лице, как будто перед ней подразумевается фраза &quot;Этот метод ....&quot;.</p><h3 id="%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%BA-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%D0%BC" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%BA-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%D0%BC"><span>Комментарии к параметризованным свойствам</span></a></h3><p><a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties">Параметризованное свойство</a> — это параметр конструктора, которому предшествует один из модификаторов <code>private</code>, <code>protected</code>, <code>public</code> или <code>readonly</code>. Параметризованное свойство объявляет одновременно и параметр и свойство экземпляра, а также неявно присваивает им значения. Для примера, выражение <code>constructor(private readonly foo: Foo)</code> объявляет то, что конструктор принимает параметр <code>foo</code>, а также объявляет приватное и доступное только для чтения свойство <code>foo</code> и присваивает значение параметра этому свойству перед выполнением остальной части конструктора.</p><p>Чтобы задокументировать эти поля, используйте JSDoc <code>@param</code> аннотацию. Редакторы отображают описание при вызовах конструктора и доступе к свойствам.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/** Этот класс демонстрирует, как документируются параметризованные свойства. */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ParamProps</span> {
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> percolator Кофеварка, используемая для варки.
   * <span class="hljs-doctag">@param</span> beans Зерна для варки.
   */</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> percolator: Percolator,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> beans: CoffeeBean[]</span>) {}
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/** Этот класс демонстрирует, как документируются обычные поля. */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">OrdinaryClass</span> {
  <span class="hljs-comment">/** Кофейные зерна, которые будут использоваться в следующем вызове brew(). */</span>
  <span class="hljs-attr">nextBean</span>: <span class="hljs-title class_">CoffeeBean</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">initialBean: CoffeeBean</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextBean</span> = initialBean;
  }
}
</code></pre><h3 id="%D0%B0%D0%BD%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D0%B8-%D1%82%D0%B8%D0%BF%D0%B0-%D0%B2-jsdoc" tabindex="-1"><a class="header-anchor" href="#%D0%B0%D0%BD%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D0%B8-%D1%82%D0%B8%D0%BF%D0%B0-%D0%B2-jsdoc"><span>Аннотации типа в JSDoc</span></a></h3><p>Аннотации типа в JSDoc являются избыточными для исходного кода на TypeScript. Не указывайте типы в <code>@param</code> или <code>@return</code> блоках, не пишите <code>@implements</code>, <code>@enum</code>, <code>@private</code>, <code>@override</code> в коде, который использует <code>implements</code>, <code>enum</code>, <code>private</code>, <code>override</code> и пр. ключевые слова.</p><h3 id="%D0%B4%D0%B5%D0%BB%D0%B0%D0%B9%D1%82%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8%2C-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE-%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E%D1%82-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8E" tabindex="-1"><a class="header-anchor" href="#%D0%B4%D0%B5%D0%BB%D0%B0%D0%B9%D1%82%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8%2C-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE-%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E%D1%82-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8E"><span>Делайте комментарии, которые действительно добавляют информацию</span></a></h3><p>Для неэкспортируемых элементов иногда достаточно имени и типа функции или параметра. Хотя код <em>обычно</em> выигрывает от большего документирования, чем просто имена переменных!</p><ul><li>Избегайте комментариев в которых просто повторяется имя и тип параметра.<pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">/** <span class="hljs-doctag">@param</span> fooBarService Сервис &quot;The Bar&quot; для приложения &quot;the Foo&quot;. */</span>
</code></pre></li><li>Исходя из этого правила, строки <code>@param</code> и <code>@return</code> требуются только тогда, когда они добавляют новую информацию, а иначе их <em>возможно</em> исключить.<pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/**
 * Отправляет POST-запрос для начала варки кофе.
 * <span class="hljs-doctag">@param</span> amountLitres Количество для заваривания. Должно соответствовать размеру емкости!
 */</span>
<span class="hljs-title function_">brew</span>(<span class="hljs-params">amountLitres: <span class="hljs-built_in">number</span>, logger: Logger</span>) {
  <span class="hljs-comment">// ...</span>
}
</code></pre></li></ul><h4 id="%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%BF%D1%80%D0%B8-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%BF%D1%80%D0%B8-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8"><span>Комментарии при вызове функции</span></a></h4><p>Комментарии &quot;Имя параметра&quot; рекомендуется использовать всякий раз, когда имя метода и значение параметра недостаточно передают смысл параметра.</p><p>Прежде чем добавлять эти комментарии, подумайте о рефакторинге метода, чтобы он принимал интерфейс и деструктурировал его, что позволит значительно улучшить читаемость в местах вызова этого метода.</p><p>Комментарии &quot;Имя параметра&quot; располагаются перед значением параметра и включают в себя имя параметра и суффикс <code>=</code>:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-title function_">someFunction</span>(obviousParam, <span class="hljs-comment">/* shouldRender= */</span> <span class="hljs-literal">true</span>, <span class="hljs-comment">/* name= */</span> <span class="hljs-string">&#x27;hello&#x27;</span>);
</code></pre><p>В существующем коде комментарий &quot;Имя параметра&quot; возможно использовать в устаревшем стиле, при котором такой комментарий не содержит символ <code>=</code> и размещается <em>после</em> значения параметра. Продолжение использования этого стиля в файле для обеспечения единообразия допустимо.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-title function_">someFunction</span>(obviousParam, <span class="hljs-literal">true</span> <span class="hljs-comment">/* shouldRender */</span>, <span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-comment">/* name */</span>);
</code></pre><h3 id="%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%89%D0%B0%D0%B9%D1%82%D0%B5-%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8E-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0%D0%BC%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%89%D0%B0%D0%B9%D1%82%D0%B5-%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8E-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0%D0%BC%D0%B8"><span>Размещайте документацию перед декораторами</span></a></h3><p>Если класс, метод или свойство содержит и JSDoc и декораторы вроде <code>@Component</code>, то убедитесь, что JSDoc написан перед декоратором.</p><ul><li><p>Не пишите JSDoc между декоратором и декорируемым выражением.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,
})
<span class="hljs-comment">/** Компонент, который печатает &quot;bar&quot;. */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FooComponent</span> {}
</code></pre></li><li><p>Напишите JSDoc перед декоратором.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/** Компонент, который печатает &quot;bar&quot;. */</span>
<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FooComponent</span> {}
</code></pre></li></ul><h2 id="%D0%BF%D0%BE%D0%BB%D0%B8%D1%82%D0%B8%D0%BA%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%BE%D0%BB%D0%B8%D1%82%D0%B8%D0%BA%D0%B8"><span>Политики</span></a></h2><h3 id="%D0%B5%D0%B4%D0%B8%D0%BD%D0%BE%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%B8%D0%B5" tabindex="-1"><a class="header-anchor" href="#%D0%B5%D0%B4%D0%B8%D0%BD%D0%BE%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%B8%D0%B5"><span>Единообразие</span></a></h3><p>Для любого вопроса о стиле, который не решен окончательно этой спецификацией, делайте то, что уже делает другой код в том же файле (будьте последовательны). Если это не решит проблему, рассмотрите возможность подражания другим файлам в том же каталоге.</p><p>При создании новых файлов <em>должен</em> использоваться стиль Google, независимо от того, какой стиль выбран для других файлов в том же пакете. При добавлении нового кода в файл, не использующий стиль Google, рекомендуется сначала переформатировать существующий код, с учетом советов, приведенных <a href="#%D0%BF%D0%B5%D1%80%D0%B5%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%89%D0%B5%D0%B3%D0%BE-%D0%BA%D0%BE%D0%B4%D0%B0">ниже</a>. Если переформатирование не проводится, тогда новый код <em>рекомендуется</em> делать как можно более единообразным с уже существующим кодом в том же файле, но при этом он <em>не должен</em> нарушать руководство по стилю.</p><h4 id="%D0%BF%D0%B5%D1%80%D0%B5%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%89%D0%B5%D0%B3%D0%BE-%D0%BA%D0%BE%D0%B4%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%B5%D1%80%D0%B5%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%89%D0%B5%D0%B3%D0%BE-%D0%BA%D0%BE%D0%B4%D0%B0"><span>Переформатирование существующего кода</span></a></h4><p>Иногда вы будете сталкиваться с файлами в кодовой базе, которые не соответствуют стилю Google. Они могли появиться в результате приобретения или были написаны до того, как для стиля Google была сформирована конкретная позицию по какому-либо вопросу, или же они могут быть в стиле, отличном от Google, по какой-либо другой причине.</p><p>При обновлении стиля существующего кода следуйте этим рекомендациям:</p><ul><li>Не требуется изменять весь существующий код, чтобы соответствовать текущим рекомендациям по стилю. Переформатирование существующего кода — это компромисс между переписыванием кода и единообразием. Правила стиля со временем меняются и подобные изменения для поддержания соответствия могут привести к ненужной перекодировке. Однако если в файл вносятся существенные изменения, ожидается, что файл будет в стиле Google.</li><li>Будьте осторожны, чтобы не допустить, чтобы исправление кода на новый стиль мешало фокусироваться на основном коде. Если вы обнаружили, что вносите много стилевых изменений, которые не являются критичными, делайте эти изменения в отдельных файлах или участках кода.</li></ul><h3 id="%D1%83%D1%81%D1%82%D0%B0%D1%80%D0%B5%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" tabindex="-1"><a class="header-anchor" href="#%D1%83%D1%81%D1%82%D0%B0%D1%80%D0%B5%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"><span>Устаревание</span></a></h3><p>Пометьте устаревшие методы, классы или интерфейсы JSDoc аннотацией <code>@deprecated</code>. Комментарий об устаревании должен содержать простые и ясные для людей указания по исправлению их мест вызова.</p><h3 id="%D1%81%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BA%D0%BE%D0%B4%3A-%D0%B2-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D0%BE%D0%BC-%D0%B1%D0%B5%D0%B7-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BA%D0%BE%D0%B4%3A-%D0%B2-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D0%BE%D0%BC-%D0%B1%D0%B5%D0%B7-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB"><span>Сгенерированный код: в основном без правил</span></a></h3><p>Исходный код, генерируемый в процессе сборки, не обязательно должен быть в стиле Google. Однако, любые сгенерированные идентификаторы, на которые будут ссылаться из вручную написанного исходного кода, должны соответствовать требованиям к именованию. В качестве особого исключения, такие идентификаторы могут содержать подчеркивания, что может помочь избежать конфликтов с написанными вручную идентификаторами.</p><h3 id="%D1%86%D0%B5%D0%BB%D0%B8-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%B0-%D0%BF%D0%BE-%D1%81%D1%82%D0%B8%D0%BB%D1%8E" tabindex="-1"><a class="header-anchor" href="#%D1%86%D0%B5%D0%BB%D0%B8-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%B0-%D0%BF%D0%BE-%D1%81%D1%82%D0%B8%D0%BB%D1%8E"><span>Цели руководства по стилю</span></a></h3><p>В основном, инженеры обычно лучше знают, что необходимо в их коде, поэтому если есть несколько вариантов и выбор зависит от ситуации, мы должны позволить принимать решения на месте. Поэтому рекомендуемым ответом по умолчанию здесь является &quot;оставить это как есть&quot;.</p><p>Следующие пункты являются теми исключительными моментами, на основании которых мы имеем некоторые всеобщие правила. Оцените ваше предложение по составлению руководства по стилю с учетом следующего:</p><ol><li><p><strong>В коде рекомендуется избегать шаблонов, которые известны как вызывающие проблемы, особенно для пользователей, только начинающих изучать язык.</strong></p></li><li><p><strong>Код в различных проектах рекомендуется разрабатывать единообразно, с учетом незначительных отклонений.</strong></p><p>Когда есть два варианта, которые эквивалентны в поверхностном смысле, стоит рассмотреть возможность выбора одного из них, просто чтобы не развивались расхождения без причины и избежать бессмысленных дебатов в обзорах кода.</p><p>Примеры:</p><ul><li>Стиль написания имен с использованием заглавных букв.</li><li><code>x as T</code> синтаксис по сравнению с эквивалентным синтаксисом <code>&lt;T&gt;x</code> (запрещено).</li><li><code>Array&lt;[number, number]&gt;</code> по сравнению с <code>[number, number][]</code>.</li></ul></li><li><p><strong>Код рекомендуется писать так, чтобы он был поддерживаемым в долгосрочной перспективе.</strong></p><p>Код обычно живет дольше, чем над ним работает его автор и команда специалистов по TypeScript должна обеспечить работоспособность всего кода Google в будущем.</p><p>Примеры:</p><ul><li>Мы используем программы для автоматизации изменений в коде, поэтому код автоматически форматируется, чтобы программа легко соблюдала правила оформления пробельных символов.</li><li>Мы предъявляем требования к единому набору флагов компиляции, поэтому конкретная библиотека TS может быть написана с учетом определенного набора флагов, и пользователи всегда могут безопасно использовать разделяемые библиотеки.</li><li>Код должен импортировать библиотеки, которые он использует (strict deps - строгие зависимости), чтобы рефакторинг в какой-либо зависимости не изменил зависимости его пользователей.</li><li>Мы просим пользователей писать тесты. Без тестов мы не можем быть уверены, что изменения, которые вносятся в язык, не нарушат работу пользователей.</li></ul></li><li><p><strong>Рецензенты кода должны быть сосредоточены на улучшении качества кода, а не на соблюдении произвольных правил.</strong></p><p>Часто хорошим знаком считается, если есть возможность реализовать ваше правило в качестве автоматической проверки. Это также способствует принципу №3.</p><p>Если это действительно не имеет большого значения — если это не совсем понятная часть языка или если это позволяет избежать ошибки, которая вряд ли возникнет — вероятно, это стоит оставить без изменений.</p></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Прим. пер.: В оригинале используются термины <em>MUST</em> и <em>SHOULD</em> которые зачастую переводят буквально как <em>должен</em>. При этом MUST носит <em>обязательный характер</em>, а <em>SHOULD</em> - <em>рекомендательный</em>. Т.к. в русском языке такие термины, как: &quot;<em>должен</em>&quot;, &quot;<em>обязан</em>&quot;, &quot;<em>стоит</em>&quot;, &quot;<em>необходимо</em>&quot; многими воспринимаются как имеющими строго обязательный характер, при буквальном переводе это может ввести в заблуждение. Поэтому для большего понимания эти термины были адаптированы как:</p><ul><li><em>ДОЛЖЕН</em> | <em>НЕ ДОЛЖЕН</em> - носят строго обязательный характер;</li><li><em>РЕКОМЕНДУЕТСЯ</em> | <em>НЕ РЕКОМЕНДУЕТСЯ</em> - являются настойчивой рекомендацией, но тем не менее не имеют обязательного характера;</li><li><em>ВОЗМОЖНО</em> - обозначают допустимый вариант.</li></ul><p>Такая адаптация вполне совместима с оригинальным стандартом <a href="https://tools.ietf.org/html/rfc2119">RFC 2119</a> и не нарушает его. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>Прим. пер.: В JSDoc для указания информации о лицензии используется тег <code>@license</code>, а для информации об авторских правах тег <code>@copyright</code>. <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>Прим. пер.: В примере комментария представлен классический условный текст-заполнитель (текст-&quot;заглушка&quot;, текст-&quot;рыба&quot;) <a href="https://en.wikipedia.org/wiki/Lorem_ipsum">&quot;Lorem ipsum dolor sit amet, consectetur...&quot;</a>, который не несет в себе никакой смысловой нагрузки и часто используется для простой имитации какого-либо текстового содержимого. <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>Импорт пространства имен часто называют &quot;импортом модуля&quot;. <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>Именованные импорты иногда называют &quot;деструктурирующими импортами&quot;, поскольку они используют синтаксис, аналогичный деструктурирующим присваиваниям. <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p>Прим. пер.: Данный тема связана с использованием технологии Protocol Buffers (https://github.com/protocolbuffers/protobuf) <a href="#fnref6" class="footnote-backref">↩︎</a></p></li><li id="fn7" class="footnote-item"><p>Прим. пер.: Аннотация <code>@nocollapse</code> используется в Google Closure Compiler. Подробнее с этим вы можете ознакомиться тут: <a href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler#nocollapse">https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler#nocollapse</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p></li><li id="fn8" class="footnote-item"><p>Прим. пер.: В блоке оператора <code>switch</code> непустые группы операторов <code>case</code> не допускаются к проваливанию компилятором при активной опции <code>noFallthroughCasesInSwitch</code>. Подробнее вы можете ознакомиться тут: <a href="https://www.typescriptlang.org/tsconfig#noFallthroughCasesInSwitch">https://www.typescriptlang.org/tsconfig#noFallthroughCasesInSwitch</a>. <a href="#fnref8" class="footnote-backref">↩︎</a></p></li><li id="fn9" class="footnote-item"><p>Прим. пер.: В TypeScript 5.0 появился функционал декораторов, который доступен по умолчанию и имеет несколько отличий от ранее существовавших экспериментальных декораторов. С отличиями вы можете ознакомиться тут: <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#differences-with-experimental-legacy-decorators">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#differences-with-experimental-legacy-decorators</a>. <a href="#fnref9" class="footnote-backref">↩︎</a></p></li><li id="fn10" class="footnote-item"><p>Automatic Semicolon Insertion (ASI) — с англ. переводится как &quot;автоматическая вставка точки с запятой&quot;. <a href="#fnref10" class="footnote-backref">↩︎</a></p></li><li id="fn11" class="footnote-item"><p>Прим. пер.: Такое соглашение было популяризовано <a href="https://cycle.js.org/basic-examples.html#basic-examples-increment-a-counter-what-is-the-convention">Cycle.js</a> и также применяется в <a href="https://angular.io/guide/rx-library#naming-conventions-for-observables">Angular</a>. <a href="#fnref11" class="footnote-backref">↩︎</a></p></li><li id="fn12" class="footnote-item"><p>Google Code Search - проект поисковой системы по исходному коду программ, позволяющий использовать в поисковых запросах регулярные выражения. Репозиторий проекта размещен по адресу: <a href="https://github.com/google/codesearch">https://github.com/google/codesearch</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p></li><li id="fn13" class="footnote-item"><p>Прим. пер.: google3 - название основного внутреннего монорепозитория Google. Подробнее: <a href="https://opensource.google/documentation/reference/glossary#google3">https://opensource.google/documentation/reference/glossary#google3</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p></li><li id="fn14" class="footnote-item"><p>Прим. пер.: Данная проблема под названием &quot;return-only generics&quot; обсуждалась в <a href="https://github.com/microsoft/TypeScript/issues/33272">issue к TypeScript</a>. На странице <a href="https://effectivetypescript.com/2020/08/12/generics-golden-rule/">https://effectivetypescript.com/2020/08/12/generics-golden-rule/</a> хорошо поясняется суть этой проблемы на примере кода:</p><pre><code class="language-ts"><span class="hljs-keyword">function</span> parseYAML&lt;T&gt;(<span class="hljs-attr">input</span>: <span class="hljs-built_in">string</span>): T {
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Weight</span> {
  <span class="hljs-attr">pounds</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">ounces</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">w</span>: <span class="hljs-title class_">Weight</span> = <span class="hljs-title function_">parseYAML</span>(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// возвращаемый тип - any!</span>
</code></pre><p>На примере, функция <code>parseYAML</code> неявно возвращает тип <code>any</code>, но при этом нигде явно не указано ключевое слово <code>any</code>, что может сбить с толку и привести к нежелательным последствиям. <a href="#fnref14" class="footnote-backref">↩︎</a></p></li><li id="fn15" class="footnote-item"><p>Прим. пер.: В данном контексте в понятие &quot;<em>Соответствие</em>&quot; (<em>Conformance</em>) разработчиками из Google заложен особый смысл. См. подробнее на странице <a href="https://developer.chrome.com/blog/conformance">https://developer.chrome.com/blog/conformance</a>. <a href="#fnref15" class="footnote-backref">↩︎</a></p></li></ol></section></div></body></html>