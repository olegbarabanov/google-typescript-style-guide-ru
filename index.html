<html lang="ru" data-color-mode="auto" data-light-theme="light" data-dark-theme="dark_dimmed"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>Руководство Google по стилю написания кода на языке TypeScript (перевод)</title><link rel="icon" href="favicon.ico"><script defer="defer" src="main.js"></script><link href="main.css" rel="stylesheet"></head><body class="d-flex flex-column height-full"><header class="header p-1 p-md-2 p-lg-3 d-flex flex-items-center flex-justify-between flex-nowrap flex-shrink-0"><div class="f3-mktg text-bold mx-2 text-left text-sm-center"><a class="title-link">Руководство Google по стилю написания кода на языке TypeScript (перевод)</a></div><div class="d-flex flex-nowrap mx-2"><details class="details-reset details-overlay"><summary><div class="btn d-flex flex-items-center flex-row flex-nowrap"><svg height="16" viewBox="0 0 16 16" version="1.1" width="16" fill="currentColor"><path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path></svg> <span class="ml-2 d-none d-md-inline">Содержание</span></div></summary><div class="selectmenu right-0"><div class="selectmenu-modal"><nav class="selectmenu-list"></nav></div></div></details></div></header><div class="markdown-body p-5 overflow-auto mt-1"><h1 id="%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-google-%D0%BF%D0%BE-%D1%81%D1%82%D0%B8%D0%BB%D1%8E-%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA%D0%BE%D0%B4%D0%B0-%D0%BD%D0%B0-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5-typescript-(%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%B0-%22google-typescript-style-guide%22)" tabindex="-1"><a class="header-anchor" href="#%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-google-%D0%BF%D0%BE-%D1%81%D1%82%D0%B8%D0%BB%D1%8E-%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA%D0%BE%D0%B4%D0%B0-%D0%BD%D0%B0-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5-typescript-(%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%B0-%22google-typescript-style-guide%22)"><span>Руководство Google по стилю написания кода на языке TypeScript (перевод руководства &quot;Google TypeScript Style Guide&quot;)</span></a></h1><h2 id="%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4%D1%83" tabindex="-1"><a class="header-anchor" href="#%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4%D1%83"><span>Дополнительная информация по переводу</span></a></h2><p>Репозиторий текущего перевода расположен по адресу: <a href="https://github.com/olegbarabanov/google-typescript-style-guide-ru">https://github.com/olegbarabanov/google-typescript-style-guide-ru</a>.</p><p>С оригинальным руководством по стилю вы можете ознакомиться по адресу: <a href="https://google.github.io/styleguide/tsguide.html">https://google.github.io/styleguide/tsguide.html</a>.</p><p>Перевод основан на следующей версии оригинального руководства: <a href="https://github.com/google/styleguide/blob/1faa779a126c3564e74d6254d596da8dd2b4bf56/tsguide.html">https://github.com/google/styleguide/blob/1faa779a126c3564e74d6254d596da8dd2b4bf56/tsguide.html</a>.</p><p>Хотя данный перевод и стремится быть максимально соответствующим оригинальному тексту, в текст перевода были добавлены сноски на комментарии и примечания переводчика, которые дополняют или разъясняют суть конкретного выражения. Также подобные сноски присутствуют в местах исправления <em>явных</em> ошибок, которые присутствовали в оригинале и которые могли бы ввести в заблуждение.</p><p>Если Вы нашли несоответствие, ошибку или неточность в переводе, вы можете оформить это в виде <em><a href="https://github.com/olegbarabanov/google-typescript-style-guide-ru/issues">issue</a></em> или предложить собственное исправление в виде <em><a href="https://github.com/olegbarabanov/google-typescript-style-guide-ru/pulls">pull request</a></em> в репозиторий проекта, либо написать переводчику по адресу <a href="mailto:mail@olegbarabanov.ru">mail@olegbarabanov.ru</a>.</p><h2 id="%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5" tabindex="-1"><a class="header-anchor" href="#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5"><span>Введение</span></a></h2><p>Это внешнее руководство, основанное на внутренней версии Google, но адаптированное для более широкой аудитории. Для этой версии руководства не существует какого-либо механизма автоматического развертывания, поскольку она предоставляется волонтерами в ответ на запросы пользователей. В нем содержатся как правила, так и лучшие практики. Выберите те, которые лучше всего подходят для вашей команды.</p><p>Данное руководство ссылается на терминологию стандарта <a href="https://tools.ietf.org/html/rfc2119">RFC 2119</a> при использовании фраз <em>ДОЛЖНЫ</em>, <em>НЕ ДОЛЖНЫ</em>, <em>РЕКОМЕНДУЕТСЯ</em>, <em>НЕ РЕКОМЕНДУЕТСЯ</em> и <em>ВОЗМОЖНО</em> <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>. Все приведенные примеры не носят нормативного характера и служат лишь для иллюстрации стандартных формулировок из данного руководства по стилю.</p><h2 id="%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81"><span>Синтаксис</span></a></h2><h3 id="%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D1%8B"><span>Идентификаторы</span></a></h3><p>Идентификаторы должны использовать только ASCII символы, цифры, символы подчеркивания (для констант и названий методов структурных тестов) и знак <code>$</code>. Таким образом, каждое допустимое имя идентификатора соответствует регулярному выражению <code>[$\w]+</code><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</p><table><thead><tr><th>Стиль</th><th>Категория</th></tr></thead><tbody><tr><td><code>UpperCamelCase</code></td><td>класс / интерфейс / тип / перечисление / декоратор / параметр типа</td></tr><tr><td><code>lowerCamelCase</code></td><td>переменная / параметр / функция / метод / свойство / псевдонимы модулей</td></tr><tr><td><code>CONSTANT_CASE</code></td><td>глобальные константы, включая имена элементов перечислений (<code>enum</code>)</td></tr><tr><td><code>#ident</code></td><td>подобные приватные идентификаторы не применяются</td></tr></tbody></table><ul><li><p><strong>Аббревиатуры</strong>: Рассматривайте используемые в именах аббревиатуры типа акронимов как целые слова, т.е. используйте <code>loadHttpUrl</code>, а не <code>loadHTTPURL</code>, если только это не обусловлено названием конкретной платформы (например <code>XMLHttpRequest</code>).</p></li><li><p><strong>Знак доллара</strong>: В идентификаторах, как правило, не рекомендуется использовать символ <code>$</code>, за исключением случаев, когда это соответствуют соглашениям об именовании для сторонних фреймворков. Подробнее об использовании суффикса <code>$</code> для наблюдаемых (<code>Observable</code>) значений <a href="#%D1%81%D1%82%D0%B8%D0%BB%D1%8C-%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">см. ниже</a>.</p></li><li><p><strong>Параметры типа</strong>: Параметры типов, как например в <code>Array&lt;T&gt;</code>, могут использовать один символ верхнего регистра (<code>T</code>) или <code>UpperCamelCase</code>.</p></li><li><p><strong>Названия тестов</strong>: Название тестовых методов в Closure <code>testSuite</code> и подобных тестовых фреймворках в стиле xUnit могут быть представлены с разделителями <code>_</code>, например <code>testX_whenY_doesZ()</code>.</p></li><li><p><code>_</code> <strong>префикс/суффикс</strong>: Идентификаторы не должны использовать <code>_</code> в качестве префикса или суффикса.<br>Это также означает что символ <code>_</code> сам по себе не должен быть использован в качестве идентификатора (например, чтобы указать, что параметр не используется).</p><blockquote><p>Совет: Если вам нужны только некоторые элементы из массива (или TypeScript кортежа), вы можете вставить дополнительные запятые в выражение деструктуризации, чтобы игнорировать промежуточные элементы:</p></blockquote><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> [a, , b] = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>];  <span class="hljs-comment">// a &lt;- 1, b &lt;- 10</span>
</code></pre></li><li><p><strong>Импорты</strong>: Импорты пространств имен модулей имеют верблюжий регистр (<code>lowerCamelCase</code>) в то время как файлы имеют змеиный регистр (<code>snake_case</code>), что означает, что корректные импорты не будут совпадать по стилю написания. Например:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fooBar <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo_bar&#x27;</span>;
</code></pre><p>Некоторые библиотеки могут широко использовать префиксы для импорта пространств имен, которые противоречат этой схеме именования, но их обширное использование в решениях с открытым исходным кодом делает этот нарушающий стиль более понятным. Единственными библиотеками, которые в настоящее время подпадают под это исключение, являются:</p><ul><li><a href="https://jquery.com">jquery</a>, использует <code>$</code> как префикс;</li><li><a href="https://threejs.org">threejs</a>, использует <code>THREE</code> как префикс.</li></ul></li><li><p><strong>Константы</strong>: <code>CONSTANT_CASE</code> указывает на то, что значение <em>не предназначено</em> для изменений и может быть использовано для тех значений, что могут быть изменены технически (т.е. значений, которые не являются глубоко замороженными), но не должны изменяться пользователями.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">UNIT_SUFFIXES</span> = {
  <span class="hljs-string">&#x27;milliseconds&#x27;</span>: <span class="hljs-string">&#x27;ms&#x27;</span>,
  <span class="hljs-string">&#x27;seconds&#x27;</span>: <span class="hljs-string">&#x27;s&#x27;</span>,
};
<span class="hljs-comment">// Несмотря на то, что в соответствии с правилами JavaScript UNIT_SUFFIXES является изменяемым,</span>
<span class="hljs-comment">// верхний регистр символов обозначает для пользователей, что они не должны изменять значения.</span>
</code></pre><p>Константой также может быть статическое свойство класса, которое предназначенно только для чтения (<code>static readonly</code>).</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-variable constant_">MY_SPECIAL_NUMBER</span> = <span class="hljs-number">5</span>;

  <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-title class_">Foo</span>.<span class="hljs-property">MY_SPECIAL_NUMBER</span>;
  }
}
</code></pre><p>Если во время работы программы значение создается более одного раза или если пользователи каким-либо образом изменяют его, то для этого должен использоваться <code>lowerCamelCase</code> стиль.</p><p>Если значение представляет собой стрелочную функцию которая реализует интерфейс, тогда это может быть объявлено в <code>lowerCamelCase</code> стиле.</p></li></ul><h4 id="%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC%D1%8B"><span>Псевдонимы</span></a></h4><p>При создании локального псевдонима существующего элемента, используйте формат уже существующего его обозначения. Локальный псевдоним должен совпадать с существующим именем и форматом источника. Для переменных при создании локальных псевдонимов используйте <code>const</code>, а для полей класса - атрибут <code>readonly</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> {<span class="hljs-title class_">Foo</span>} = <span class="hljs-title class_">SomeType</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CAPACITY</span> = <span class="hljs-number">5</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teapot</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-title class_">BrewStateEnum</span> = <span class="hljs-title class_">BrewStateEnum</span>;
  <span class="hljs-keyword">readonly</span> <span class="hljs-variable constant_">CAPACITY</span> = <span class="hljs-variable constant_">CAPACITY</span>;
}
</code></pre><h4 id="%D1%81%D1%82%D0%B8%D0%BB%D1%8C-%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" tabindex="-1"><a class="header-anchor" href="#%D1%81%D1%82%D0%B8%D0%BB%D1%8C-%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F"><span>Стиль именования</span></a></h4><p>TypeScript отражает информацию в типах, поэтому имена <em>не рекомендуется</em> дополнять информацией, которая включена в тип (см. также <a href="https://testing.googleblog.com/2017/10/code-health-identifiernamingpostforworl.html">Блог о тестировании (Testing Blog)</a> для получения дополнительной информации о том, что не следует включать).</p><p>Несколько конкретных примеров для этого правила:</p><ul><li>Не используйте начальные или завершащие символы подчеркивания для приватных свойств или методов.</li><li>Не используйте префикс <code>opt_</code> для необязательных параметров.<ul><li>Для аксессоров, см. ниже <a href="#%D0%B3%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B-%D0%B8-%D1%81%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B-%D0%B0%D0%BA%D1%81%D0%B5%D1%81%D1%81%D0%BE%D1%80%D1%8B">правила использования аксессоров</a>.</li></ul></li><li>Не стоит специально помечать интерфейсы (<s><code>IMyInterface</code></s> или <s><code>MyFooInterface</code></s>), если только они не идиоматичны в своей среде. Когда вы вводите интерфейс для класса, дайте ему имя, которое выражает причину существования интерфейса (например, <code>class TodoItem</code> и <code>interface TodoItemStorage</code> если интерфейс выражает формат, используемый для хранения/сериализации в JSON).</li><li>Добавление к наблюдаемым элементам (<code>Observable</code>) суффикса <code>$</code> является распространенным внешним соглашением<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> и может помочь устранить путаницу между наблюдаемыми и конкретными значениями. Решение о том, является ли это полезным соглашением, остается на усмотрение отдельных команд, но <em>рекомендуется</em>, чтобы оно было согласованным в рамках проектов.</li></ul><h4 id="%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F"><span>Описательные названия</span></a></h4><p>Названия <em>должны</em> быть описательными и ясными для новых читателей. Не используйте аббревиатуры, которые могут быть незнакомыми или двусмысленными для читателей за пределами вашего проекта и не сокращайте, удаляя в словах буквы.</p><ul><li><strong>Исключение</strong>: Для переменных, область действия которых составляет не более 10 строк, включая аргументы, которые <em>не</em> являются частью экспортируемого API, <em>возможно</em> использование коротких (например, однобуквенных) имен переменных.</li></ul><h3 id="%D0%BA%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%3A-utf-8" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%3A-utf-8"><span>Кодировка файлов: UTF-8</span></a></h3><p>Для символов, отличных от ASCII, используйте фактический символ Юникода (например <code>∞</code>). Для непечатаемых символов можно использовать эквивалентный шестнадцатеричный код или экранирование Unicode-символов (например <code>\u221e</code>) вместе с пояснительным комментарием.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Совершенно ясно даже без комментария</span>
<span class="hljs-keyword">const</span> units = <span class="hljs-string">&#x27;μs&#x27;</span>;

<span class="hljs-comment">// Используйте Unicode-экранирование для непечатаемых символов</span>
<span class="hljs-keyword">const</span> output = <span class="hljs-string">&#x27;\ufeff&#x27;</span> + content; <span class="hljs-comment">// это маркер последовательности байтов (Unicode BOM)</span>
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Даже с комментарием, это сложно для чтения и подвержено потенциальным ошибкам.</span>
<span class="hljs-keyword">const</span> units = <span class="hljs-string">&#x27;\u03bcs&#x27;</span>; <span class="hljs-comment">// Греческая буква mu, &#x27;s&#x27;</span>

<span class="hljs-comment">// Читающий код не поймет, что это такое</span>
<span class="hljs-keyword">const</span> output = <span class="hljs-string">&#x27;\ufeff&#x27;</span> + content;
</code></pre><h3 id="%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%26-%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%26-%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F"><span>Комментарии &amp; Документация</span></a></h3><h4 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-jsdoc-%D0%B2-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B8-%D1%81-%D0%BE%D0%B1%D1%8B%D1%87%D0%BD%D1%8B%D0%BC%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D1%8F%D0%BC%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-jsdoc-%D0%B2-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B8-%D1%81-%D0%BE%D0%B1%D1%8B%D1%87%D0%BD%D1%8B%D0%BC%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D1%8F%D0%BC%D0%B8"><span>Использование JSDoc в сравнении с обычными комментариями</span></a></h4><p>Существует два типа комментариев, JSDoc (<code>/** ... */</code>) и не относящиеся к JSDoc обычные комментарии (<code>// ...</code> или <code>/* ... */</code>).</p><ul><li>Используйте <code>/** JSDoc */</code> комментарии для документации. Это те комментарии, с которыми стоит ознакомиться при использовании кода.</li><li>Используйте <code>// строчные комментарии</code> для комментирования реализации. Эти комментарии которые касаются только реализации самого кода.</li></ul><p>Комментарии JSDoc могут распознаваться различными инструментальными программами, такими как редакторы кода и генераторы документации, в то время как обычные комментарии могут быть распознаны только другими людьми.</p><h4 id="%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-jsdoc-%D1%81%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%82-%D1%81%D1%82%D0%B8%D0%BB%D1%8E-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0-javascript" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-jsdoc-%D1%81%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%82-%D1%81%D1%82%D0%B8%D0%BB%D1%8E-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0-javascript"><span>Правила JSDoc соответствуют стилю языка JavaScript</span></a></h4><p>В общих чертах, следуйте <a href="https://google.github.io/styleguide/jsguide.html#jsdoc">правилам для JSDoc из руководства по стилю написания JavaScript</a><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>, разделы 7.1 - 7.5. В остальной части этого раздела описываются исключения из этих правил.</p><h4 id="%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2%D1%81%D0%B5%D1%85-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2-%D0%B2%D0%B5%D1%80%D1%85%D0%BD%D0%B5%D0%B3%D0%BE-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D1%8F-%D0%B2-%D1%81%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%B5-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%B9" tabindex="-1"><a class="header-anchor" href="#%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2%D1%81%D0%B5%D1%85-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2-%D0%B2%D0%B5%D1%80%D1%85%D0%BD%D0%B5%D0%B3%D0%BE-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D1%8F-%D0%B2-%D1%81%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%B5-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%B9"><span>Документирование всех экспортов верхнего уровня в составе модулей</span></a></h4><p>Используйте <code>/** JSDoc */</code> комментарии для передачи информации пользователям вашего кода. Избегайте простого повторения имени свойства или параметра. Вам <em>рекомендуется</em> документировать все свойства и методы (экспортируемые/публичные или нет), назначение которых, по мнению вашего рецензента, не сразу очевидно из их названия.</p><p>Исключение: элементы, которые экспортируются только для использования инструментальными программами, например классы @NgModule, не требуют комментариев.</p><h4 id="%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B8%D1%82%D0%B5-%D1%82%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8%2C-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B8%D0%B7%D0%BB%D0%B8%D1%88%D0%BD%D0%B8-%D0%B2-typescript" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B8%D1%82%D0%B5-%D1%82%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8%2C-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B8%D0%B7%D0%BB%D0%B8%D1%88%D0%BD%D0%B8-%D0%B2-typescript"><span>Исключите те комментарии, которые излишни в TypeScript</span></a></h4><p>Для примера, не указывайте типы в <code>@param</code> или <code>@return</code> блоках, не пишите <code>@implements</code>, <code>@enum</code>, <code>@private</code> в коде, который использует <code>implements</code>, <code>enum</code>, <code>private</code> и пр. ключевые слова.</p><h4 id="%D0%BD%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%40override" tabindex="-1"><a class="header-anchor" href="#%D0%BD%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%40override"><span>Не используйте <code>@override</code></span></a></h4><p>Не используйте <code>@override</code> в исходном коде TypeScript<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>.</p><p><code>@override</code> не применяется компилятором, что может стать неожиданным сюрпризом и привести к несогласованности аннотаций и реализации. Использование <code>@override</code> только для документирования может привести к путанице.</p><h4 id="%D0%B4%D0%B5%D0%BB%D0%B0%D0%B9%D1%82%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8%2C-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE-%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E%D1%82-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8E" tabindex="-1"><a class="header-anchor" href="#%D0%B4%D0%B5%D0%BB%D0%B0%D0%B9%D1%82%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8%2C-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE-%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E%D1%82-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8E"><span>Делайте комментарии, которые действительно добавляют информацию</span></a></h4><p>Для неэкспортируемых элементов иногда достаточно имени и типа функции или параметра. Хотя код <em>обычно</em> выигрывает от большего документирования, чем просто имена переменных!</p><ul><li>Избегайте комментариев в которых просто повторяется имя и тип параметра.<pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">/** <span class="hljs-doctag">@param</span> fooBarService Сервис &quot;The Bar&quot; для приложения &quot;the Foo&quot;. */</span>
</code></pre></li><li>Исходя из этого правила, строки <code>@param</code> и <code>@return</code> требуются только тогда, когда они добавляют новую информацию, а иначе их можно исключить.<pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/**
 * Отправляет POST-запрос для начала варки кофе.
 * <span class="hljs-doctag">@param</span> amountLitres Количество для заваривания. Должно соответствовать размеру емкости!
 */</span>
<span class="hljs-title function_">brew</span>(<span class="hljs-params">amountLitres: <span class="hljs-built_in">number</span>, logger: Logger</span>) {
  <span class="hljs-comment">// ...</span>
}
</code></pre></li></ul><h4 id="%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%BA-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%D0%BC" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%BA-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%D0%BC"><span>Комментарии к параметризованным свойствам</span></a></h4><p>Параметризованное свойство — это когда класс объявляет поле и параметр конструктора в одном объявлении путем пометки параметра как свойства в конструкторе. Например <code>constructor(private readonly foo: Foo)</code> объявляет, что класс имеет поле <code>foo</code>.</p><p>Чтобы задокументировать эти поля, используйте JSDoc <code>@param</code> аннотацию. Редакторы отображают описание при вызовах конструктора и доступе к свойствам.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/** Этот класс демонстрирует, как документируются параметризованные свойства. */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ParamProps</span> {
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> percolator Кофеварка, используемая для варки.
   * <span class="hljs-doctag">@param</span> beans Зерна для варки.
   */</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> percolator: Percolator,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> beans: CoffeeBean[]</span>) {}
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/** Этот класс демонстрирует, как документируются обычные поля. */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">OrdinaryClass</span> {
  <span class="hljs-comment">/** Кофейные зерна, которые будут использоваться в следующем вызове brew(). */</span>
  <span class="hljs-attr">nextBean</span>: <span class="hljs-title class_">CoffeeBean</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">initialBean: CoffeeBean</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextBean</span> = initialBean;
  }
}
</code></pre><h4 id="%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%BF%D1%80%D0%B8-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%BF%D1%80%D0%B8-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8"><span>Комментарии при вызове функции</span></a></h4><p>При необходимости, документируйте параметры в местах вызова при помощи встраивания блочных комментариев. Также рассмотрите возможность применения именованных параметров с использованием объектного литерала и деструктуризации. При этом нет каких-либо четких правил касательно точного форматирования и размещения комментария.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Встраивание блочных комментариев для параметров, которые трудны для понимания:</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Percolator</span>().<span class="hljs-title function_">brew</span>(<span class="hljs-comment">/* amountLitres= */</span> <span class="hljs-number">5</span>);
<span class="hljs-comment">// Также рассмотрите возможность использования именованных аргументов и деструктуризации параметров (в объявлении метода &quot;brew&quot;):</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Percolator</span>().<span class="hljs-title function_">brew</span>({<span class="hljs-attr">amountLitres</span>: <span class="hljs-number">5</span>});
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/** Перколятор, как старый вариант кофеварки {<span class="hljs-doctag">@link</span> CoffeeBrewer} */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Percolator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CoffeeBrewer</span> {
  <span class="hljs-comment">/**
   * Сварить кофе.
   * <span class="hljs-doctag">@param</span> amountLitres Количество, которое надо сварить. Должно соответствовать объему кофейника!
   */</span>
  <span class="hljs-title function_">brew</span>(<span class="hljs-params">amountLitres: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-comment">// Так или иначе, эта реализация создает ужасный кофе.</span>
    <span class="hljs-comment">// TODO(b/12345): Улучшить процесс варки кофе в кофеварке.</span>
  }
}
</code></pre><h4 id="%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%89%D0%B0%D0%B9%D1%82%D0%B5-%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8E-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0%D0%BC%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%89%D0%B0%D0%B9%D1%82%D0%B5-%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8E-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0%D0%BC%D0%B8"><span>Размещайте документацию перед декораторами</span></a></h4><p>Когда класс, метод или свойство имеют и декораторы вида <code>@Component</code> и JSDoc, убедитесь, что JSDoc написан перед декоратором.</p><ul><li>Не пишите JSDoc между декоратором и декорируемым выражением.<pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,
})
<span class="hljs-comment">/** Компонент, который выводит &quot;bar&quot;. */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FooComponent</span> {}
</code></pre></li><li>Пишите блок с JSDoc перед декоратором.<pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/** Компонент, который выводит &quot;bar&quot;. */</span>
<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FooComponent</span> {}
</code></pre></li></ul><h2 id="%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0"><span>Языковые правила</span></a></h2><h3 id="%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C" tabindex="-1"><a class="header-anchor" href="#%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C"><span>Видимость</span></a></h3><p>Ограничение видимости свойств, методов и целых типов помогает сохранить код слабо связанным.</p><ul><li>Максимально ограничивайте область видимости обозначений.</li><li>Рассмотрите возможность преобразования приватных методов в неэкспортируемые функции в том же файле, но вне какого-либо класса, а также перемещение приватных свойств в отдельные, неэкспортируемые классы.</li><li>В TypeScript все обозначения по умолчанию публичные. Никогда не используйте модификатор <code>public</code>, за исключением случаев объявления доступных для чтения и записи (т.е. не <code>readonly</code>) публичных параметризованных свойств (в конструкторе).</li></ul><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">public</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>();  <span class="hljs-comment">// ПЛОХО: нет необходимости в модификаторе &quot;public&quot;</span>

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> baz: Baz</span>) {}  <span class="hljs-comment">// ПЛОХО: модификатор &quot;readonly&quot; подразумевает, что это свойство имеет по умолчанию модификатор &quot;public&quot;</span>
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  bar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>();  <span class="hljs-comment">// ХОРОШО: нет необходимости в модификаторе &quot;public&quot;</span>

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> baz: Baz</span>) {}  <span class="hljs-comment">// допускается модификатор &quot;public&quot;</span>
}
</code></pre><p>См. также <a href="#%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D1%85-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2">Область видимости экспортируемых элементов</a> ниже.</p><h3 id="%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80%D1%8B"><span>Конструкторы</span></a></h3><p>При вызове конструктора всегда должны использоваться скобки, даже если никакие аргументы не передаются:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();
</code></pre><p>Нет необходимости предоставлять пустой конструктор или конструктор, который просто делегирует в родительский класс, поскольку ES2015 предоставляет конструктор класса по умолчанию, если он не указан. Однако не следует убирать конструкторы с параметризованными свойствами, модификаторами или декораторами параметров, даже если тело конструктора пустое.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UnnecessaryConstructor</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UnnecessaryConstructorOverride</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Base</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value: <span class="hljs-built_in">number</span></span>) {
      <span class="hljs-variable language_">super</span>(value);
    }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultConstructor</span> {
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ParameterProperties</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> myService</span>) {}
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ParameterDecorators</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@SideEffectDecorator</span> myService</span>) {}
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">NoInstantiation</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}
}
</code></pre><h3 id="%D1%87%D0%BB%D0%B5%D0%BD%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D1%87%D0%BB%D0%B5%D0%BD%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0"><span>Члены класса</span></a></h3><h4 id="%D0%BD%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B0%D1%82%D0%BD%D1%8B%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8F-%D0%B2%D0%B8%D0%B4%D0%B0-%23private" tabindex="-1"><a class="header-anchor" href="#%D0%BD%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B0%D1%82%D0%BD%D1%8B%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8F-%D0%B2%D0%B8%D0%B4%D0%B0-%23private"><span>Не используйте приватные поля вида <code>#private</code></span></a></h4><p>Не используйте приватные поля (также известные как приватные идентификаторы):</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Clazz</span> {
  #ident = <span class="hljs-number">1</span>;
}
</code></pre><p>Вместо этого используйте поддерживаемые TypeScript аннотации видимости:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Clazz</span> {
  <span class="hljs-keyword">private</span> ident = <span class="hljs-number">1</span>;
}
</code></pre><blockquote><p>Почему?</p><p>Приватные идентификаторы вызывают существенные проблемы с размером и производительностью при понижении версии стандарта ECMAScript, в которую будет скомпилирован код TypeScript и не поддерживаются до ES2015. Они могут быть понижены только до уровня ES2015, но не ниже. В то же время, они не дают существенных преимуществ, когда для контроля области видимости используется статическая проверка типов.</p></blockquote><h4 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80-readonly" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80-readonly"><span>Используйте модификатор <code>readonly</code></span></a></h4><p>Пометьте модификатором <code>readonly</code> те свойства, которые никогда не переназначаются вне конструктора (они не обязательно должны быть глубоко неизменяемыми).</p><h4 id="%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0"><span>Параметризованные свойства</span></a></h4><p>Вместо того чтобы просто передавать очевидный инициализатор в член класса, используйте <a href="#%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0">параметризованные свойства</a> TypeScript.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">barService</span>: <span class="hljs-title class_">BarService</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">barService: BarService</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">barService</span> = barService;
  }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> barService: BarService</span>) {}
}
</code></pre><p>Если параметризованное свойство нуждается в документировании, то <a href="#%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%BA-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%D0%BC">используйте JSDoc тег <code>@param</code></a>.</p><h4 id="%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BF%D0%BE%D0%BB%D0%B5%D0%B9" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BF%D0%BE%D0%BB%D0%B5%D0%B9"><span>Инициализаторы полей</span></a></h4><p>Если элемент класса не является параметризованным свойством, инициализируйте его там, где он объявлен, что иногда позволяет совсем отбросить конструктор.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">userList</span>: <span class="hljs-built_in">string</span>[];
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">userList</span> = [];
  }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">userList</span>: <span class="hljs-built_in">string</span>[] = [];
}
</code></pre><h4 id="%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%2C-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D0%BC%D1%8B%D0%B5-%D0%B7%D0%B0-%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B0%D0%BC%D0%B8-%D0%BB%D0%B5%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B9-%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%2C-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D0%BC%D1%8B%D0%B5-%D0%B7%D0%B0-%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B0%D0%BC%D0%B8-%D0%BB%D0%B5%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B9-%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0"><span>Свойства, используемые за пределами лексической области класса</span></a></h4><p>Для свойств, так или иначе задействованных вне лексической области видимости содержащего их класса, например, для свойств контроллера AngularJS используемых из шаблона, не должна использоваться приватная (<code>private</code>) область видимости, т.к. к этим свойствам потребуется доступ за пределами лексической области видимости их класса.</p><p>Для этих свойств предпочтительна публичная (<code>public</code>) видимость, однако при необходимости можно использовать и защищенную (<code>protected</code>) видимость. Например, для свойств используемых в шаблонах Angular и Polymer следует использовать <code>public</code>, а в AngularJS - <code>protected</code>.</p><p>В TypeScript коде не должны использоваться <code>obj['foo']</code> для обхода ограничения видимости свойства.</p><blockquote><p>Почему?</p><p>Когда свойство является приватным (<code>private</code>), вы объявляете автоматизированным системам и людям, что доступ к свойству ограничен методами объявленного класса, и они будут полагаться на это. Например, проверка на неиспользуемый код отметит приватное свойство, которое может посчитаться неиспользуемым, даже если какому-то коду из другого файла удастся обойти ограничение видимости.</p><p>Хотя может показаться, что <code>obj['foo']</code> может обойти область видимости в компиляторе TypeScript, эта схема может быть нарушена путем изменения правил сборки, а также нарушается согласованность с оптимизациями.</p></blockquote><h4 id="%D0%B3%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B-%D0%B8-%D1%81%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B-(%D0%B0%D0%BA%D1%81%D0%B5%D1%81%D1%81%D0%BE%D1%80%D1%8B)" tabindex="-1"><a class="header-anchor" href="#%D0%B3%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B-%D0%B8-%D1%81%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B-(%D0%B0%D0%BA%D1%81%D0%B5%D1%81%D1%81%D0%BE%D1%80%D1%8B)"><span>Геттеры и Сеттеры (Аксессоры)</span></a></h4><p>Для членов класса можно иcпользовать геттеры и сеттеры. Методы-геттеры должны быть <a href="https://en.wikipedia.org/wiki/Pure_function">чистыми функциями</a> (т.е. не иметь побочных эффектов и каждый раз возвращать одинаковый результат при одних и тех же параметрах). Они также полезны как средство ограничения видимости внутренних или подробных деталей реализации (показано ниже).</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> someService: SomeService</span>) {}

  <span class="hljs-keyword">get</span> <span class="hljs-title function_">someMember</span>(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">someService</span>.<span class="hljs-property">someVariable</span>;
  }

  <span class="hljs-keyword">set</span> <span class="hljs-title function_">someMember</span>(<span class="hljs-params">newValue: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">someService</span>.<span class="hljs-property">someVariable</span> = newValue;
  }
}
</code></pre><p>Если аксессор используется для сокрытия свойства класса, скрытое свойство может иметь префикс или суффикс с любым целым словом, например <code>internal</code> или <code>wrapped</code>. При использовании этих приватных свойств по возможности обращайтесь к их значению через аксессор. По крайней мере один аксессор к свойству должен быть нетривиальным: не определяйте сквозные аксессоры только для того, чтобы скрыть свойство. Вместо этого сделайте свойство публичным (или подумайте о том, чтобы сделать его доступным только для чтения (<code>readonly</code>), чем просто определять геттер без сеттера).</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">private</span> wrappedBar = <span class="hljs-string">&#x27;&#x27;</span>;
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">bar</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">wrappedBar</span> || <span class="hljs-string">&#x27;bar&#x27;</span>;
  }

  <span class="hljs-keyword">set</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">wrapped: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">wrappedBar</span> = wrapped.<span class="hljs-title function_">trim</span>();
  }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> {
  <span class="hljs-keyword">private</span> barInternal = <span class="hljs-string">&#x27;&#x27;</span>;
  <span class="hljs-comment">// Ни один из этих аксессоров не имеет логики, поэтому просто сделайте bar публичным</span>
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">bar</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">barInternal</span>;
  }

  <span class="hljs-keyword">set</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">barInternal</span> = value;
  }
}
</code></pre><h3 id="%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-%26-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%BE%D0%B1%D0%B5%D1%80%D1%82%D0%BA%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-%26-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%BE%D0%B1%D0%B5%D1%80%D1%82%D0%BA%D0%B8"><span>Примитивные типы &amp; Классы-обертки</span></a></h3><p>Код TypeScript не должен создавать экземпляры классов-оберток для примитивных типов <code>String</code>, <code>Boolean</code> и <code>Number</code>. Классы-обертки имеют удивляющее поведение, такое как <code>new Boolean(false)</code> равное <code>true</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);
<span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">false</span>);
<span class="hljs-keyword">const</span> n = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">5</span>);
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> s = <span class="hljs-string">&#x27;hello&#x27;</span>;
<span class="hljs-keyword">const</span> b = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">const</span> n = <span class="hljs-number">5</span>;
</code></pre><h3 id="%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0"><span>Конструктор массива</span></a></h3><p>В коде на Typescript не должны использоваться <code>Array()</code> конструкторы, с или без <code>new</code>. Его применение неоднозначно и сбивает с толку:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// [undefined, undefined]</span>
<span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [2, 3];</span>
</code></pre><p>Вместо этого всегда используйте скобки для инициализации массивов , или <code>from</code> для инициализации <code>Array</code> с определенным размером:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> a = [<span class="hljs-number">2</span>];
<span class="hljs-keyword">const</span> b = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-comment">// Эквивалент для Array(2):</span>
<span class="hljs-keyword">const</span> c = [];
c.<span class="hljs-property">length</span> = <span class="hljs-number">2</span>;

<span class="hljs-comment">// [0, 0, 0, 0, 0]</span>
<span class="hljs-title class_">Array</span>.<span class="hljs-property">from</span>&lt;<span class="hljs-built_in">number</span>&gt;({<span class="hljs-attr">length</span>: <span class="hljs-number">5</span>}).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);
</code></pre><h3 id="%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2"><span>Преобразование типов</span></a></h3><p>В TypeScript коде можно использовать <code>String()</code> и <code>Boolean()</code> (примечание: без <code>new</code>!) функции, строковые шаблонные литералы или <code>!!</code> для преобразования типов.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> bool = <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">false</span>);
<span class="hljs-keyword">const</span> str = <span class="hljs-title class_">String</span>(aNumber);
<span class="hljs-keyword">const</span> bool2 = !!str;
<span class="hljs-keyword">const</span> str2 = <span class="hljs-string">`result: <span class="hljs-subst">${bool2}</span>`</span>;
</code></pre><p>Не приветствуется для приведения к строке использовать конкатенацию строк, так как при проверке кода мы отслеживаем, чтобы операнды оператора «плюс» имели совпадающие типы.</p><p>Код должен использовать <code>Number()</code> для парсинга числовых значений и должен явно проверять его возврат на значения <code>NaN</code>, за исключением случаев, когда из контекста точно известно, что сбой парсинга невозможен.</p><p>Примечание: <code>Number('')</code>, <code>Number(' ')</code>, и <code>Number('\t')</code> могут вернуть <code>0</code> вместо <code>NaN</code>. <code>Number('Infinity')</code> и <code>Number('-Infinity')</code> могут вернуть <code>Infinity</code> и <code>-Infinity</code> соответственно. Эти случаи могут потребовать особого обращения.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> aNumber = <span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;123&#x27;</span>);
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(aNumber)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(...);  <span class="hljs-comment">// Обрабатываем NaN, если в строке может не быть чисел</span>
<span class="hljs-title function_">assertFinite</span>(aNumber, ...);                <span class="hljs-comment">// Необязательно: если NaN не может возникнуть, потому что он был проверен ранее.</span>
</code></pre><p>В коде не должен использоваться унарный плюс (<code>+</code>) для преобразования строки в число. Парсинг чисел может привести к неудаче, иметь неожиданные исключительные ситуации и может быть признаком дурно пахнущего кода (парсинг чисел не на том уровне). Учитывая это, унарный плюс слишком легко пропустить при проверке кода.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> x = +y;
</code></pre><p>В коде также не должны использоваться <code>parseInt</code> или <code>parseFloat</code> для парсинга чисел, за исключением случаев парсинга в строках недесятичных числовых значений (см. ниже). Обе эти функции игнорируют конечные символы в строке, что может привести к возникновению ошибочного состояния (например, парсинг <code>12 гномов</code> как <code>12</code>).</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(someString, <span class="hljs-number">10</span>);  <span class="hljs-comment">// Подвержено ошибкам,</span>
<span class="hljs-keyword">const</span> f = <span class="hljs-built_in">parseFloat</span>(someString);    <span class="hljs-comment">// независимо от передачи основания системы счисления.</span>
</code></pre><p>Код, который должен выполнять парсинг числа с использованием системы счисления, должен проверять, является ли его ввод числом, прежде чем вызывать <code>parseInt</code>;</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^[a-fA-F0-9]+$/</span>.<span class="hljs-title function_">test</span>(someString)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(...);
  <span class="hljs-comment">// Требуется для парсинга восьмеричного числа.</span>
<span class="hljs-comment">// tslint:disable-next-line:ban</span>
<span class="hljs-keyword">const</span> n = <span class="hljs-built_in">parseInt</span>(someString, <span class="hljs-number">16</span>);  <span class="hljs-comment">// Допустимо только для основания числа != 10</span>
</code></pre><p>Используйте <code>Number()</code>, а затем <code>Math.floor</code> или <code>Math.trunc</code> (там, где это возможно) для парсинга целых чисел:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">let</span> f = <span class="hljs-title class_">Number</span>(someString);
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(f)) <span class="hljs-title function_">handleError</span>();
f = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(f);
</code></pre><p>Не используйте явное булево преобразование в условиях, в которых уже имеется неявное булево преобразование. Это условия в операторах <code>if</code>, <code>for</code> и <code>while</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-title class_">MyInterface</span>|<span class="hljs-literal">null</span> = ...;
<span class="hljs-keyword">if</span> (!!foo) {...}
<span class="hljs-keyword">while</span> (!!foo) {...}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-title class_">MyInterface</span>|<span class="hljs-literal">null</span> = ...;
<span class="hljs-keyword">if</span> (foo) {...}
<span class="hljs-keyword">while</span> (foo) {...}
</code></pre><p>В коде можно использовать явные сравнения:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Явное сравнение &gt; 0 это хорошо:</span>
<span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {...}
<span class="hljs-comment">// так же как и полагаться на неявное булево преобразование:</span>
<span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span>) {...}
</code></pre><h3 id="%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5"><span>Переменные</span></a></h3><p>Всегда используйте <code>const</code> или <code>let</code> для объявления переменных. По умолчанию используйте <code>const</code>, если не требуется переназначение переменной. Никогда не используйте <code>var</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> foo = otherValue;  <span class="hljs-comment">// Используйте, если &quot;foo&quot; никогда не меняется.</span>
<span class="hljs-keyword">let</span> bar = someValue;     <span class="hljs-comment">// Используйте, если для &quot;bar&quot; когда-либо позднее будет присвоено значение </span>
</code></pre><p><code>const</code> и <code>let</code> имеют блочную область видимости, как и переменные в большинстве других языков. <code>var</code> в JavaScript ограничен областью действия функции, что может вызвать трудные для понимания ошибки. Не используйте его.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">var</span> foo = someValue;     <span class="hljs-comment">// Не используйте - область видимости var сложна и подвержена ошибкам.</span>
</code></pre><p>Переменные не должны использоваться до их объявления.</p><h3 id="%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-(exceptions)" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-(exceptions)"><span>Исключения (Exceptions)</span></a></h3><p>Всегда используйте <code>new Error()</code> при создании исключений вместо простого вызова <code>Error()</code>. В обоих случаях создается новый экземпляр <code>Error</code>, но использование <code>new</code> более согласуется с тем, как создаются экземпляры других объектов.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Foo is not a valid bar.&#x27;</span>);
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Foo is not a valid bar.&#x27;</span>);
</code></pre><h3 id="%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0%D0%BC" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0%D0%BC"><span>Итерация по объектам</span></a></h3><p>Итерация по объектам с помощью <code>for (... in ...)</code> подвержена вероятным ошибкам, т.к. это включает в себя все перечисляемые свойства из цепочки прототипов.</p><p>Не используйте не фильтрованные <code>for (... in ...)</code> выражения:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">in</span> someObj) {
  <span class="hljs-comment">// x может происходить от некоторого родительского прототипа!</span>
}
</code></pre><p>Либо явно отфильтруйте значения с помощью оператора <code>if</code>, либо используйте <code>for (... of Object.keys(...))</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">in</span> someObj) {
  <span class="hljs-keyword">if</span> (!someObj.<span class="hljs-title function_">hasOwnProperty</span>(x)) <span class="hljs-keyword">continue</span>;
  <span class="hljs-comment">// сейчас x был точно определен в принадлежности someObj</span>
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(someObj)) { <span class="hljs-comment">// примечание: for _of_!</span>
  <span class="hljs-comment">// сейчас x был точно определен в принадлежности someObj</span>
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(someObj)) { <span class="hljs-comment">// примечание: for _of_!</span>
  <span class="hljs-comment">// сейчас key был точно определен в принадлежности someObj</span>
}
</code></pre><h3 id="%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D0%BC" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D0%BC"><span>Итерация по массивам</span></a></h3><p>Не используйте <code>for (... in ...)</code> для итерации по массивам. Это будет контринтуитивно давать индексы массива (в виде строк!), а не значения:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">in</span> someArray) {
  <span class="hljs-comment">// x - это индекс!</span>
}
</code></pre><p>Для итерации по массивам используйте <code>for (... of someArr)</code> или обычные циклы <code>for</code> с индексами.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> someArr) {
  <span class="hljs-comment">// x - ссылается на значение из someArr</span>
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; someArr.<span class="hljs-property">length</span>; i++) {
  <span class="hljs-comment">// Если необходим индекс, то используйте явный пересчет, а иначе используйте форму for/of.</span>
  <span class="hljs-keyword">const</span> x = someArr[i];
  <span class="hljs-comment">// ...</span>
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [i, x] <span class="hljs-keyword">of</span> someArr.<span class="hljs-title function_">entries</span>()) {
  <span class="hljs-comment">// Альтернативная версия предыдущего.</span>
}
</code></pre><p>Не используйте <code>Array.prototype.forEach</code>, <code>Set.prototype.forEach</code>, и <code>Map.prototype.forEach</code>. Они усложняют отладку кода и препятствуют некоторым полезным проверкам компилятора (например, проверку достижимости).</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

someArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> {
  <span class="hljs-title function_">someFn</span>(item, index);
});
</code></pre><blockquote><p>Почему?</p><p>Рассмотрим следующий код:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>|<span class="hljs-literal">null</span> = <span class="hljs-string">&#x27;abc&#x27;</span>;
myArray.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">() =&gt;</span> { x.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>); });
</code></pre><p>Вы можете видеть, что этот код вполне в порядке: <code>x</code> не является <code>null</code> и не изменяется до обращения к нему. Но компилятор не может знать, что этот вызов <code>.forEach()</code> не привязан к переданному замыканию и не вызовет его позже, возможно, после того, как <code>x</code> будет установлен в <code>null</code>, поэтому он помечает этот код как ошибку. Эквивалентный цикл for-of работает нормально.</p><p><a href="https://www.typescriptlang.org/play?#code/DYUwLgBAHgXBDOYBOBLAdgcwD5oK7GAgF4IByAQwCMBjUgbgCgBtAXQDoAzAeyQFFzqACwAUwgJTEAfBADeDCNDZDySAIJhhABjGMAvjoYNQkAJ5xEqTDnyESFGvQbckEYdS5pEEAPoQuHCFYJOQUTJUEVdS0DXQYgA">Посмотреть в песочнице ошибочный и безошибочный варианты</a></p><p>На практике различные варианты этих ограничений анализа потока управления проявляются в более сложных путях выполнения кода, где это может быть более неожиданно.</p></blockquote><h3 id="%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-spread-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-spread-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0"><span>Применение spread-оператора</span></a></h3><p>Использование spread-оператора <code>[...foo]; {...bar}</code> является удобным сокращением для копирования массивов и объектов. При использовании spread-оператора для объектов, более поздние значения заменяют более ранние с тем же ключом.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> foo = {
  <span class="hljs-attr">num</span>: <span class="hljs-number">1</span>,
};

<span class="hljs-keyword">const</span> foo2 = {
  ...foo,
  <span class="hljs-attr">num</span>: <span class="hljs-number">5</span>,
};

<span class="hljs-keyword">const</span> foo3 = {
  <span class="hljs-attr">num</span>: <span class="hljs-number">5</span>,
  ...foo,
}

foo2.<span class="hljs-property">num</span> === <span class="hljs-number">5</span>;
foo3.<span class="hljs-property">num</span> === <span class="hljs-number">1</span>;
</code></pre><p>При использовании spread-оператора раскладываемое значение должно соответствовать создаваемому. Т.е. при создании объекта с spread-оператором можно использовать только объекты, а при создании массива раскладывайте только итерируемые объекты. Примитивы, включая <code>null</code> и <code>undefined</code>, никогда не могут быть разложены.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> foo = {<span class="hljs-attr">num</span>: <span class="hljs-number">7</span>};
<span class="hljs-keyword">const</span> bar = {<span class="hljs-attr">num</span>: <span class="hljs-number">5</span>, ...(shouldUseFoo &amp;&amp; foo)}; <span class="hljs-comment">// может быть undefined</span>

<span class="hljs-comment">// Creates {0: &#x27;a&#x27;, 1: &#x27;b&#x27;, 2: &#x27;c&#x27;} but has no length</span>
<span class="hljs-keyword">const</span> fooStrings = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];
<span class="hljs-keyword">const</span> ids = {...fooStrings};
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> foo = shouldUseFoo ? {<span class="hljs-attr">num</span>: <span class="hljs-number">7</span>} : {};
<span class="hljs-keyword">const</span> bar = {<span class="hljs-attr">num</span>: <span class="hljs-number">5</span>, ...foo};
<span class="hljs-keyword">const</span> fooStrings = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];
<span class="hljs-keyword">const</span> ids = [...fooStrings, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>];
</code></pre><h3 id="%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BC-%26-%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BC-%26-%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8"><span>Операторы управления потоком &amp; блоки</span></a></h3><p>Операторы управления потоком, охватывающие несколько строк, всегда используют блоки для размещения содержащегося в них кода.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; x; i++) {
  <span class="hljs-title function_">doSomethingWith</span>(i);
  <span class="hljs-title function_">andSomeMore</span>();
}
<span class="hljs-keyword">if</span> (x) {
  <span class="hljs-title function_">doSomethingWithALongMethodName</span>(x);
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">if</span> (x)
  x.<span class="hljs-title function_">doFoo</span>();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; x; i++)
  <span class="hljs-title function_">doSomethingWithALongMethodName</span>(i);
</code></pre><p>Исключением являются операторы <code>if</code>, которые помещаются на одной строке и могут не использовать блоки.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">if</span> (x) x.<span class="hljs-title function_">doFoo</span>();
</code></pre><h3 id="switch-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80" tabindex="-1"><a class="header-anchor" href="#switch-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80"><span>Switch оператор</span></a></h3><p>Каждый <code>switch</code> оператор должен включать в себя блок по умолчанию (<code>default</code>), даже если там не содержится кода.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">switch</span> (x) {
  <span class="hljs-keyword">case</span> <span class="hljs-attr">Y</span>:
    <span class="hljs-title function_">doSomethingElse</span>();
    <span class="hljs-keyword">break</span>;
  <span class="hljs-attr">default</span>:
    <span class="hljs-comment">// ничего не делать.</span>
}
</code></pre><p>Непустые группы операторов (<code>case ...</code>) могут не проваливаться (обеспечивается настройками компилятора<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>):</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">switch</span> (x) {
  <span class="hljs-keyword">case</span> <span class="hljs-attr">X</span>:
    <span class="hljs-title function_">doSomething</span>();
    <span class="hljs-comment">// дальнейший пропуск - не разрешен!</span>
  <span class="hljs-keyword">case</span> <span class="hljs-attr">Y</span>:
    <span class="hljs-comment">// ...</span>
}
</code></pre><p>Допускается пропуск пустых групп операторов:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">switch</span> (x) {
  <span class="hljs-keyword">case</span> <span class="hljs-attr">X</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-attr">Y</span>:
    <span class="hljs-title function_">doSomething</span>();
    <span class="hljs-keyword">break</span>;
  <span class="hljs-attr">default</span>: <span class="hljs-comment">// ничего не делать.</span>
}
</code></pre><h3 id="%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0-%D1%80%D0%B0%D0%B2%D0%B5%D0%BD%D1%81%D1%82%D0%B2%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0-%D1%80%D0%B0%D0%B2%D0%B5%D0%BD%D1%81%D1%82%D0%B2%D0%B0"><span>Проверка равенства</span></a></h3><p>Всегда используйте тройное равенство (<code>===</code>) и неравенство (<code>!==</code>). Операторы двойного равенства вызывают склонные к ошибкам приведения типов, которые трудны для понимания и работают медленнее в реализации виртуальных машин JavaScript. Смотрите также <a href="https://dorey.github.io/JavaScript-Equality-Table/">JavaScript таблицу равенства</a>.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">if</span> (foo == <span class="hljs-string">&#x27;bar&#x27;</span> || baz != bam) {
  <span class="hljs-comment">// Трудное для понимания поведение из-за преобразования типов.</span>
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">if</span> (foo === <span class="hljs-string">&#x27;bar&#x27;</span> || baz !== bam) {
  <span class="hljs-comment">// Здесь все хорошо и понятно.</span>
}
</code></pre><p><strong>Исключение</strong>: При сравнении с значением <code>null</code> можно использовать операторы <code>==</code> и <code>!=</code> для общего охвата <code>null</code> и <code>undefined</code> значений.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">if</span> (foo == <span class="hljs-literal">null</span>) {
  <span class="hljs-comment">// Будет срабатывать, когда foo равен null или undefined. </span>
}
</code></pre><h3 id="%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-(function-declaration)" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-(function-declaration)"><span>Объявление функции (Function Declaration)</span></a></h3><p>Используйте <code>function foo() { ... }</code> для объявления именованных функций, включая функции во вложенных областях, например внутри другой функции.</p><p>Используйте объявления функций вместо присваивания функционального выражения локальной переменной (<code>const x = function() {...};</code>). TypeScript уже запрещает переназначение функций, поэтому предотвращение перезаписи объявления функции с помощью <code>const</code> не требуется.</p><p><strong>Исключение</strong>: Если функция обращается к <code>this</code> внешней области видимости, вместо объявления функции используйте назначаемые переменным стрелочные функции.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) { ... }
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Учитывая приведенное выше объявление, это не будет компилироваться:</span>
foo = <span class="hljs-function">() =&gt;</span> <span class="hljs-number">3</span>;  <span class="hljs-comment">// ОШИБКА: Недопустимая левая часть выражения присваивания.</span>

<span class="hljs-comment">// Так что такие объявления излишни.</span>
<span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... }
</code></pre><p>Обратите внимание на различия между обсуждаемыми здесь объявлениями функций (<code>function foo() {}</code>) и функциональными выражениями (<code>doSomethingWith(function() {});</code>), которые обсуждаются <a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F">ниже</a>.</p><p>Стрелочные функции верхнего уровня <em>могут</em> использоваться для явного объявления того, что функция реализует интерфейс.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">SearchFunction</span> {
  (<span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">fooSearch</span>: <span class="hljs-title class_">SearchFunction</span> = <span class="hljs-function">(<span class="hljs-params">source, subString</span>) =&gt;</span> { ... };
</code></pre><h3 id="%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F" tabindex="-1"><a class="header-anchor" href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F"><span>Функциональные выражения</span></a></h3><h4 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D1%85-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9-%D0%B2-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%D1%85" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D1%85-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9-%D0%B2-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%D1%85"><span>Использование стрелочных функций в выражениях</span></a></h4><p>Всегда используйте стрелочные функции вместо функциональных выражений которые были до ES6 и задавались с помощью ключевого слова <code>function</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-title function_">bar</span>(<span class="hljs-function">() =&gt;</span> { <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">doSomething</span>(); })
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-title function_">bar</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... })
</code></pre><p>Функциональные выражения (определенные с помощью ключевого слова <code>function</code>) могут использоваться только в том случае, если код должен динамически перепривязать <code>this</code>, хотя в коде в принципе <em>не рекомендуется</em> перепривязывать <code>this</code>. В коде обычных функций (в отличие от стрелочных функций и методов) <em>не рекомендуется</em> обращаться к <code>this</code>.</p><h4 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B8%D0%BB%D0%B8-%D0%B1%D0%BB%D0%BE%D0%BA%D0%BE%D0%B2-%D0%B2-%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B5-%D1%82%D0%B5%D0%BB%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B8%D0%BB%D0%B8-%D0%B1%D0%BB%D0%BE%D0%BA%D0%BE%D0%B2-%D0%B2-%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B5-%D1%82%D0%B5%D0%BB%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8"><span>Использование выражений или блоков в качестве тела функции</span></a></h4><p>Используйте стрелочные функции с выражениями или блоками в качестве тела там, где это целесообразно.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Для объявления функции верхнего уровня используйте Function Declarations.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">someFunction</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Вполне подходит использование блочных тел стрелочных функций, т.е. у которых тело функции представляет =&gt; { } :</span>
  <span class="hljs-keyword">const</span> receipts = books.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">b: Book</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> receipt = <span class="hljs-title function_">payMoney</span>(b.<span class="hljs-property">price</span>);
    <span class="hljs-title function_">recordTransaction</span>(receipt);
    <span class="hljs-keyword">return</span> receipt;
  });

  <span class="hljs-comment">// Использование выражения в качестве тела функции тоже подходит, если возвращаемое значение будет использоваться:</span>
  <span class="hljs-keyword">const</span> longThings = myValues.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1000</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-title class_">String</span>(v));

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">payMoney</span>(<span class="hljs-params">amount: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-comment">// Function Declarations - это хорошо, но не обращайтесь к `this` в них. </span>
  }
}
</code></pre><p>Используйте выражения в качестве тела функции только в том случае, если возвращаемое значение функции действительно используется.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// ПЛОХО: используйте блочное тело функции ({ ... }) если возвращаемое значение функции не используется.</span>
myPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v));
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// ХОРОШО: возвращаемое значение не используется, поэтому применяется блочное тело функции.</span>
myPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v);
});
<span class="hljs-comment">// ХОРОШО: в коде можно использовать блочное тело функции для повышения удобочитаемости.</span>
<span class="hljs-keyword">const</span> transformed = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> intermediate = <span class="hljs-title function_">someComplicatedExpr</span>(v);
  <span class="hljs-keyword">const</span> more = <span class="hljs-title function_">acrossManyLines</span>(intermediate);
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">worthWrapping</span>(more);
});
</code></pre><h4 id="%D0%BF%D0%B5%D1%80%D0%B5%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-this" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-this"><span>Перепривязывание <code>this</code></span></a></h4><p>Функциональные выражения не должны использовать <code>this</code>, если только они не существуют специально для перепривязки <code>this</code>. В большинстве случаев перепривязки <code>this</code> можно избежать, используя стрелочные функции или явно заданные параметры.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">clickHandler</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Плохо: что такое «this» в этом контексте?</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;Hello&#x27;</span>;
}
<span class="hljs-comment">// Плохо: `this` неявно ссылается на document.body .</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">onclick</span> = clickHandler;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Хорошо: явная ссылка на объект из стрелочной функции.</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> { <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;hello&#x27;</span>; };
<span class="hljs-comment">// Альтернатива: взять явно заданный параметр</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">setTextFn</span> = (<span class="hljs-params">e: HTMLElement</span>) =&gt; { e.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;hello&#x27;</span>; };
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">onclick</span> = setTextFn.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>);
</code></pre><h4 id="%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BA%D0%B0%D0%BA-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BA%D0%B0%D0%BA-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0"><span>Стрелочные функции как свойства</span></a></h4><p>В классах обычно <em>не рекомендуется</em> содержать свойства, которые проинициализированы как стрелочные функции. Использование стрелочных функций как свойств требует чтобы вызывающая их функция корректно понимала, что у вызываемой функции уже есть привязанный <code>this</code>, что увеличивает путаницу в понимании того, что такое <code>this</code>, а сами места вызовов и ссылки использующие эти функции могут смотреться некорректно работающими (т.к. это требует дополнительных знаний об окружении за пределами локальной области вызывающей функции, чтобы определить, что они корректны). В коде <em>рекомендуется</em> всегда использовать стрелочные функции для вызова методов экземпляра (<code>const handler = (x) =&gt; { this.listener(x); };</code>) и <em>не рекомендуется</em> получать или передавать ссылки на методы экземпляра (<s><code>const handler = this.listener; handler(x);</code></s>).</p><blockquote><p>Примечание: в некоторых специфических ситуациях, например, в случае привязки функций к шаблонам, стрелочные функции в качестве свойств полезны и создают гораздо более читабельный код. Руководствуйтесь здравым смыслом при использовании этого правила. Также см. раздел <a href="#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B8-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9">Обработчики событий</a> ниже.</p></blockquote><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayHandler</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Проблема: `this` не сохраняется в функции обратного вызова. `this` в обратном вызове</span>
    <span class="hljs-comment">// не будет экземпляром DelayHandler.</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">patienceTracker</span>, <span class="hljs-number">5000</span>);
  }
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">patienceTracker</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">waitedPatiently</span> = <span class="hljs-literal">true</span>;
  }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Стрелочные функции обычно не рекомендуется задавать свойствам.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayHandler</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Плохо: этот код выглядит так, как будто тут забыли привязать `this`. </span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">patienceTracker</span>, <span class="hljs-number">5000</span>);
  }
  <span class="hljs-keyword">private</span> patienceTracker = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">waitedPatiently</span> = <span class="hljs-literal">true</span>;
  }
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Явное управление `this` во время вызова.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayHandler</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// По возможности используйте анонимные функции.</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">patienceTracker</span>();
    }, <span class="hljs-number">5000</span>);
  }
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">patienceTracker</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">waitedPatiently</span> = <span class="hljs-literal">true</span>;
  }
}
</code></pre><h4 id="%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B8-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B8-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9"><span>Обработчики событий</span></a></h4><p>Обработчики событий <em>могут</em> использовать стрелочные функции, когда нет необходимости удалять обработчик (например, если событие генерируется самим классом). Если обработчик впоследствии должен быть удален, тогда правильным подходом будет использование назначенной свойству стрелочной функции, поскольку они автоматически захватывают <code>this</code> и при этом обеспечивается постоянная ссылка на обработчик для его последующего удаления.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Обработчики событий могут быть анонимными функциями или назначенные свойствам стрелочными функциями.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> {
  <span class="hljs-title function_">onAttached</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Событие генерируется этим классом, удалять его не нужно.</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">listener</span>();
    });
    <span class="hljs-comment">// this.listener это постоянная ссылка на функцию-обработчик, которую мы позже можем удалить.</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;onbeforeunload&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">listener</span>);
  }
  <span class="hljs-title function_">onDetached</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Событие генерируется окном (window). Если мы не удалим функцию-обработчик (this.listener), то она</span>
    <span class="hljs-comment">// сохранит ссылку на `this` к которой привязана, что приведет к утечке памяти.</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;onbeforeunload&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">listener</span>);
  }
  <span class="hljs-comment">// Стрелочная функция, хранящаяся в свойстве, автоматически привязывается к `this`.</span>
  <span class="hljs-keyword">private</span> listener = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">confirm</span>(<span class="hljs-string">&#x27;Вы хотите покинуть страницу?&#x27;</span>);
  }
}
</code></pre><p>Не используйте <code>bind</code> в выражениях, которые устанавливают обработчики событий, потому что это создает временную ссылку, которую нельзя удалить.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Привязка слушателей создает временную ссылку, которая недоступна для удаления.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> {
  <span class="hljs-title function_">onAttached</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Это создает временную ссылку, которая нам не будет доступна для удаления.</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;onbeforeunload&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">listener</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));
  }
  <span class="hljs-title function_">onDetached</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// метод bind каждый раз создает новую ссылку, поэтому эта строка не делает ничего.</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;onbeforeunload&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">listener</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));
  }
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">listener</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">confirm</span>(<span class="hljs-string">&#x27;Вы хотите покинуть страницу?&#x27;</span>);
  }
}
</code></pre><h3 id="%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F-%D0%B2%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B0-%D1%82%D0%BE%D1%87%D0%BA%D0%B8-%D1%81-%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%BE%D0%B9" tabindex="-1"><a class="header-anchor" href="#%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F-%D0%B2%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B0-%D1%82%D0%BE%D1%87%D0%BA%D0%B8-%D1%81-%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%BE%D0%B9"><span>Автоматическая вставка точки с запятой</span></a></h3><p>Не следует полагаться на автоматическую вставку точки с запятой (ASI<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>). Явно завершайте все операторы с помощью точки с запятой. Это предотвращает ошибки, возникающие из-за неправильной вставки точки с запятой, а также обеспечивает совместимость с инструментами, которые имеют ограниченную поддержку ASI (например, clang-format).</p><h3 id="%40ts-ignore" tabindex="-1"><a class="header-anchor" href="#%40ts-ignore"><span>@ts-ignore</span></a></h3><p>Не используйте <code>@ts-ignore</code>. На первый взгляд кажется, что это простой способ исправить ошибку компилятора, но на практике конкретная ошибка компилятора часто вызывается более серьезной проблемой, которая может быть исправлена более явным путем.</p><p>Например, если вы используете <code>@ts-ignore</code> для подавления ошибок типизации, то будет трудно предсказать, какие типы в конечном итоге будет видеть окружающий код. Для многих ошибок типизации, полезны советы в разделе <a href="#%D1%82%D0%B8%D0%BF-any">как лучше всего использовать</a> <code>any</code>.</p><h3 id="%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%B0-(type-assertions)-%D0%B8-%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BD%D0%B5%D0%BD%D1%83%D0%BB%D0%B5%D0%B2%D0%BE%D0%B3%D0%BE-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-(non-nullability-assertions)" tabindex="-1"><a class="header-anchor" href="#%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%B0-(type-assertions)-%D0%B8-%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BD%D0%B5%D0%BD%D1%83%D0%BB%D0%B5%D0%B2%D0%BE%D0%B3%D0%BE-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-(non-nullability-assertions)"><span>Утверждения типа (Type Assertions) и утверждения ненулевого значения (Non-nullability Assertions)</span></a></h3><p>Утверждения типа (<code>x as SomeType</code>) и утверждения ненулевого значения (<code>y!</code>) не безопасны. Оба только заглушают компилятор TypeScript, но не вставляют никаких проверок во время выполнения, чтобы соответствовать этим утверждениям, поэтому они могут привести к сбою вашей программы во время выполнения.</p><p>По этой причине, вам <em>не рекомендуется</em> использовать утверждения типа и утверждения ненулевого значения без явной или объяснимой причины.</p><p>Вместо этого:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

(x <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span>).<span class="hljs-title function_">foo</span>();

y!.<span class="hljs-title function_">bar</span>();
</code></pre><p>Когда вы захотите произвести утверждение типа или утверждение ненулевого значения, то лучшим решением будет написать проверку, которая будет работать во время выполнения.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// предположим, что Foo - это класс.</span>
<span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Foo</span>) {
  x.<span class="hljs-title function_">foo</span>();
}

<span class="hljs-keyword">if</span> (y) {
  y.<span class="hljs-title function_">bar</span>();
}
</code></pre><p>Иногда из-за некоторых внутренних особенностей вашего кода вы можете быть уверены, что форма утверждения безопасна. В таких ситуациях <em>рекомендуется</em> добавить пояснение, объясняющее, почему вы согласны с небезопасным поведением:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// x это Foo, потому что ...</span>
(x <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span>).<span class="hljs-title function_">foo</span>();

<span class="hljs-comment">// y не может быть null, потому что ...</span>
y!.<span class="hljs-title function_">bar</span>();
</code></pre><p>Комментарии могут не потребоваться, если очевидны причины, лежащие в основе применения утверждения типа или утверждения ненулевого значения. Например, сгенерированный код-прототип всегда допускает значение <code>null</code>, но, возможно, в контексте кода хорошо известно, что определенные поля всегда предоставляются серверной частью. В таком случае, принимайте решение руководствуясь своим профессиональным видением.</p><h4 id="%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81-%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81-%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%B0"><span>Синтаксис утверждения типа</span></a></h4><p>Утверждения типа должны использовать синтаксис <code>as</code> (в отличие от синтаксиса угловых скобок). Это позволяет заключить утверждение в круглые скобки при обращении к элементу.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> x = (&lt;<span class="hljs-title class_">Foo</span>&gt;z).<span class="hljs-property">length</span>;
<span class="hljs-keyword">const</span> y = &lt;<span class="hljs-title class_">Foo</span>&gt;z.<span class="hljs-property">length</span>;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> x = (z <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span>).<span class="hljs-property">length</span>;
</code></pre><h4 id="%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-%26-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-%26-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B5-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B"><span>Утверждение типа &amp; объектные литералы</span></a></h4><p>Используйте аннотации типа (<code>: Foo</code>) вместо утверждения типа (<code>as Foo</code>) для указания типа объектного литерала. Это позволяет обнаружить ошибки рефакторинга, когда поля интерфейса меняются со временем.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-attr">bar</span>: <span class="hljs-built_in">number</span>;
  baz?: <span class="hljs-built_in">string</span>;  <span class="hljs-comment">// был &quot;bam&quot;, но позднее был переименован в &quot;baz&quot;.</span>
}

<span class="hljs-keyword">const</span> foo = {
  <span class="hljs-attr">bar</span>: <span class="hljs-number">123</span>,
  <span class="hljs-attr">bam</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,  <span class="hljs-comment">// нет ошибки!</span>
} <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">bar</span>: <span class="hljs-number">123</span>,
    <span class="hljs-attr">bam</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,  <span class="hljs-comment">// нет ошибки!</span>
  } <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span>;
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-attr">bar</span>: <span class="hljs-built_in">number</span>;
  baz?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-title class_">Foo</span> = {
  <span class="hljs-attr">bar</span>: <span class="hljs-number">123</span>,
  <span class="hljs-attr">bam</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,  <span class="hljs-comment">// жалуется на то, что &quot;bam&quot; не был объявлен в Foo.</span>
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">bar</span>: <span class="hljs-number">123</span>,
    <span class="hljs-attr">bam</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,  <span class="hljs-comment">// жалуется на то, что &quot;bam&quot; не был объявлен в Foo.</span>
  };
}
</code></pre><h3 id="%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2"><span>Объявление свойств элементов</span></a></h3><p>В объявлениях интерфейсов и классов, для разделения объявлений отдельных членов, необходимо использовать символ <code>;</code></p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-attr">memberA</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">memberB</span>: <span class="hljs-built_in">number</span>;
}
</code></pre><p>Интерфейсы специально не должны использовать символ <code>,</code> для разделения полей, поскольку это необходимо для симметричности с объявлениями классов:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-attr">memberA</span>: <span class="hljs-built_in">string</span>,
  <span class="hljs-attr">memberB</span>: <span class="hljs-built_in">number</span>,
}
</code></pre><p>Встраиваемое объявление объектного типа в качестве разделителя должно использовать запятую:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">type</span> <span class="hljs-title class_">SomeTypeAlias</span> = {
  <span class="hljs-attr">memberA</span>: <span class="hljs-built_in">string</span>,
  <span class="hljs-attr">memberB</span>: <span class="hljs-built_in">number</span>,
};

<span class="hljs-keyword">let</span> <span class="hljs-attr">someProperty</span>: {<span class="hljs-attr">memberC</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">memberD</span>: <span class="hljs-built_in">number</span>};
</code></pre><h4 id="%D1%81%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D1%81-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%D0%BC%D0%B8-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0-%D0%BA-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%D0%BC" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D1%81-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%D0%BC%D0%B8-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0-%D0%BA-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%D0%BC"><span>Совместимость с оптимизациями доступа к свойствам</span></a></h4><p>Код не должен смешивать доступ к свойству в кавычках с доступом к свойству через точку</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Плохо: код должен использовать либо доступ без кавычек, либо доступ в кавычках для любого свойства</span>
<span class="hljs-comment">// единообразно для всего приложения:</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x[<span class="hljs-string">&#x27;someField&#x27;</span>]);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x.<span class="hljs-property">someField</span>);
</code></pre><p>Код должен не полагаться на отключение переименования, а должен объявить все свойства, которые являются внешними по отношению к приложению, чтобы предотвратить переименование.</p><p>Предусмотрите, чтобы в коде учитывалось потенциальное переименование свойств при оптимизации и объявляйте все свойства, которые являются внешними по отношению к приложению, чтобы предотвратить переименование:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Хорошо: объявление интерфейса</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ServerInfoJson</span> {
  <span class="hljs-attr">appVersion</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">user</span>: <span class="hljs-title class_">UserJson</span>;
}
<span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(serverResponse) <span class="hljs-keyword">as</span> <span class="hljs-title class_">ServerInfoJson</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">appVersion</span>); <span class="hljs-comment">// Тип защищен и переименование безопасно!</span>
</code></pre><h4 id="%D1%81%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D1%81-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%D0%BC%D0%B8-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D0%B0-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8F" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D1%81-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%D0%BC%D0%B8-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D0%B0-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8F"><span>Совместимость с оптимизациями импорта объектов модуля</span></a></h4><p>При импорте объекта модуля напрямую обращайтесь к свойствам объекта модуля, а не передавайте его. Это гарантирует, что модули могут быть проанализированы и оптимизированы. Отношение к <a href="#%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%B8-%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B9-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D1%8B">импорту модулей</a> как к пространствам имен является нормальным.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">import</span> {method1, method2} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;utils&#x27;</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">readonly</span> utils = {method1, method2};
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> utils <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;utils&#x27;</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">readonly</span> utils = utils;
}
</code></pre><h4 id="%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5"><span>Исключение</span></a></h4><p>Это правило согласованности с оптимизациями применимо ко всем веб-приложениям. Оно не применяется к коду, который выполняется только на стороне сервера (например, в NodeJS для выполнения тестов). Но все же для поддержания чистоты кода очень поощряется всегда объявлять все типы и избегать смешивания доступа к свойствам с кавычками и без кавычек.</p><h3 id="%D0%BF%D0%B5%D1%80%D0%B5%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-(enums)" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%B5%D1%80%D0%B5%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-(enums)"><span>Перечисления (Enums)</span></a></h3><p>Всегда используйте <code>enum</code>, а не <code>const enum</code>. В TypeScript перечисления и так не могут быть изменены, а <code>const enum</code> - это отдельная особенность языка, связанная с оптимизацией, которая делает перечисление невидимым для пользователей JavaScript модуля.</p><h3 id="%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-%D0%BE%D1%82%D0%BB%D0%B0%D0%B4%D1%87%D0%B8%D0%BA%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-%D0%BE%D1%82%D0%BB%D0%B0%D0%B4%D1%87%D0%B8%D0%BA%D0%B0"><span>Команды отладчика</span></a></h3><p>Команды отладчика (наподобие <code>debugger;</code>) не должны включаться в рабочий код.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">debugMe</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">debugger</span>;
}
</code></pre><h3 id="%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B"><span>Декораторы</span></a></h3><p>Декораторы обозначаются с помощью префикса <code>@</code>, например <code>@MyDecorator</code>.</p><p>Не определяйте новых декораторов. Используйте только те декораторы, которые определены фреймворками:</p><ul><li>Angular (например: <code>@Component</code>, <code>@NgModule</code> и т.д.);</li><li>Polymer (например: <code>@property</code>).</li></ul><blockquote><p>Почему?</p><p>В основном мы предпочитаем избегать декораторов, поскольку они были экспериментальной функцией, которая с тех пор отклонилась от предложения TC39 и имеет известные ошибки, которые вряд ли будут исправлены.</p></blockquote><p>При использовании декораторов, декоратор должен непосредственно предшествовать элементу, к которому он применяется, без пустых строк между ними:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">/** Комментарии JSDoc идут перед декораторами */</span>
<span class="hljs-meta">@Component</span>({...})  <span class="hljs-comment">// Примечание: после декоратора не должно быть пустой строки. </span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComp</span> {
  <span class="hljs-meta">@Input</span>() <span class="hljs-attr">myField</span>: <span class="hljs-built_in">string</span>;  <span class="hljs-comment">// Декораторы полей могут находиться на одной линии... </span>

  <span class="hljs-meta">@Input</span>()
  <span class="hljs-attr">myOtherField</span>: <span class="hljs-built_in">string</span>;  <span class="hljs-comment">// ...  или переноситься.</span>
}
</code></pre><h2 id="%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BA%D0%BE%D0%B4%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BA%D0%BE%D0%B4%D0%B0"><span>Организация структуры исходного кода</span></a></h2><h3 id="%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B8"><span>Модули</span></a></h3><h4 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%83%D1%82%D0%B5%D0%B9-%D0%B2-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D0%B0%D1%85" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%83%D1%82%D0%B5%D0%B9-%D0%B2-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D0%B0%D1%85"><span>Использование путей в импортах</span></a></h4><p>В TypeScript коде обязательно должны указываться пути при импорте другого TypeScript кода. Пути могут быть относительными, т.е. начинаться с <code>.</code> или <code>..</code> или начинаться с базовой директории, например <code>root/path/to/file</code>.</p><p>В коде <em>рекомендуется</em> использовать относительные импорты (<code>./foo</code>) вместо абсолютных импортов <code>path/to/foo</code> при ссылке на файлы в пределах одного и того же (в логическом смысле) проекта.</p><p>Рассмотрите возможность ограничения количества родительских шагов (<code>../../../</code>), т.к. это может затруднить понимание структуры модулей и путей.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">import</span> {<span class="hljs-title class_">Symbol1</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;google3/path/from/root&#x27;</span>;
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">Symbol2</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../parent/file&#x27;</span>;
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">Symbol3</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./sibling&#x27;</span>;
</code></pre><h4 id="%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B0-%D0%B8%D0%BC%D0%B5%D0%BD-(namespace)-%26-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B0-%D0%B8%D0%BC%D0%B5%D0%BD-(namespace)-%26-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B8"><span>Пространства имен (namespace) &amp; Модули</span></a></h4><p>TypeScript поддерживает два метода организации кода: пространства имен (<em>namespaces</em>) и модули, но использование пространств имен необходимо избегать. В google3<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup> в коде должны использоваться TypeScript <em>модули</em> (которые являются <a href="http://exploringjs.com/es6/ch_modules.html">модулями ECMAScript 6</a>). Т.е. ваш код <em>должен</em> ссылаться на код в других файлах с помощью импорта и экспорта вида <code>import {foo} from 'bar';</code></p><p>В вашем коде не должны использоваться <code>namespace Foo { ... }</code> конструкции. Пространства имен (<code>namespace</code>) могут использоваться только тогда, когда это необходимо для взаимодействия с внешним сторонним кодом. Чтобы семантически разделить пространство имен вашего кода, используйте отдельные файлы.</p><p>В коде не должны использоваться <code>require</code> (как в <code>import x = require('...');</code>) для импортов. Используйте синтаксис модулей ES6.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Плохо: не используйте пространства имен:</span>
<span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Rocket</span> {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">launch</span>(<span class="hljs-params"></span>) { ... }
}

<span class="hljs-comment">// Плохо: не используйте &lt;reference&gt;</span>
<span class="hljs-comment">/// &lt;reference path=&quot;...&quot;/&gt;</span>

<span class="hljs-comment">// Плохо: не используйте require()</span>
<span class="hljs-keyword">import</span> x = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mydep&#x27;</span>);
</code></pre><blockquote><p>Примечание: В TypeScript пространства имен (<code>namespace</code>) раньше назывались внутренними модулями и использовали ключевое слово <code>module</code> в виде <code>module Foo { ... }</code>. Не используйте такую форму. Всегда используйте ES6 импорты.</p></blockquote><h3 id="%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D1%8B"><span>Экспорты</span></a></h3><p>По всему коду используйте именованные экспорты:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Использование именованного экспорта:</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> { ... }
</code></pre><p>Не используйте экспорт по умолчанию. Это гарантирует, что все импорты будут следовать единому шаблону.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Не используйте экспорт по умолчанию:</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> { ... } <span class="hljs-comment">// ПЛОХО!</span>
</code></pre><blockquote><p>Почему?</p><p>Экспорт по умолчанию не предоставляет канонического имени, что затрудняет централизованное обслуживание при относительно небольшой пользе для владельцев кода, причем возможно ухудшение читабельности:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./bar&#x27;</span>;  <span class="hljs-comment">// Валидно.</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Bar</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./bar&#x27;</span>;  <span class="hljs-comment">// Также валидно.</span>
</code></pre><p>Преимущество именованного экспорта заключается в том, что оно приводит к ошибкам, когда операторы импорта пытаются импортировать что-то, что не было объявлено. В <code>foo.ts</code>:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;blah&#x27;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> foo;
</code></pre><p>И в <code>bar.ts</code>:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">import</span> {fizz} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo&#x27;</span>;
</code></pre><p>В результате возникает ошибка <code>error TS2614: Module '&quot;./foo&quot;' has no exported member 'fizz'</code>. Если указать в <code>bar.ts</code>:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">import</span> fizz <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo&#x27;</span>;
</code></pre><p>В результате получается <code>fizz === foo</code>, что может быть неожиданным и затрудняющим отладку.</p><p>Кроме того, экспорт по умолчанию побуждает людей помещать все в один большой объект, чтобы разместить все вместе в пространстве имен:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-variable constant_">SOME_CONSTANT</span> = ...
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">someHelpfulFunction</span>(<span class="hljs-params"></span>) { ... }
  ...
}
</code></pre><p>В приведенном выше примере у нас есть область видимости файла, которая может использоваться как пространство имен. У нас также есть, возможно, ненужная вторая область видимости (класс <code>Foo</code>), которая в других файлах может двусмысленно использоваться и как тип, и как значение.</p><p>Вместо этого предпочтительно использовать файловую область видимости для пространства имен, а также именованный экспорт:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SOME_CONSTANT</span> = ...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">someHelpfulFunction</span>(<span class="hljs-params"></span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-comment">// тут только элементы класса</span>
}
</code></pre></blockquote><h4 id="%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D1%85-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D1%85-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2"><span>Область видимости экспортируемых элементов</span></a></h4><p>TypeScript не поддерживает ограничение видимости экспортируемых элементов. Экспортируйте только те элементы, которые используются вне модуля. В целом, минимизируйте экспортируемую часть API модулей.</p><h4 id="%D0%BC%D1%83%D1%82%D0%B0%D0%B1%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BC%D1%83%D1%82%D0%B0%D0%B1%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2"><span>Мутабельность экспортов</span></a></h4><p>Независимо от технической стороны, мутабельные экспорты могут создавать трудно понимаемый и отлаживаемый код, особенно при реэкспорте в различных модулях. Если по другому сформулировать это правило, то <code>export let</code> не допускается.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> foo = <span class="hljs-number">3</span>;
<span class="hljs-comment">// В чистом ES6 foo является мутабельным, и импортеры будут видеть изменение его значения уже через секунду.</span>
<span class="hljs-comment">// В TS (прим. пер.: в версии TS &lt; 3.9, при использовании модулей CommonJS), если foo реэкспортируется вторым файлом,</span>
<span class="hljs-comment">// импортеры не увидят изменения значения.</span>
<span class="hljs-comment">// Прим. пер.: В версии TS &gt;= 3.9, это будет работать по аналогии с ES6.</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  foo = <span class="hljs-number">4</span>;
}, <span class="hljs-number">1000</span> <span class="hljs-comment">/* миллисекунды */</span>);

</code></pre><p>Если необходимо поддерживать доступные извне мутабельные привязки, то вместо этого рекомендуется явно использовать функции-геттеры.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">let</span> foo = <span class="hljs-number">3</span>;
<span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  foo = <span class="hljs-number">4</span>;
}, <span class="hljs-number">1000</span> <span class="hljs-comment">/* миллисекунды */</span>);
<span class="hljs-comment">// Используйте явно заданный геттер для доступа к мутабельному экспорту.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFoo</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> foo; };
</code></pre><p>При экспорте одного из двух значений в зависимости от условий, в качестве стандартного шаблона, сначала выполняется проверка условий, а затем экспорт. Убедитесь, что все экспортируемые значения являются окончательными после выполнения всего тела модуля.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">pickApi</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">useOtherApi</span>()) <span class="hljs-keyword">return</span> <span class="hljs-title class_">OtherApi</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">RegularApi</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">SomeApi</span> = <span class="hljs-title function_">pickApi</span>();
</code></pre><h4 id="%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B"><span>Классы-контейнеры</span></a></h4><p>Не создавайте классы-контейнеры со статическими методами или свойствами ради пространства имен.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-variable constant_">FOO</span> = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; }
}
</code></pre><p>Вместо этого экспортируйте отдельные константы и функции:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FOO</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; }
</code></pre><h3 id="%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D1%8B"><span>Импорты</span></a></h3><p>В ES6 и TypeScript есть четыре варианта операторов импорта:</p><table><thead><tr><th>Вид импорта</th><th>Пример</th><th>Назначение</th></tr></thead><tbody><tr><td>модульный</td><td><code>import * as foo from '...';</code></td><td>Импорты TypeScript</td></tr><tr><td>деструктурирующий</td><td><code>import {SomeThing} from '...';</code></td><td>Импорты TypeScript</td></tr><tr><td>по умолчанию</td><td><code>import SomeThing from '...';</code></td><td>Только для поддержки стороннего кода, который их требует</td></tr><tr><td>для использования побочных эффектов</td><td><code>import '...';</code></td><td>Только для импорта библиотек ради получения их сторонних эффектов при загрузке (таких как пользовательские элементы)</td></tr></tbody></table><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Хорошо: выберите один из двух вариантов в зависимости от ситуации (см. ниже).</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ng <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">Foo</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo&#x27;</span>;

<span class="hljs-comment">// Только при необходимости: импорт по умолчанию.</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;Button&#x27;</span>;

<span class="hljs-comment">// Иногда необходимо импортировать библиотеки для получения их вспомогательных эффектов:</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;jasmine&#x27;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@polymer/paper-button&#x27;</span>;
</code></pre><h4 id="%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%B8-%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B9-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%B8-%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B9-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D1%8B"><span>Модульный и деструктурирующий импорты</span></a></h4><p>Как модульный, так и деструктурирующий импорт имеют свои преимущества в зависимости от ситуации.</p><p>Несмотря на <code>*</code>, импорт модуля не сопоставим с wildcard импортом , который встречается в других языках. Вместо этого импорт модулей дает имя всему модулю и каждой связанной с упомянутым модулем ссылке на элемент, что может сделать код более читабельным и обеспечивает функцию автоматического определения всех элементов в модуле. Они также требуют меньшего количества операций импорта (все элементы доступны), меньше коллизий имен и позволяют использовать более лаконичные имена в импортируемом модуле. Импорт модулей особенно полезен при использовании множества различных элементов из больших API.</p><p>Деструктурирующие импорты дают локальные имена для каждого импортируемого элемента. Они позволяют использовать более краткий и лаконичный код при использовании импортируемого элемента, что особенно полезно для очень часто используемых элементов, как например, <code>describe</code> и <code>it</code> в Jasmine.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Плохо: слишком длинный оператор импорта с излишними пространствами имен.</span>
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">TableViewItem</span>, <span class="hljs-title class_">TableViewHeader</span>, <span class="hljs-title class_">TableViewRow</span>, <span class="hljs-title class_">TableViewModel</span>,
  <span class="hljs-title class_">TableViewRenderer</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./tableview&#x27;</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">item</span>: <span class="hljs-title class_">TableViewItem</span> = ...;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Лучше: используйте модуль для пространства имен. </span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> tableview <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./tableview&#x27;</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">item</span>: tableview.<span class="hljs-property">Item</span> = ...;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> testing <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./testing&#x27;</span>;

<span class="hljs-comment">// Все тесты будут неоднократно использовать одни и те же три функции.</span>
<span class="hljs-comment">// При импорте только некоторых определенных элементов, которые используются очень часто, также</span>
<span class="hljs-comment">// рассмотрите возможность импорта элементов напрямую (см. пример ниже).</span>
testing.<span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  testing.<span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    testing.<span class="hljs-title function_">expect</span>(...);
    testing.<span class="hljs-title function_">expect</span>(...);
  });
});
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Лучше: дайте локальные имена распространенным функциям.</span>
<span class="hljs-keyword">import</span> {describe, it, expect} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./testing&#x27;</span>;

<span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">expect</span>(...);
    <span class="hljs-title function_">expect</span>(...);
  });
});
...
</code></pre><h4 id="%D0%BF%D0%B5%D1%80%D0%B5%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2"><span>Переименование импортов</span></a></h4><p>В коде <em>рекомендуется</em> устранить возможные конфликты имен используя импорт модулей и переименовывая сами экспорты. При необходимости в коде <em>можно</em> переименовывать импорты (<code>import {SomeThing as SomeOtherThing}</code>).</p><p>Три примера, когда переименование может быть полезным:</p><ol><li>Если необходимо избежать коллизий с другими импортируемыми элементами;</li><li>Если имя импортированного элемента генерируется;</li><li>При импорте элементов, имена которых сами по себе неясны, переименование может улучшить ясность кода. Например, при использовании RxJS функция <code>from</code> может быть более удобочитаемой, если ее переименовать в <code>observableFrom</code>.</li></ol><h4 id="%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D1%8B-%26-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D1%8B-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D1%8B-%26-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82%D1%8B-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2"><span>Импорты &amp; экспорты типов</span></a></h4><p>Не используйте <code>import type ... from</code> или <code>export type ... from</code>.</p><p>Примечание: это не относится к экспорту определений типов, т.е. <code>export type Foo = ...;</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {<span class="hljs-title class_">Foo</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo&#x27;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> {<span class="hljs-title class_">Bar</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./bar&#x27;</span>;
</code></pre><p>Вместо этого просто используйте обычный импорт:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">import</span> {<span class="hljs-title class_">Foo</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo&#x27;</span>;
<span class="hljs-keyword">export</span> {<span class="hljs-title class_">Bar</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./bar&#x27;</span>;
</code></pre><p>Инструментарий TypeScript автоматически различает элементы, используемые как типы, и элементы, используемые как значения, и только для последних генерируется загружаемый во время выполнения код.</p><blockquote><p>Почему?</p><p>Инструментарий TypeScript автоматически определяет различия и не внедряет динамическую (runtime) загрузку для обращений к типам. Это обеспечивает более удобный UX для разработчиков: переключение туда-сюда между <code>import type</code> и <code>import</code> весьма утомительно. В то же время, <code>import type</code> не дает никаких гарантий: ваш код все равно может иметь жесткую зависимость от какого-либо импорта через различные транзитивные пути.</p><p>Если вам необходима обязательная динамическая (runtime) загрузка для получения сторонних эффектов, используйте <code>import '...';</code>. См. <a href="#%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D1%8B">импорты</a>.</p><p><code>export type</code> может показаться полезным, чтобы избежать какого-либо экспортирования значения элемента в API. Однако и это не дает гарантий, т.к. последующий код может по-прежнему импортировать API другим путем. Лучший способ для разделения и гарантии использования API по типу и значению - разделить элементы, например, на <code>UserService</code> и <code>AjaxUserService</code>. Это менее подвержено ошибкам и лучше передает смысл.</p></blockquote><h3 id="%D1%84%D0%BE%D1%80%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%BC%D1%83-%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8E" tabindex="-1"><a class="header-anchor" href="#%D1%84%D0%BE%D1%80%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%BC%D1%83-%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8E"><span>Формирование по функциональному назначению</span></a></h3><p>Формируйте пакеты по их функциональному назначению, а не по типам. Например, для интернет-магазина <em>рекомендуется</em> иметь пакеты с названиями <code>products</code>, <code>checkout</code>, <code>backend</code>, а не <s><code>views</code></s>, <s><code>models</code></s>, <s><code>controllers</code></s>.</p><h2 id="%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2"><span>Система типов</span></a></h2><h3 id="%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D1%82%D0%B8%D0%BF%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D1%82%D0%B8%D0%BF%D0%B0"><span>Вывод типа</span></a></h3><p>Код может полагаться на вывод типа, реализуемый компилятором TypeScript для всех типов выражений (переменных, полей класса, возвращаемых типов и т.д.). Флаги компилятора в google3 позволяют не допускать код, который не имеет аннотации типа и тип при этом не может быть выведен, поэтому весь код гарантированно является типизированным (но может явно использовать тип <code>any</code>).</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> x = <span class="hljs-number">15</span>;  <span class="hljs-comment">// Тип выведен.</span>
</code></pre><p>Не указывайте типы для тривиально выводимых типов: переменных или параметров, инициализированных строковыми (<code>string</code>), числовыми (<code>number</code>), логическими (<code>boolean</code>) литералами, литералами регулярных выражений (<code>RegExp</code>) или выражением <code>new</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// Плохо: &#x27;boolean&#x27; здесь не способствует удобочитаемости</span>
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Плохо: &#x27;Set&#x27; тривиально выводится из инициализации</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;();
</code></pre><p>Для более сложных выражений, аннотации типов могут улучшить читабельность программы. Необходимость аннотации определяется рецензентом кода.</p><h4 id="%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B"><span>Возвращаемые типы</span></a></h4><p>Вопрос о том, следует ли включать аннотации типа возвращаемого значения для функций и методов, зависит от автора кода. Рецензенты <em>могут</em> запросить аннотации для уточнения сложных типов возвращаемых данных, которые трудно понять. В проектах <em>может</em> существовать локальная политика, согласно которой всегда требуется указывать возвращаемые типы, но это не является общим требованием стиля TypeScript.</p><p>Явная типизация неявных возвращаемых значений функций и методов имеет два преимущества:</p><ul><li>Более точная документация для повышения удобства чтения кода.</li><li>Быстрее выявляются потенциальные ошибки типизации в будущем, когда в код вносятся изменения, которые приводят к изменению возвращаемого типа функции.</li></ul><h3 id="null-%26-undefined" tabindex="-1"><a class="header-anchor" href="#null-%26-undefined"><span>Null &amp; Undefined</span></a></h3><p>TypeScript поддерживает типы <code>null</code> и <code>undefined</code>. Nullable-типы могут быть созданы как union-типы (<code>string|null</code>), что также относится и к <code>undefined</code>. Специального синтаксиса для объединений с <code>null</code> и <code>undefined</code> не существует.</p><p>В TypeScript коде для обозначения отсутствия значения можно использовать <code>undefined</code> или <code>null</code>, при этом нет общих рекомендаций для предпочтения одного другому. Множество JavaScript API используют <code>undefined</code> (например, <code>Map.get</code>), в то время как во многих DOM API и Google API используется <code>null</code> (например, <code>Element.getAttribute</code>), поэтому подходящее обозначение отсутствия значения зависит от контекста.</p><h4 id="nullable%2Fundefined-%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC%D1%8B-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#nullable%2Fundefined-%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC%D1%8B-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2"><span>Nullable/undefined псевдонимы типов</span></a></h4><p>Псевдонимы типов <em>не должны</em> включать <code>|null</code> или <code>|undefined</code> в union-тип. Псевдонимы, допускающие значение <code>null</code>, обычно указывают на то, что значения <code>null</code> проходят через слишком много слоев приложения и это затуманивает источник исходной проблемы, которая привела к значению <code>null</code>. Они также делают неясной ситуацию, когда конкретные значения в классе или интерфейсе могут отсутствовать.</p><p>Вместо этого код <em>должен</em> добавлять <code>|null</code> или <code>|undefined</code> только тогда, когда псевдоним фактически используется. В коде <em>рекомендуется</em> работать с <code>null</code> в непосредственной близости от места их возникновения, используя вышеуказанные приемы.</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-comment">// Плохо</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">CoffeeResponse</span> = <span class="hljs-title class_">Latte</span>|<span class="hljs-title class_">Americano</span>|<span class="hljs-literal">undefined</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeService</span> {
  <span class="hljs-title function_">getLatte</span>(): <span class="hljs-title class_">CoffeeResponse</span> { ... };
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Лучше</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">CoffeeResponse</span> = <span class="hljs-title class_">Latte</span>|<span class="hljs-title class_">Americano</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeService</span> {
  <span class="hljs-title function_">getLatte</span>(): <span class="hljs-title class_">CoffeeResponse</span>|<span class="hljs-literal">undefined</span> { ... };
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Наилучший вариант</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">CoffeeResponse</span> = <span class="hljs-title class_">Latte</span>|<span class="hljs-title class_">Americano</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeService</span> {
  <span class="hljs-title function_">getLatte</span>(): <span class="hljs-title class_">CoffeeResponse</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">assert</span>(<span class="hljs-title function_">fetchResponse</span>(), <span class="hljs-string">&#x27;Кофеварка сломана, подайте заявку&#x27;</span>);
  };
}
</code></pre><h4 id="%D0%BE%D0%BF%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0-%26-%D1%82%D0%B8%D0%BF-%7Cundefined" tabindex="-1"><a class="header-anchor" href="#%D0%BE%D0%BF%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0-%26-%D1%82%D0%B8%D0%BF-%7Cundefined"><span>Опциональные свойства &amp; тип <code>|undefined</code></span></a></h4><p>Также TypeScript поддерживает специальную конструкцию для опциональных параметров и полей, используя <code>?</code>:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">CoffeeOrder</span> {
  <span class="hljs-attr">sugarCubes</span>: <span class="hljs-built_in">number</span>;
  milk?: <span class="hljs-title class_">Whole</span>|<span class="hljs-title class_">LowFat</span>|<span class="hljs-title class_">HalfHalf</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">pourCoffee</span>(<span class="hljs-params">volume?: Milliliter</span>) { ... }
</code></pre><p>Опциональные параметры неявно включают <code>|undefined</code> в свой тип. Однако они отличаются тем, что их можно не указывать при составлении выражения или вызове метода. Например, <code>{sugarCubes: 1}</code> является валидным <code>CoffeeOrder</code> поскольку <code>milk</code> является опциональным.</p><p>Используйте опциональные поля (в интерфейсах или классах) и параметры вместо <code>|undefined</code> типов.</p><p>Для классов лучше вообще избегать этого приёма и инициализировать как можно больше полей.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  field = <span class="hljs-string">&#x27;&#x27;</span>;
}
</code></pre><h3 id="%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%B0%D1%8F-%26-%D0%BD%D0%BE%D0%BC%D0%B8%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F" tabindex="-1"><a class="header-anchor" href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%B0%D1%8F-%26-%D0%BD%D0%BE%D0%BC%D0%B8%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F"><span>Структурная &amp; номинальная типизация</span></a></h3><p>Система типов TypeScript является структурной, а не номинальной. Т.е. значение соответствует типу, если оно имеет, по крайней мере, все требуемые типом свойства и типы свойств совпадают рекурсивно.</p><p>Используйте структурную типизацию в коде там, где это уместно. Вне тестов для определения структурных типов используйте интерфейсы, а не классы. В тестовом коде может быть полезно иметь Mock-объекты, структурно соответствующие тестируемому коду, без введения дополнительного интерфейса.</p><p>При предоставлении реализации, основанной на структуре, явно указывайте тип в объявлении элемента (это позволяет более точно проверить тип и сообщить об ошибке).</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-title class_">Foo</span> = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">123</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> badFoo = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">123</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,
}
</code></pre><blockquote><p>Почему?</p><p>Приведенный выше объект <code>badFoo</code> полагается на вывод типа. В <code>badFoo</code> могут быть добавлены дополнительные поля, а тип будет выводиться на основе самого объекта.</p><p>При передаче <code>badFoo</code> в функцию, которая принимает <code>Foo</code>, ошибка будет возникать на месте вызова функции, а не на месте объявления объекта. Это также существенно при изменении описания интерфейса в обширной кодовой базе.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">sound</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">makeSound</span>(<span class="hljs-params">animal: Animal</span>) {}

<span class="hljs-comment">/**
 * &#x27;cat&#x27; имеет выводимый тип &#x27;{sound: string}&#x27;
 */</span>
<span class="hljs-keyword">const</span> cat = {
  <span class="hljs-attr">sound</span>: <span class="hljs-string">&#x27;meow&#x27;</span>,
};

<span class="hljs-comment">/**
 * &#x27;cat&#x27; не соответствует требуемому для функции типу,
 * поэтому компилятор TypeScript выдает ошибку здесь,
 * что может быть очень далеко от места определения &#x27;cat&#x27;.
 */</span>
<span class="hljs-title function_">makeSound</span>(cat);

<span class="hljs-comment">/**
 * Horse имеет структурный тип, и ошибка типа возникает здесь, а не в вызове функции,
 * поскольку &#x27;horse&#x27; не соответствует требованиям типа &#x27;Animal&#x27;
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">horse</span>: <span class="hljs-title class_">Animal</span> = {
  <span class="hljs-attr">sound</span>: <span class="hljs-string">&#x27;niegh&#x27;</span>,
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">dog</span>: <span class="hljs-title class_">Animal</span> = {
  <span class="hljs-attr">sound</span>: <span class="hljs-string">&#x27;bark&#x27;</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;MrPickles&#x27;</span>,
};

<span class="hljs-title function_">makeSound</span>(dog);
<span class="hljs-title function_">makeSound</span>(horse);
</code></pre></blockquote><h3 id="%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B-%D0%B8-%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC%D1%8B-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B-%D0%B8-%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC%D1%8B-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2"><span>Интерфейсы и псевдонимы типов</span></a></h3><p>TypeScript поддерживает <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases">псевдонимы типов</a> для присвоения имени всему выражению описывающему тип. Это может быть использовано для именования примитивов, объединений, кортежей и любых других типов.</p><p>Однако, при объявлении типов для объектов, используйте интерфейсы вместо псевдонима типа, для выражения, представленного объектным литералом.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span>;
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>,
  <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span>,
}
</code></pre><blockquote><p>Почему?</p><p>Эти формы почти эквивалентны, поэтому следуя принципу выбора только одной из двух форм, для предотвращения вариативности, нам стоит выбрать одну из них. Кроме того, существуют также <a href="https://ncjamieson.com/prefer-interfaces/">интересные технические причины, по которым предпочтение отдается интерфейсу</a>. На той странице также приводятся слова руководителя команды разработчиков TypeScript: &quot;Честно говоря, я считаю, что на самом деле это должны быть просто интерфейсы для всего, что они могут моделировать. Нет особой выгоды в псевдонимах типов, когда существует так много проблем с их отображением и производительностью&quot;.</p></blockquote><h3 id="%D1%82%D0%B8%D0%BF-array%3Ct%3E" tabindex="-1"><a class="header-anchor" href="#%D1%82%D0%B8%D0%BF-array%3Ct%3E"><span>Тип <code>Array&lt;T&gt;</code></span></a></h3><p>Для простых типов (содержащих только буквенно-цифровые символы и точку) используйте синтаксический сахар для массивов, <code>T[]</code>, а не более длинную форму <code>Array&lt;T&gt;</code>.</p><p>Для чего-то более сложного используйте более длинную форму <code>Array&lt;T&gt;</code>.</p><p>Это также относится к <code>readonly T[]</code> и <code>ReadonlyArray&lt;T&gt;</code>.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>[];
<span class="hljs-keyword">const</span> <span class="hljs-attr">b</span>: <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span>[];
<span class="hljs-keyword">const</span> <span class="hljs-attr">c</span>: ns.<span class="hljs-property">MyObj</span>[];
<span class="hljs-keyword">const</span> <span class="hljs-attr">d</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>&gt;;
<span class="hljs-keyword">const</span> <span class="hljs-attr">e</span>: <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>&gt;;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">f</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;;            <span class="hljs-comment">// синтаксический сахар короче </span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">g</span>: <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">string</span>&gt;;
<span class="hljs-keyword">const</span> <span class="hljs-attr">h</span>: {<span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>}[]; <span class="hljs-comment">// фигурные/круглые скобки ухудшают читабельность</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">i</span>: (<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>)[];
<span class="hljs-keyword">const</span> <span class="hljs-attr">j</span>: <span class="hljs-keyword">readonly</span> (<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>)[];
</code></pre><h3 id="%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D0%B9-(%7B%5Bkey%3A-string%5D%3A-number%7D)-%D1%82%D0%B8%D0%BF" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D0%B9-(%7B%5Bkey%3A-string%5D%3A-number%7D)-%D1%82%D0%B8%D0%BF"><span>Индексируемый (<code>{[key: string]: number}</code>) тип</span></a></h3><p>В JavaScript принято использовать объект в качестве ассоциативного массива (он же карта (map), хеш-таблица, или словарь):</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">fileSizes</span>: {[<span class="hljs-attr">fileName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>} = {};
fileSizes[<span class="hljs-string">&#x27;readme.txt&#x27;</span>] = <span class="hljs-number">541</span>;
</code></pre><p>В TypeScript укажите осмысленное обозначение для ключа. (Обозначение существует только для документации; в остальном оно не используется.)</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">users</span>: {[<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>} = ...;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">users</span>: {[<span class="hljs-attr">userName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>} = ...;
</code></pre><blockquote><p>Вместо использования одного из тех вариантов, рассмотрите возможность использования <code>Map</code> и <code>Set</code> типов ES6. Объекты JavaScript обладают довольно <a href="http://2ality.com/2012/01/objects-as-maps.html">неожиданным нежелательным поведением</a>, а типы ES6 более явно передают ваши намерения. Также, <code>Set</code> могут хранить значения, а <code>Map</code> еще и ключи, отличные от <code>string</code>.</p></blockquote><p>Встроенный в TypeScript тип <code>Record&lt;Keys, ValueType&gt;</code> позволяет создавать типы с определенным набором ключей. Это отличается от ассоциативных массивов тем, что ключи известны статически. См. рекомендации по этому вопросу <a href="#%D1%81%D0%BE%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-mapped--%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-conditional-%D1%82%D0%B8%D0%BF%D1%8B">ниже</a>.</p><h3 id="%D1%81%D0%BE%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-(mapped)-%26-%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-(conditional)-%D1%82%D0%B8%D0%BF%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%BE%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-(mapped)-%26-%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-(conditional)-%D1%82%D0%B8%D0%BF%D1%8B"><span>Сопоставленные (Mapped) &amp; Условные (Conditional) Типы</span></a></h3><p>В TypeScript <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types">сопоставленные</a> и <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types">условные</a> типы позволяют определять новые типы на основе других типов. Стандартная библиотека TypeScript включает в себя ряд основанных на этих операциях типов (<code>Record</code>, <code>Partial</code>, <code>Readonly</code> и др.).</p><p>Эти особенности системы типов позволяют лаконично задавать типы и создавать мощные, но в то же время безопасные абстракции типов. Однако они обладают определенным количеством недостатков:</p><ul><li>По сравнению с явным указанием свойств и взаимосвязей типов (например, с использованием интерфейсов и расширений, пример см. ниже), операции с типами требуют от читателя мысленно просчитывать выражения типа. Это может существенно затруднить чтение программ, особенно в сочетании с выводом типов и выражениями, пересекающими границы файлов.</li><li>Модель оценки сопоставленных и условных типов, особенно в сочетании с выводом типов, недостаточно определена, не всегда хорошо понятна и нередко претерпевает изменения в версиях компилятора TypeScript. Код может скомпилироваться по ошибке или казаться дающим правильные результаты. Это увеличивает стоимость будущей поддержки кода, использующего операции с типами.</li><li>Сопоставленные и условные типы являются наиболее мощными при получении типов на основе комплексных и/или выводимых типов. С другой стороны, это также тот случай, когда они наиболее склонны создавать трудные для понимания и обслуживания программы.</li><li>Некоторые языковые инструменты недостаточно хорошо работают с этими особенностями системы типов. Например, в вашей IDE поиск ссылок (&quot;references&quot;) и, соответственно, переименование свойств при рефакторинге, не найдут свойства в типе Pick&lt;T, Keys&gt;, а Code Search<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup> не будет создавать на них гиперссылки.</li></ul><p>Рекомендация по стилю такова:</p><ul><li>Всегда используйте самую простую конструкцию типа, которая может выразить ваш код.</li><li>Небольшое количество повторений или многословность зачастую обходятся гораздо дешевле, чем долговременные затраты на сложные выражения объявления типов.</li><li>Сопоставленные и условные типы могут быть использованы с учетом перечисленных аспектов.</li></ul><p>Например, встроенный в TypeScript тип <code>Pick&lt;T, Keys&gt;</code> позволяет создать новый тип на основе подмножества другого типа <code>T</code>, но простое расширение интерфейса часто может быть проще для понимания.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">shoeSize</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">favoriteIcecream</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">favoriteChocolate</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// В типе FoodPreferences есть favoriteIcecream и favoriteChocolate, но нет shoeSize.</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">FoodPreferences</span> = <span class="hljs-title class_">Pick</span>&lt;<span class="hljs-title class_">User</span>, <span class="hljs-string">&#x27;favoriteIcecream&#x27;</span>|<span class="hljs-string">&#x27;favoriteChocolate&#x27;</span>&gt;;
</code></pre><p>Это эквивалентно указанию свойств в интерфейсе <code>FoodPreferences</code>:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">FoodPreferences</span> {
  <span class="hljs-attr">favoriteIcecream</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">favoriteChocolate</span>: <span class="hljs-built_in">string</span>;
}
</code></pre><p>Чтобы сократить количество дублирований, <code>User</code> может расширить <code>FoodPreferences</code> или (что, возможно, лучше) вложить отдельное поле для указания предпочтений в еде:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">FoodPreferences</span> { <span class="hljs-comment">/* как описано выше */</span> }
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FoodPreferences</span> {
  <span class="hljs-attr">shoeSize</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">// также включает в себя предпочтения.</span>
}
</code></pre><p>Использование здесь интерфейсов делает группирование свойств более очевидным, улучшает поддержку IDE, обеспечивает лучшую оптимизацию и, вполне возможно, сделает код проще для понимания.</p><h3 id="%D1%82%D0%B8%D0%BF-any" tabindex="-1"><a class="header-anchor" href="#%D1%82%D0%B8%D0%BF-any"><span>Тип <code>any</code></span></a></h3><p>В TypeScript тип <code>any</code> является супертипом и подтипом всех других типов и при разыменовании допускает обращение к любым свойствам. Как таковой, <code>any</code> опасен - он может маскировать серьезные программные ошибки и его использование разрушает ценность наличия статических типов, в первую очередь.</p><p><strong>Подумайте о том, чтобы не использовать <code>any</code>.</strong> В тех обстоятельствах, в которых вы захотите использовать <code>any</code>, рассмотрите один из вариантов:</p><ul><li><a href="#%D0%BF%D1%80%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5-%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D1%84%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE-%D1%82%D0%B8%D0%BF%D0%B0">Указать более конкретный тип</a></li><li><a href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-unknown-%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%BE-any">Использовать <code>unknown</code></a></li><li><a href="#%D0%BF%D0%BE%D0%B4%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B5%D0%B4%D1%83%D0%BF%D1%80%D0%B5%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BB%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B0-%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC-any">Подавить предупреждение анализатора кода и задокументировать, почему</a></li></ul><h4 id="%D0%BF%D1%80%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5-%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D1%84%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE-%D1%82%D0%B8%D0%BF%D0%B0" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D1%80%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5-%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D1%84%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE-%D1%82%D0%B8%D0%BF%D0%B0"><span>Предоставление более специфичного типа</span></a></h4><p>Используйте интерфейсы, встраиваемый объектный тип или псевдоним типа:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Используйте декларируемые интерфейсы для представления серверного JSON.</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyUserJson</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// Используйте псевдонимы типов для тех типов, которые приходится писать многократно.</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span> = <span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>;

<span class="hljs-comment">// Или используйте встраиваемый объектный тип для возврата комплексных значений.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getTwoThings</span>(<span class="hljs-params"></span>): {<span class="hljs-attr">something</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">other</span>: <span class="hljs-built_in">string</span>} {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">return</span> {something, other};
}

<span class="hljs-comment">// Используйте дженерик там, где в ином случае библиотека указала бы `any`,</span>
<span class="hljs-comment">// чтобы обозначить, что ей все равно, с каким типом работает пользователь (но обратите </span>
<span class="hljs-comment">// внимание на раздел &quot;Возвращаемый тип представлен только дженериком&quot; представленный ниже).</span>
<span class="hljs-keyword">function</span> nicestElement&lt;T&gt;(<span class="hljs-attr">items</span>: T[]): T {
  <span class="hljs-comment">// Поиск наиболее подходящего элемента в items.</span>
  <span class="hljs-comment">// Код может также накладывать ограничения на T, например &lt;T extends HTMLElement&gt;.</span>
}
</code></pre><h4 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-unknown-%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%BE-any" tabindex="-1"><a class="header-anchor" href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-unknown-%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%BE-any"><span>Использование <code>unknown</code> вместо <code>any</code></span></a></h4><p>Тип <code>any</code> позволяет присваивать значение любого другого типа и разыменовывать любые его свойства. Часто такое поведение не является необходимым или желательным и код просто нуждается в обозначении неизвестности типа. В такой ситуации используйте встроенный тип <code>unknown</code> - он точнее описывает суть концепции и гораздо безопаснее, поскольку не позволяет разыменовывать произвольные свойства.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Можно присваивать любое значение (включая null или undefined), но нельзя </span>
<span class="hljs-comment">// использовать его без сужения типа или приведения.</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">val</span>: <span class="hljs-built_in">unknown</span> = value;
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">danger</span>: <span class="hljs-built_in">any</span> = value <span class="hljs-comment">/* результат произвольного выражения */</span>;
danger.<span class="hljs-title function_">whoops</span>();  <span class="hljs-comment">//  Этот доступ к переменной абсолютно бесконтролен</span>
</code></pre><p>Чтобы благополучно использовать значения типа <code>unknown</code>, следует сужать тип с помощью <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types">защитников типа (type guards)</a></p><h4 id="%D0%BF%D0%BE%D0%B4%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B5%D0%B4%D1%83%D0%BF%D1%80%D0%B5%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BB%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B0%2C-%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC-any" tabindex="-1"><a class="header-anchor" href="#%D0%BF%D0%BE%D0%B4%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B5%D0%B4%D1%83%D0%BF%D1%80%D0%B5%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BB%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B0%2C-%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC-any"><span>Подавление предупреждений линтера, связанных с использованием <code>any</code></span></a></h4><p>Иногда использование <code>any</code> вполне оправдано, например, в тестах для создания Mock-объектов. В таких случаях добавьте комментарий, который подавляет предупреждение линтера, и задокументируйте, почему это решение оправдано.</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-comment">// Этому тесту нужна только частичная реализация BookService,</span>
<span class="hljs-comment">// и если мы что-то упустили, тест очевидно провалится</span>
<span class="hljs-comment">// Это намеренно небезопасный частичный Mock-объект</span>
<span class="hljs-comment">// tslint:disable-next-line:no-any</span>
<span class="hljs-keyword">const</span> mockBookService = ({<span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> mockBook; }} <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">BookService</span>;
<span class="hljs-comment">// Корзина покупателя (класс ShoppingCart) в этом тесте не используется</span>
<span class="hljs-comment">// tslint:disable-next-line:no-any</span>
<span class="hljs-keyword">const</span> component = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyComponent</span>(mockBookService, <span class="hljs-comment">/* неиспользуемый ShoppingCart */</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>);
</code></pre><h3 id="%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B" tabindex="-1"><a class="header-anchor" href="#%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B"><span>Кортежные типы</span></a></h3><p>Если у вас возникнет соблазн создать парный тип, то используйте вместо него кортежный тип:</p><pre><code class="language-ts"><span class="hljs-comment">// ❌ ПЛОХО ↴</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Pair</span> {
  <span class="hljs-attr">first</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">second</span>: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">splitInHalf</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Pair</span> {
  ...
  <span class="hljs-keyword">return</span> {<span class="hljs-attr">first</span>: x, <span class="hljs-attr">second</span>: y};
}
</code></pre><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">splitInHalf</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>): [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>] {
  ...
  <span class="hljs-keyword">return</span> [x, y];
}

<span class="hljs-comment">// Используйте это как:</span>
<span class="hljs-keyword">const</span> [leftHalf, rightHalf] = <span class="hljs-title function_">splitInHalf</span>(<span class="hljs-string">&#x27;my string&#x27;</span>);
</code></pre><p>Однако часто бывает яснее, если свойствам даются осмысленные имена.</p><p>Если объявление интерфейса (<code>interface</code>) слишком обременительно, можно использовать встраиваемый объектным литералом тип:</p><pre><code class="language-ts"><span class="hljs-comment">// ✅ ХОРОШО ↴</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">splitHostPort</span>(<span class="hljs-params">address: <span class="hljs-built_in">string</span></span>): {<span class="hljs-attr">host</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">port</span>: <span class="hljs-built_in">number</span>} {
  ...
}

<span class="hljs-comment">// Используйте это как:</span>
<span class="hljs-keyword">const</span> address = <span class="hljs-title function_">splitHostPort</span>(userAddress);
<span class="hljs-title function_">use</span>(address.<span class="hljs-property">port</span>);

<span class="hljs-comment">// Вы также можете использовать деструктуризацию, чтобы получить поведение, подобное разложению кортежа на отдельные переменные:</span>
<span class="hljs-keyword">const</span> {host, port} = <span class="hljs-title function_">splitHostPort</span>(userAddress);
</code></pre><h3 id="%D1%82%D0%B8%D0%BF%D1%8B-%D0%BE%D0%B1%D0%B5%D1%80%D1%82%D0%BA%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D1%82%D0%B8%D0%BF%D1%8B-%D0%BE%D0%B1%D0%B5%D1%80%D1%82%D0%BA%D0%B8"><span>Типы-обертки</span></a></h3><p>Есть несколько типов, связанных с JavaScript примитивами, которые никогда не следует использовать:</p><ul><li><code>String</code>, <code>Boolean</code>, и <code>Number</code> имеют несколько иное значение, чем соответствующие примитивные типы <code>string</code>, <code>boolean</code>, and <code>number</code>. Всегда используйте версию со строчными буквами.</li><li><code>Object</code> имеет сходство с <code>{}</code> и <code>object</code>, но является несколько менее строгим. Используйте <code>{}</code> для типа, который включает в себя всё, кроме <code>null</code> и <code>undefined</code>, или строчный <code>object</code> для того, чтобы дополнительно исключить другие примитивные типы (три упомянутых выше, плюс <code>symbol</code> и <code>bigint</code>).</li></ul><p>Кроме того, никогда не вызывайте типы-обертки в качестве конструкторов (с помощью <code>new</code>).</p><h3 id="%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%D1%8B%D0%B9-%D1%82%D0%B8%D0%BF-%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%B4%D0%B6%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D0%BA%D0%BE%D0%BC" tabindex="-1"><a class="header-anchor" href="#%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%D1%8B%D0%B9-%D1%82%D0%B8%D0%BF-%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%B4%D0%B6%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D0%BA%D0%BE%D0%BC"><span>Возвращаемый тип представлен только дженериком</span></a></h3><p>Избегайте создания API у которых возвращаемый тип представлен только дженериком. При работе с существующими API у которых возвращаемый тип представлен только дженериком, всегда явно указывайте дженерик <sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>.</p><h2 id="%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C" tabindex="-1"><a class="header-anchor" href="#%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C"><span>Согласованность</span></a></h2><p>Для любого вопроса о стиле, который не решен окончательно этой спецификацией, делайте то, что уже делает другой код в том же файле (будьте последовательны). Если это не решит проблему, рассмотрите возможность подражания другим файлам в том же каталоге.</p><h3 id="%D1%86%D0%B5%D0%BB%D0%B8" tabindex="-1"><a class="header-anchor" href="#%D1%86%D0%B5%D0%BB%D0%B8"><span>Цели</span></a></h3><p>В основном, инженеры обычно лучше знают, что необходимо в их коде, поэтому если есть несколько вариантов и выбор зависит от ситуации, мы должны позволить принимать решения на месте. Поэтому рекомендуемым ответом по умолчанию здесь является &quot;оставить это как есть&quot;.</p><p>Следующие пункты являются теми исключительными моментами, на основании которых мы имеем некоторые всеобщие правила. Оцените ваше предложение по составлению руководства по стилю с учетом следующего:</p><ol><li><p><strong>В коде рекомендуется избегать шаблонов, которые известны как вызывающие проблемы, особенно для пользователей, только начинающих изучать язык.</strong></p><p>Примеры:</p><ul><li>Типом <code>any</code> легко злоупотребить (<em>действительно</em> ли эта переменная может быть и числом и вызываться как функция?), поэтому у нас есть рекомендации по его использованию.</li><li>В TypeScript пространство имен (<code>namespace</code>) создает проблемы с оптимизациями Closure.</li><li>Точки в именах файлов делают их уродливыми/запутанными для импорта из JavaScript.</li><li>Статические функции в классах оптимизируются довольно запутанно, в то время как функции на уровне файлов достигают тех же целей.</li><li>Пользователи, не знающие о ключевом слове <code>private</code>, попытаются скрыть имена своих функций с помощью подчеркивания.</li></ul></li><li><p><strong>Код в различных проектах рекомендуется разрабатывать единообразно, с учетом незначительных отклонений.</strong></p><p>Когда есть два варианта, которые эквивалентны в поверхностном смысле, стоит рассмотреть возможность выбора одного из них, просто чтобы не развивались расхождения без причины и избежать бессмысленных дебатов в обзорах кода.</p><p>Обычно нам также стоит соответствовать стилю JavaScript, потому что люди часто пишут на обоих языках вместе.</p><p>Примеры:</p><ul><li>Стиль написания имен с использованием заглавных букв.</li><li><code>x as T</code> синтаксис по сравнению с эквивалентным синтаксисом <code>&lt;T&gt;x</code> (запрещено).</li><li><code>Array&lt;[number, number]&gt;</code> по сравнению с <code>[number, number][]</code>.</li></ul></li><li><p><strong>Код рекомендуется писать так, чтобы он был поддерживаемым в долгосрочной перспективе.</strong></p><p>Код обычно живет дольше, чем над ним работает его автор и команда специалистов по TypeScript должна обеспечить работоспособность всего кода Google в будущем.</p><p>Примеры:</p><ul><li>Мы используем программы для автоматизации изменений в коде, поэтому код автоматически форматируется, чтобы программа легко соблюдала правила оформления пробельных символов.</li><li>Мы предъявляем требования к единому набору флагов компиляции Closure, поэтому конкретная библиотека TS может быть написана с учетом определенного набора флагов, и пользователи всегда могут безопасно использовать разделяемые библиотеки.</li><li>Код должен импортировать библиотеки, которые он использует (strict deps - строгие зависимости), чтобы рефакторинг в какой-либо зависимости не изменил зависимости его пользователей.</li><li>Мы просим пользователей писать тесты. Без тестов мы не можем быть уверены, что изменения, которые вносятся в язык, или изменения в библиотеках google3, не нарушат работу пользователей.</li></ul></li><li><p><strong>Рецензенты кода должны быть сосредоточены на улучшении качества кода, а не на соблюдении произвольных правил.</strong></p><p>Часто хорошим знаком считается, если есть возможность реализовать ваше правило в качестве автоматической проверки. Это также способствует принципу №3.</p><p>Если это действительно не имеет большого значения — если это не совсем понятная часть языка или если это позволяет избежать ошибки, которая вряд ли возникнет — вероятно, это стоит оставить без изменений.</p></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Прим. пер.: В оригинале используются термины <em>MUST</em> и <em>SHOULD</em> которые зачастую переводят буквально как <em>должен</em>. При этом MUST носит <em>обязательный характер</em>, а <em>SHOULD</em> - <em>рекомендательный</em>. Т.к. в русском языке такие термины, как: &quot;<em>должен</em>&quot;, &quot;<em>обязан</em>&quot;, &quot;<em>стоит</em>&quot;, &quot;<em>необходимо</em>&quot; многими воспринимаются как имеющими строго обязательный характер, при буквальном переводе это может ввести в заблуждение. Поэтому для большего понимания эти термины были адаптированы как:</p><ul><li><em>ДОЛЖНЫ</em> | <em>НЕ ДОЛЖНЫ</em> - носят строго обязательный характер;</li><li><em>РЕКОМЕНДУЕТСЯ</em> | <em>НЕ РЕКОМЕНДУЕТСЯ</em> - являются настойчивой рекомендацией, но тем не менее не имеют обязательного характера;</li><li><em>ВОЗМОЖНО</em> - обозначают допустимый вариант.</li></ul><p>Такая адаптация вполне совместима с оригинальным стандартом <a href="https://tools.ietf.org/html/rfc2119">RFC 2119</a> и не нарушает его. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>Прим. пер.: В оригинале в этом абзаце присутствует несколько вероятных ошибок:</p><ul><li>Вместо <code>$</code> в оригинале был указан знак <code>\(</code>, но такой символ не может быть в имени идентификатора и поэтому в переводе указан более корректный вариант с <code>$</code>;</li><li>В оригинале упоминается явно ошибочное регулярное выражение <code>[\)\w]+</code> и поэтому, с учетом прошлого пункта, в переводе было указано более корректное <code>[$\w]+</code>.</li></ul><a href="#fnref2" class="footnote-backref">↩︎</a></li><li id="fn3" class="footnote-item"><p>Прим. пер.: Такое соглашение было популяризовано <a href="https://cycle.js.org/basic-examples.html#basic-examples-increment-a-counter-what-is-the-convention">Cycle.js</a> и также применяется в <a href="https://angular.io/guide/rx-library#naming-conventions-for-observables">Angular</a>. <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>Прим. пер.: С переводом руководства &quot;Google JavaScript Style Guide&quot; вы можете ознакомиться тут: <a href="https://rostislavdugin.github.io/styleguide/jsguide.html">https://rostislavdugin.github.io/styleguide/jsguide.html</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>Прим. пер.: В TS 4.3 появилась полноценная поддержка модификатора <code>override</code>, поэтому нет необходимости в JSDoc <code>@override</code> (См. <a href="#%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B8%D1%82%D0%B5-%D1%82%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B8%D0%B7%D0%BB%D0%B8%D1%88%D0%BD%D0%B8-%D0%B2-typescript">исключите те комментарии, которые излишни в TypeScript</a>). Подробнее с нативным <code>override</code> вы можете ознакомиться тут: <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#override-and-the---noimplicitoverride-flag">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#override-and-the---noimplicitoverride-flag</a>. <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p>Прим. пер.: В блоке оператора <code>switch</code> непустые группы операторов <code>case</code> не допускаются к проваливанию компилятором при активной опции <code>noFallthroughCasesInSwitch</code>. Подробнее вы можете ознакомиться тут: <a href="https://www.typescriptlang.org/tsconfig#noFallthroughCasesInSwitch">https://www.typescriptlang.org/tsconfig#noFallthroughCasesInSwitch</a>. <a href="#fnref6" class="footnote-backref">↩︎</a></p></li><li id="fn7" class="footnote-item"><p>Automatic Semicolon Insertion (ASI) — с англ. переводится как &quot;автоматическая вставка точки с запятой&quot;. <a href="#fnref7" class="footnote-backref">↩︎</a></p></li><li id="fn8" class="footnote-item"><p>google3 - название основного внутреннего монорепозитория Google. Подробнее: <a href="https://opensource.google/documentation/reference/glossary#google3">https://opensource.google/documentation/reference/glossary#google3</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p></li><li id="fn9" class="footnote-item"><p>Google Code Search - проект поисковой системы по исходному коду программ, позволяющий использовать в поисковых запросах регулярные выражения. Репозиторий проекта размещен по адресу: <a href="https://github.com/google/codesearch">https://github.com/google/codesearch</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p></li><li id="fn10" class="footnote-item"><p>Прим. пер.: Данная проблема под названием &quot;return-only generics&quot; обсуждалась в <a href="https://github.com/microsoft/TypeScript/issues/33272">issue к TypeScript</a>. На странице <a href="https://effectivetypescript.com/2020/08/12/generics-golden-rule/">https://effectivetypescript.com/2020/08/12/generics-golden-rule/</a> хорошо поясняется суть этой проблемы на примере кода:</p><pre><code class="language-ts"><span class="hljs-keyword">function</span> parseYAML&lt;T&gt;(<span class="hljs-attr">input</span>: <span class="hljs-built_in">string</span>): T {
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Weight</span> {
  <span class="hljs-attr">pounds</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">ounces</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">w</span>: <span class="hljs-title class_">Weight</span> = <span class="hljs-title function_">parseYAML</span>(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// возвращаемый тип - any!</span>
</code></pre><p>На примере, функция <code>parseYAML</code> неявно возвращает тип <code>any</code>, но при этом нигде явно не указано ключевое слово <code>any</code>, что может сбить с толку и привести к нежелательным последствиям. <a href="#fnref10" class="footnote-backref">↩︎</a></p></li></ol></section></div></body></html>