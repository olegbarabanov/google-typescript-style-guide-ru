# Руководство Google по стилю написания кода на языке TypeScript (перевод руководства "Google TypeScript Style Guide")

## Дополнительная информация по переводу

Репозиторий текущего перевода расположен по адресу: [https://github.com/olegbarabanov/google-typescript-style-guide-ru](https://github.com/olegbarabanov/google-typescript-style-guide-ru).

С оригинальным руководством по стилю вы можете ознакомиться по адресу: [https://google.github.io/styleguide/tsguide.html](https://google.github.io/styleguide/tsguide.html).

Перевод основан на [версии оригинального руководства от ***21.10.2023***](https://github.com/google/styleguide/blob/4d9a47834bfbadeb00a3dcf3d9808ffe49e43aeb/tsguide.html).

Хотя данный перевод и стремится быть максимально соответствующим оригинальному тексту, в текст перевода были добавлены сноски на комментарии и примечания переводчика, которые дополняют или разъясняют суть конкретного выражения. Также подобные сноски присутствуют в местах исправления *явных* ошибок, которые присутствовали в оригинале и которые могли бы ввести в заблуждение.

Если Вы нашли несоответствие, ошибку или неточность в переводе, вы можете оформить это в виде *[issue](https://github.com/olegbarabanov/google-typescript-style-guide-ru/issues)* или предложить собственное исправление в виде *[pull request](https://github.com/olegbarabanov/google-typescript-style-guide-ru/pulls)* в репозиторий проекта, либо написать переводчику по адресу [mail@olegbarabanov.ru](mailto:mail@olegbarabanov.ru).

## Введение

Данное руководство основано на внутреннем руководстве Google по стилю написания кода на языке TypeScript, но при этом оно было незначительно скорректировано с целью удаления разделов предназначенных для внутреннего пользования Google. Внутренняя среда Google предусматривает иные ограничения на TypeScript, чем те, что вы могли бы встретить за пределами Google. Приведенные здесь советы особенно полезны для людей, создающих код, который они намерены импортировать в Google, однако в других случаях они могут и не применяться в вашей внешней по отношению к Google среде.

Для этой версии руководства не существует какого-либо механизма автоматического развертывания, поскольку она предоставляется волонтерами в ответ на запросы пользователей.

### Примечание к терминологии

Данное руководство ссылается на терминологию стандарта [RFC 2119](https://tools.ietf.org/html/rfc2119) при использовании фраз *ДОЛЖЕН*, *НЕ ДОЛЖЕН*, *РЕКОМЕНДУЕТСЯ*, *НЕ РЕКОМЕНДУЕТСЯ* и *ВОЗМОЖНО* [^comment-terminology]. Термины *ПРЕДПОЧИТАТЬ* и *ИЗБЕГАТЬ* соответствуют терминам *РЕКОМЕНДУЕТСЯ* и *НЕ РЕКОМЕНДУЕТСЯ* соответственно. Императивные и декларативные высказывания носят предписывающий характер и соответствуют термину *ДОЛЖЕН*.

[^comment-terminology]: Прим. пер.: В оригинале используются термины *MUST* и *SHOULD* которые зачастую переводят буквально как *должен*. При этом MUST носит *обязательный характер*, а *SHOULD* - *рекомендательный*. Т.к. в русском языке такие термины, как: "*должен*", "*обязан*", "*стоит*", "*необходимо*" многими воспринимаются как имеющими строго обязательный характер, при буквальном переводе это может ввести в заблуждение. Поэтому для большего понимания эти термины были адаптированы как:  
    - *ДОЛЖЕН* | *НЕ ДОЛЖЕН* - носят строго обязательный характер;
    - *РЕКОМЕНДУЕТСЯ* | *НЕ РЕКОМЕНДУЕТСЯ* - являются настойчивой рекомендацией, но тем не менее не имеют обязательного характера;
    - *ВОЗМОЖНО* - обозначают допустимый вариант.

    Такая адаптация вполне совместима с оригинальным стандартом [RFC 2119](https://tools.ietf.org/html/rfc2119) и не нарушает его.

### Примечание к руководству

Все приведенные примеры **не носят нормативного характера** и служат лишь для иллюстрации стандартных формулировок из данного руководства по стилю. Т.е. хоть примеры и выполнены в стиле текущего руководства, они могут не иллюстрировать представление кода *исключительно* в этом стиле. Любые дополнительные решения в отношении форматирования кода, представленные в примерах, не должны рассматриваться в качестве правил руководства.

## Основы исходных файлов

### Кодировка файлов: UTF-8

Исходные файлы кодируются в UTF-8.

### Специальные символы

#### Пробельные символы

Помимо последовательности символов перевода строки, ASCII-символ горизонтального пробела (0x20) является единственным допустимым пробельным символом, который может появляться где-либо в исходном коде. Это также подразумевает, что в строковых литералах все прочие пробельные символы экранируются.

#### Специальные экранирующие последовательности

Для каждого символа, для которого существует специальная экранирующая последовательность (`\'`, `\"`, `\\`, `\b`, `\f`, `\n`, `\r`, `\t`, `\v`) предпочтительнее использовать именно ее вместо соответствующего числового экранирования (например, `\x0a`, `\u000a` или `\u{a}`). Устаревшие восьмеричные символы экранирования не используются.

#### Символы не из таблицы ASCII

Для остальных символов, которые не из таблицы ASCII, используйте подходящий символ Unicode (например `∞`). Для непечатаемых символов можно использовать эквивалентный шестнадцатеричный код или экранирование Unicode-символов (например `\u221e`) вместе с пояснительным комментарием.

```ts
// ✅ ХОРОШО ↴

// Совершенно ясно даже без комментария
const units = 'μs';

// Используйте Unicode-экранирование для непечатаемых символов
const output = '\ufeff' + content; // это маркер последовательности байтов (Unicode BOM)
```

```ts
// ❌ ПЛОХО ↴

// Даже с комментарием, это сложно для чтения и подвержено потенциальным ошибкам.
const units = '\u03bcs'; // Греческая буква mu, 's'

// Читающий код не поймет, что это такое
const output = '\ufeff' + content;
```

## Структура исходного файла

Исходный файл состоит из следующих **по порядку** частей:

- Информация об авторских правах, при наличии
- JSDoc с `@fileoverview`, при наличии
- Объявление импортов, при наличии
- Реализация файла

Для разделения перечисленных частей друг от друга используется **только одна пустая строка**.

### Информация об авторских правах

Если необходимо указать в файле информацию о лицензии или авторских правах, добавьте ее в JSDoc в верхней части файла[^comment-copyright-or-license-jsdoc].

[^comment-copyright-or-license-jsdoc]: Прим. пер.: В JSDoc для указания информации о лицензии используется тег `@license`, а для информации об авторских правах тег `@copyright`. 

### JSDoc тег `@fileoverview`

Файл может иметь на верхнем уровне JSDoc с тегом `@fileoverview`. При наличии, в нем может быть представлено описание содержимого файла, его применение, а также информация о его зависимостях. 

Пример[^comment-jsdoc-fileoverview]:

[^comment-jsdoc-fileoverview]: Прим. пер.: В примере комментария представлен классический условный текст-заполнитель (текст-"заглушка", текст-"рыба") ["Lorem ipsum dolor sit amet, consectetur..."](https://en.wikipedia.org/wiki/Lorem_ipsum), который не несет в себе никакой смысловой нагрузки и часто используется для простой имитации какого-либо текстового содержимого.

```ts
// ✅ ХОРОШО ↴

/**
 * @fileoverview Описание файла. Lorem ipsum dolor sit amet, consectetur
 * adipiscing elit, sed do eiusmod tempor incididunt.
 */
```

### Импорты

В ES6 и TypeScript есть четыре варианта операторов импорта:

| Вид импорта | Пример | Назначение |
| ----------- | ------ | ---------- |
| модульный | `import * as foo from '...';` | Импорты TypeScript |
| именованный (деструктурированный) | `import {SomeThing} from '...';` | Импорты TypeScript |
| по умолчанию | `import SomeThing from '...';` | Только для поддержки стороннего кода, который их требует |
| для использования побочных эффектов | `import '...';` | Только для импорта библиотек ради получения их побочных эффектов при загрузке (таких как пользовательские элементы) |

```ts
// ✅ ХОРОШО ↴

// Хорошо: выберите один из двух вариантов в зависимости от ситуации (см. ниже).
import * as ng from '@angular/core';
import {Foo} from './foo';

// Только при необходимости: импорт по умолчанию.
import Button from 'Button';

// Иногда необходимо импортировать библиотеки для получения их вспомогательных эффектов:
import 'jasmine';
import '@polymer/paper-button';
```

#### Использование путей в импортах

В TypeScript коде обязательно *должны* указываться пути при импорте другого TypeScript кода. *Возможно* указывать относительные пути, т.е. начинающиеся с `.` или `..` или с базовой директории, как например `root/path/to/file`.

В коде *рекомендуется* использовать относительные импорты (`./foo`) вместо абсолютных импортов `path/to/foo` при ссылке на файлы в пределах одного и того же (в логическом смысле) проекта, т.к. это позволяет перемещать весь проект без внесения изменений в эти импорты.

Рассмотрите возможность ограничения количества родительских шагов (`../../../`), т.к. это может затруднить понимание структуры модулей и путей.

```ts
// ✅ ХОРОШО ↴

import {Symbol1} from 'path/from/root';
import {Symbol2} from '../parent/file';
import {Symbol3} from './sibling';
```

#### Импорты пространств имен в сравнении с именованными импортами

Могут использоваться как импорты пространств имен, так и именованные импорты.

Именованные импорты предпочтительны для элементов, часто используемых в файле, а также для элементов, имеющих понятное название, как например, `describe` и `it` в Jasmine. При необходимости с помощью оператора `as` именованные импорты могут быть переименованы в более понятные названия.

Импорты пространств имен предпочтительны при использовании множества различных элементов из больших API. Импорт пространства имен, несмотря на `*`, не сопоставим с "подстановочным" (wildcard) импортом, который встречается в других языках. Вместо этого, импорт пространства имен присваивает имя всему экспорту модуля и каждый экспортируемый элемент из модуля становится свойством этого имени модуля. Импорты пространств имен могут поспособствовать удобочитаемости в случае экспортируемых элементов, которые имеют распространенные имена, наподобие `Model` или `Controller`, без необходимости объявлять для них псевдонимы.

```ts
// ❌ ПЛОХО ↴

// Плохо: слишком длинный оператор импорта с излишними пространствами имен.
import {Item as TableviewItem, Header as TableviewHeader, Row as TableviewRow,
  Model as TableviewModel, Renderer as TableviewRenderer} from './tableview';

let item: TableviewItem|undefined;
```

```ts
// ✅ ХОРОШО ↴

// Лучше: используйте модуль для пространства имен. 
import * as tableview from './tableview';

let item: tableview.Item|undefined;
```

```ts
// ❌ ПЛОХО ↴

import * as testing from './testing';

// Плохо: Имя модуля не способствует удобочитаемости.
testing.describe('foo', () => {
  testing.it('bar', () => {
    testing.expect(null).toBeNull();
    testing.expect(undefined).toBeUndefined();
  });
});
```

```ts
// ✅ ХОРОШО ↴

// Лучше: дайте локальные имена распространенным функциям.
import {describe, it, expect} from './testing';

describe('foo', () => {
  it('bar', () => {
    expect(null).toBeNull();
    expect(undefined).toBeUndefined();
  });
});
```

##### Особый случай: Приложения использующие JSPB proto-файлы

Приложения использующие JSPB proto-файлы должны использовать для них именованный импорт, даже если это приводит к возникновению длинных строк импорта[^comment-jspb-proto].

[^comment-jspb-proto]: Прим. пер.: Данный тема связана с использованием технологии Protocol Buffers (https://github.com/protocolbuffers/protobuf)

Это правило существует для повышения производительности сборки и избавления от мертвого кода, поскольку часто файлы `.proto` содержат множество "сообщений" (`message`), которые не всегда нужны все вместе. Используя деструктурированный импорт, система сборки может создавать более точную структуру зависимостей от "сообщений" JSPB в приложении их использующем, сохраняя при этом удобство импорта на основе путей.

```ts
// ✅ ХОРОШО ↴

// ХОРОШО: Импортируйте из proto-файла именно тот набор элементов, который вам нужен.
import {Foo, Bar} from './foo.proto';

function copyFooBar(foo: Foo, bar: Bar) {...}
```

#### Переименование импортов

В коде *рекомендуется* устранять возможные конфликты имен используя импорт пространств имен или переименовывая сами экспорты. При необходимости в коде *можно* переименовывать импорты (`import {SomeThing as SomeOtherThing}`).

Три примера, когда переименование может быть полезным:

1. Если необходимо избежать коллизий с другими импортируемыми элементами;
2. Если имя импортированного элемента генерируется;
3. При импорте элементов, имена которых сами по себе неясны, переименование может улучшить ясность кода. Например, при использовании RxJS функция `from` может быть более удобочитаемой, если ее переименовать в `observableFrom`.

### Экспорты

По всему коду используйте именованные экспорты:

```ts
// ✅ ХОРОШО ↴

// Использование именованного экспорта:
export class Foo { ... }
```

Не используйте экспорт по умолчанию. Это гарантирует, что все импорты будут следовать единому шаблону.

```ts
// ❌ ПЛОХО ↴

// Не используйте экспорт по умолчанию:
export default class Foo { ... } // ПЛОХО!
```

> Почему?
> 
> Экспорт по умолчанию не предоставляет канонического имени, что затрудняет централизованное обслуживание при относительно небольшой пользе для владельцев кода, причем возможно ухудшение читабельности:
> 
> ```ts
> // ❌ ПЛОХО ↴
> 
> import Foo from './bar';  // Валидно.
> import Bar from './bar';  // Также валидно.
> ```
> 
> Преимущество именованного экспорта заключается в том, что оно приводит к ошибкам, когда операторы импорта пытаются импортировать что-то, что не было объявлено. В `foo.ts`:
> 
> ```ts
> // ❌ ПЛОХО ↴
> 
> const foo = 'blah';
> export default foo;
> ```
> 
> И в `bar.ts`:
> 
> ```ts
> // ❌ ПЛОХО ↴
> 
> import {fizz} from './foo';
> ```
> 
> В результате возникает ошибка `error TS2614: Module '"./foo"' has no exported member 'fizz'`. Если указать в `bar.ts`:
> 
> ```ts
> // ❌ ПЛОХО ↴
> 
> import fizz from './foo';
> ```
> 
> В результате получается `fizz === foo`, что может быть неожиданным и затрудняющим отладку.
> 
> Кроме того, экспорт по умолчанию побуждает людей помещать все в один большой объект, чтобы разместить все вместе в пространстве имен:
> 
> ```ts
> // ❌ ПЛОХО ↴
> 
> export default class Foo {
>   static SOME_CONSTANT = ...
>   static someHelpfulFunction() { ... }
>   ...
> }
> ```
> 
> В приведенном выше примере у нас есть область видимости файла, которая может использоваться как пространство имен. У нас также есть, возможно, ненужная вторая область видимости (класс `Foo`), которая в других файлах может двусмысленно использоваться и как тип, и как значение.
> 
> Вместо этого предпочтительно использовать файловую область видимости для пространства имен, а также именованный экспорт:
> 
> ```ts
> // ✅ ХОРОШО ↴
> 
> export const SOME_CONSTANT = ...
> export function someHelpfulFunction()
> export class Foo {
>   // тут только элементы класса
> }
> ```

#### Область видимости экспортируемых элементов

TypeScript не поддерживает ограничение видимости экспортируемых элементов. Экспортируйте только те элементы, которые используются вне модуля. В целом, минимизируйте экспортируемую часть API модулей.

#### Мутабельность экспортов

Независимо от технической стороны, мутабельные экспорты могут создавать трудно понимаемый и отлаживаемый код, особенно при реэкспорте в различных модулях. Если по другому сформулировать это правило, то `export let` не допускается.

```ts
// ❌ ПЛОХО ↴

export let foo = 3;
// В чистом ES6 foo является мутабельным, и импортеры будут видеть изменение его значения уже через секунду.
// В TS (прим. пер.: в версии TS < 3.9, при использовании модулей CommonJS), если foo реэкспортируется вторым файлом,
// импортеры не увидят изменения значения.
// Прим. пер.: В версии TS >= 3.9, это будет работать по аналогии с ES6.
window.setTimeout(() => {
  foo = 4;
}, 1000 /* миллисекунды */);

```

Если необходимо поддерживать доступные извне мутабельные привязки, то вместо этого *рекомендуется* явно использовать функции-геттеры.

```ts
// ✅ ХОРОШО ↴

let foo = 3;
window.setTimeout(() => {
  foo = 4;
}, 1000 /* миллисекунды */);
// Используйте явно заданный геттер для доступа к мутабельному экспорту.
export function getFoo() { return foo; };
```

При экспорте одного из двух значений в зависимости от условий, в качестве стандартного шаблона, сначала выполняется проверка условий, а затем экспорт. Убедитесь, что все экспортируемые значения являются окончательными после выполнения всего тела модуля.

```ts
// ✅ ХОРОШО ↴

function pickApi() {
  if (useOtherApi()) return OtherApi;
  return RegularApi;
}
export const SomeApi = pickApi();
```

#### Классы-контейнеры

Не создавайте классы-контейнеры со статическими методами или свойствами ради пространства имен.

```ts
// ❌ ПЛОХО ↴

export class Container {
  static FOO = 1;
  static bar() { return 1; }
}
```

Вместо этого экспортируйте отдельные константы и функции:

```ts
// ✅ ХОРОШО ↴

export const FOO = 1;
export function bar() { return 1; }
```

### Импорт и экспорт типов

#### Импорт типа

Вы можете использовать `import type {...}` если вы используете импортируемый элемент только в качестве типа. Для значений используйте обычный импорт:

```ts
// ✅ ХОРОШО ↴

import type {Foo} from './foo';
import {Bar} from './foo';

import {type Foo, Bar} from './foo';
```

> Почему?
> 
> Компилятор TypeScript автоматически определяет различия и не внедряет динамическую (runtime) загрузку для обращений к типам. Так зачем же тогда аннотировать импорт типов?
>
> Компилятор TypeScript может работать в двух режимах:
>
> - В режиме разработки (development mode) мы обычно хотим получить быстрые итерации циклов выполнения. Компилятор транспилирует код в JavaScript без полной информации о типе. Это работает намного быстрее, запрашивая `import type` лишь в некоторых случаях.
> - В режиме эксплуатации (production mode) мы хотим обеспечить корректность. Компилятор проверяет типы для всех элементов, а также проверяет использование корректного `import type`.
>
> Совет: Если вам необходима обязательная динамическая (runtime) загрузка для получения сторонних эффектов, используйте `import '...';`. См. [импорты](#импорты).

#### Экспорт типа

Используйте `export type` при реэкспорте типа, например:

```ts
// ✅ ХОРОШО ↴

export type {AnInterface} from './foo';
```

> Почему?
>
> `export type` полезен тем, что позволяет использовать реэкспорт типов при пофайловой транспиляции. См. [документацию по `isolatedModules`](https://www.typescriptlang.org/tsconfig#exports-of-non-value-identifiers).
> 
> Также `export type` может показаться полезным, чтобы избежать какого-либо экспортирования значения элемента в API. Однако и это не дает гарантий, т.к. последующий код может по-прежнему импортировать API другим путем. Лучший способ для разделения и гарантии использования API по типу и значению - разделить элементы, например, на `UserService` и `AjaxUserService`. Это менее подвержено ошибкам и лучше передает смысл.

#### Используйте модули, а не пространства имен

TypeScript поддерживает два метода организации кода: пространства имен (*namespaces*) и модули, но использование пространств имен необходимо избегать. Т.е. ваш код *должен* ссылаться на код в других файлах с помощью импорта и экспорта вида `import {foo} from 'bar';`

В вашем коде *не должны* использоваться `namespace Foo { ... }` конструкции. Пространства имен (`namespace`) *возможно* использовать только тогда, когда это необходимо для взаимодействия с внешним сторонним кодом. Чтобы семантически разделить пространство имен вашего кода, используйте отдельные файлы.

В коде *не должны* использоваться `require` (как в `import x = require('...');`) для импортов. Используйте синтаксис модулей ES6.

```ts
// ❌ ПЛОХО ↴

// Плохо: не используйте пространства имен:
namespace Rocket {
  function launch() { ... }
}

// Плохо: не используйте <reference>
/// <reference path="..."/>

// Плохо: не используйте require()
import x = require('mydep');
```

> Примечание: В TypeScript пространства имен (`namespace`) раньше назывались внутренними модулями и использовали ключевое слово `module` в виде `module Foo { ... }`. Не используйте такую форму. Всегда используйте ES6 импорты.

## Языковые особенности

В этом разделе указывается, какие особенности можно или нельзя использовать, а также прочие ограничения на их применение.

Языковые особенности, которые не рассматриваются в данном руководстве по стилю, могут быть использованы без каких-либо рекомендаций по их применению.

### Объявление локальных переменных

#### Используйте const и let

Всегда используйте `const` или `let` для объявления переменных. По умолчанию используйте `const`, если не требуется переназначение переменной. Никогда не используйте `var`.

```ts
// ✅ ХОРОШО ↴

const foo = otherValue;  // Используйте, если "foo" никогда не меняется.
let bar = someValue;     // Используйте, если для "bar" когда-либо позднее будет присвоено значение 
```

`const` и `let` имеют блочную область видимости, как и переменные в большинстве других языков. `var` в JavaScript ограничен областью действия функции, что может вызвать трудные для понимания ошибки. Не используйте его.

```ts
// ❌ ПЛОХО ↴

var foo = someValue;     // Не используйте - область видимости var сложна и подвержена ошибкам.
```

Переменные *не должны* использоваться до их объявления.

#### При каждом обьявлении переменных задается только одна переменная

При каждом объявлении локальных переменных задается только одна переменная: т.е. такие объявления, как `let a = 1, b = 2`, не используются.

### Литералы массива

#### Не используйте конструктор `Array`

В коде *не должен* использоваться конструктор `Array()`, с или без `new`. Его применение неоднозначно и сбивает с толку:

```ts
// ❌ ПЛОХО ↴

const a = new Array(2); // [undefined, undefined]
const b = new Array(2, 3); // [2, 3];
```

Вместо этого всегда используйте скобки для инициализации массивов или `from` для инициализации `Array` с определенным размером:

```ts
// ✅ ХОРОШО ↴

const a = [2];
const b = [2, 3];

// Эквивалент для Array(2):
const c = [];
c.length = 2;

// [0, 0, 0, 0, 0]
Array.from<number>({length: 5}).fill(0);
```

#### Не определяйте свойства в массивах

Не определяйте и не используйте нечисловые свойства массива (кроме `length`). Вместо этого используйте `Map` (или `Object`).

#### Использование синтаксиса spread-оператора

Использование синтаксиса spread-оператора `[...foo]; {...bar}` является удобным сокращением для неглубокого копирования или конкатенации итерируемых структур.

```ts
// ✅ ХОРОШО ↴

const foo = [
  1,
];

const foo2 = [
  ...foo,
  6,
  7,
];

const foo3 = [
  5,
  ...foo,
];

foo2[1] === 6;
foo3[1] === 1;
```

При использовании синтаксиса spread-оператора раскладываемое значение *должно* соответствовать создаваемому. При создании массива раскладывайте только итерируемые структуры. Примитивы, включая `null` и `undefined`, *не должны* раскладываться.

```ts
// ❌ ПЛОХО ↴

const foo = [7];
const bar = [5, ...(shouldUseFoo && foo)]; // может быть undefined

// Создает {0: 'a', 1: 'b', 2: 'c'} но при этом не содержит длины (length)
const fooStrings = ['a', 'b', 'c'];
const ids = {...fooStrings};
```

```ts
// ✅ ХОРОШО ↴

const foo = shouldUseFoo ? [7] : [];
const bar = [5, ...foo];
const fooStrings = ['a', 'b', 'c'];
const ids = [...fooStrings, 'd', 'e'];
```

#### Деструктуризация массива

Литералы массивов могут использоваться в левой части присваивания для выполнения деструктуризации (например, при распаковке нескольких значений из одного массива или итерируемого элемента). В конце можно указать переменную (без пробела между `...` и именем переменной) для присвоения оставшихся элементов (прим. пер.: переменная `rest` на примере ниже). Неиспользуемые элементы следует пропускать.

```ts
// ✅ ХОРОШО ↴

const [a, b, c, ...rest] = generateResults();
let [, b,, d] = someArray;
```

Деструктуризация может также использоваться и для параметров функций. Если деструктурированный массив как параметр является необязательным, в таких случаях всегда указывайте `[]` в качестве значения по умолчанию, а в левой части указывайте значения по умолчанию:

```ts
// ✅ ХОРОШО ↴

function destructured([a = 4, b = 2] = []) { … }
```

Запрещено:

```ts
// ❌ ПЛОХО ↴

function badDestructuring([a, b] = [4, 2]) { … }
```

> Совет: Для упаковки/распаковки нескольких значений в параметр или в возврат функции (`return`) по возможности следует предпочесть деструктуризацию объекта вместо деструктуризации массива, поскольку это позволяет присваивать имена отдельным элементам и задавать для каждого из них свой тип.

### Объектные литералы

#### Не используйте конструктор `Object`

Конструктор `Object` запрещен. Вместо этого используйте объектные литералы (`{}` или `{a: 0, b: 1, c: 2}`).

#### Итерация по объектам

Итерация по объектам с помощью `for (... in ...)` подвержена вероятным ошибкам, т.к. это включает в себя все перечисляемые свойства из цепочки прототипов.

Не используйте не фильтрованные `for (... in ...)` выражения:

```ts
// ❌ ПЛОХО ↴

for (const x in someObj) {
  // x может происходить от некоторого родительского прототипа!
}
```

Либо явно отфильтруйте значения с помощью оператора `if`, либо используйте `for (... of Object.keys(...))`.

```ts
// ✅ ХОРОШО ↴

for (const x in someObj) {
  if (!someObj.hasOwnProperty(x)) continue;
  // сейчас x был точно определен в принадлежности someObj
}
for (const x of Object.keys(someObj)) { // примечание: for _of_!
  // сейчас x был точно определен в принадлежности someObj
}
for (const [key, value] of Object.entries(someObj)) { // примечание: for _of_!
  // сейчас key был точно определен в принадлежности someObj
}
```

#### Использование синтаксиса spread-оператора

Использование синтаксиса spread-оператора `[...foo]; {...bar}` является удобным сокращением для неглубокого копирования объекта. При использовании синтаксиса spread-оператора для инициализации объектов, более поздние значения заменяют более ранние с тем же ключом.

```ts
// ✅ ХОРОШО ↴

const foo = {
  num: 1,
};

const foo2 = {
  ...foo,
  num: 5,
};

const foo3 = {
  num: 5,
  ...foo,
}

foo2.num === 5;
foo3.num === 1;
```

При использовании синтаксиса spread-оператора, раскладываемое значение *должно* соответствовать создаваемому. Т.е. при создании объекта, spread-оператор может использоваться только на объектах и  *не должен* использоваться на массивах и примитивах (включая `null` и `undefined`). Избегайте использовать spread-оператор на объектах, имеющих прототипы, отличные от прототипа Object (например, определений классов, экземпляров классов, функций), так как их поведение неинтуитивно (поверхностно копируются только перечислимые свойства, не относящиеся к прототипу).

```ts
// ❌ ПЛОХО ↴

const foo = {num: 7};
const bar = {num: 5, ...(shouldUseFoo && foo)}; // может быть undefined

// Создает {0: 'a', 1: 'b', 2: 'c'} но при этом не содержит длины (length)
const fooStrings = ['a', 'b', 'c'];
const ids = {...fooStrings};
```

```ts
// ✅ ХОРОШО ↴

const foo = shouldUseFoo ? {num: 7} : {};
const bar = {num: 5, ...foo};
```

#### Вычисленные имена свойств

Вычисляемые имена свойств (например, `{['key' + foo()]: 42}`) разрешены, заключаются в кавычки и рассматриваются в стиле ключей словаря (т.е. не должны смешиваться с ключами без кавычек), если только вычисляемое свойство не принадлежит типу [`symbol`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) (например, `[Symbol.iterator]`).

#### Деструктуризация объекта

Шаблоны деструктуризации объектов могут использоваться в левой части присваивания для выполнения деструктуризации и распаковки множества значений из отдельного объекта.

Деструктурированные объекты также могут использоваться в качестве параметров функции, но при этом их следует делать как можно более простыми, с одним уровнем вложенности состоящем из коротких свойств без кавычек. Более глубокие уровни вложенности и вычисляемые свойства не следует использовать при деструктуризации параметров. Любые значения по умолчанию указываются в левой части деструктурируемого параметра (`{str = 'some default'} = {}`, а не `{str} = {str: 'some default'}`), а если деструктурируемый объект сам по себе необязателен, то по умолчанию он должен иметь значение `{}`.

Например:

```ts
// ✅ ХОРОШО ↴

interface Options {
  /** Сколько раз выполнять то или иное действие. */
  num?: number;

  /** Строка для обработки. */
  str?: string;
}

function destructured({num, str = 'default'}: Options = {}) {}
```

Запрещено:

```ts
// ❌ ПЛОХО ↴

function nestedTooDeeply({x: {num, str}}: {x: Options}) {}
function nontrivialDefault({num, str}: Options = {num: 42, str: 'default'}) {}
```

### Классы

#### Объявления классов

Объявления классов *не должны* завершаться точкой с запятой:

```ts
// ✅ ХОРОШО ↴

class Foo {
}
```

```ts
// ❌ ПЛОХО ↴

class Foo {
}; // Ненужная точка с запятой
```

В отличие от этого, инструкции, содержащие выражения классов, *должны* завершаться точкой с запятой:

```ts
// ✅ ХОРОШО ↴

export const Baz = class extends Bar {
  method(): number {
    return this.x;
  }
}; // Здесь точка с запятой, поскольку это инструкция, а не объявление класса
```

```ts
// ❌ ПЛОХО ↴

exports const Baz = class extends Bar {
  method(): number {
    return this.x;
  }
}
```

По поводу использования пустых строк, отделяющих скобки объявления класса от остального содержимого класса, нет никаких особых рекомендаций или запретов:

```ts
// ✅ ХОРОШО ↴

// Никаких пустых строк возле скобок — хорошо.
class Baz {
  method(): number {
    return this.x;
  }
}

// Одна пустая строка возле обоих скобок - тоже хорошо
class Foo {

  method(): number {
    return this.x;
  }

}
```

#### Объявления методов класса

В объявлениях методов классов *не должна* использоваться точка с запятой для разделения отдельных объявлений методов:

```ts
// ✅ ХОРОШО ↴

class Foo {
  doThing() {
    console.log("A");
  }
}
```

```ts
// ❌ ПЛОХО ↴

class Foo {
  doThing() {
    console.log("A");
  }; // <-- ненужно
}
```

Объявления методов рекомендуется отделять от окружающего кода одной пустой строкой:

```ts
// ✅ ХОРОШО ↴

class Foo {
  doThing() {
    console.log("A");
  }

  getOtherThing(): number {
    return 4;
  }
}
```

```ts
// ❌ ПЛОХО ↴

class Foo {
  doThing() {
    console.log("A");
  }
  getOtherThing(): number {
    return 4;
  }
}
```

##### Переопределение метода toString

Метод `toString` может быть переопределен, но всегда должен срабатывать успешно и не иметь ощутимых побочных эффектов.

> Совет: Остерегайтесь, в частности, вызывать другие методы из `toString`, поскольку при исключительных условиях это может привести к бесконечному циклу.

#### Статические методы

##### Избегайте приватных статических методов

Отдавайте предпочтение локальным функциям внутри модуля, а не приватным статическим методам, в случаях, когда это не мешает удобочитаемости.

##### Не полагайтесь на динамическую диспетчеризацию

В коде *не рекомендуется* полагаться на динамическую диспетчеризацию статических методов. Статические методы *рекомендуется* вызывать только непосредственно на базовом классе (в котором они определены). Статические методы *не рекомендуется* вызывать на переменных, содержащих динамический экземпляр, который может быть конструктором как самого класса, так и конструктором его подкласса (и *должен* быть определен с помощью `@nocollapse`[^nocollapse-tag], если он существует), а также *не должны* вызываться непосредственно на подклассе, который не определяет данный метод.

[^nocollapse-tag]: Прим. пер.: Аннотация `@nocollapse` используется в Google Closure Compiler. Подробнее с этим вы можете ознакомиться тут: [https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler#nocollapse](https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler#nocollapse)

Запрещено:

```ts
// ❌ ПЛОХО ↴

// Контекст для примеров ниже (этот класс вполне приемлем сам по себе)
class Base {
  /** @nocollapse */ static foo() {}
}
class Sub extends Base {}

// Предостережение: не вызывайте статические методы динамически
function callFoo(cls: typeof Base) {
  cls.foo();
}

// Запрещено: не вызывайте статические методы в подклассах, которые сами их не определяют
Sub.foo();

// Запрещено: не обращайтесь к `this` в статических методах
class MyClass {
  static foo() {
    return this.staticField;
  }
}
MyClass.staticField = 1;
```

##### Избегайте `this` в статическом контексте

В коде *не должен* использоваться `this` в статическом контексте.

JavaScript позволяет обращаться к статическим полям через `this`. Кроме того, в отличие от других языков, статические поля являются наследуемыми.

```ts
// ❌ ПЛОХО ↴

class ShoeStore {
  static storage: Storage = ...;

  static isAvailable(s: Shoe) {
    // Плохо: не используйте `this` в статическом методе.
    return this.storage.has(s.id);
  }
}

class EmptyShoeStore extends ShoeStore {
  static storage: Storage = EMPTY_STORE;  // переопределяет storage из ShoeStore
}
```

> Почему?
>
> Этот код может привести к неожиданностям: авторы могут не ожидать, что к статическим полям можно обращаться через указатель `this` и могут быть удивлены, обнаружив, что они могут быть переопределены — подобная функциональность используется не часто.
>
> Этот код также поощряет использование антипаттерна, заключающегося в наличии значительного статического состояния, что вызывает проблемы с тестируемостью.

#### Конструкторы

При вызове конструктора всегда *должны* использоваться скобки, даже если никакие аргументы не передаются:

```ts
// ❌ ПЛОХО ↴

const x = new Foo;
```

```ts
// ✅ ХОРОШО ↴

const x = new Foo();
```

Отсутствие скобок может привести к трудноуловимым ошибкам. Эти две строки не эквивалентны:

```ts
// ✅ ХОРОШО ↴

new Foo().Bar();
new Foo.Bar();
```

Нет необходимости предоставлять пустой конструктор или конструктор, который просто делегирует в родительский класс, поскольку ES2015 предоставляет конструктор класса по умолчанию, если он не указан. Однако *не рекомендуется* убирать конструкторы с параметризованными свойствами, модификаторами области видимости или декораторами параметров, даже если тело конструктора пустое.

```ts
// ❌ ПЛОХО ↴

class UnnecessaryConstructor {
  constructor() {}
}
```

```ts
// ❌ ПЛОХО ↴

class UnnecessaryConstructorOverride extends Base {
    constructor(value: number) {
      super(value);
    }
}
```

```ts
// ✅ ХОРОШО ↴

class DefaultConstructor {
}

class ParameterProperties {
  constructor(private myService) {}
}

class ParameterDecorators {
  constructor(@SideEffectDecorator myService) {}
}

class NoInstantiation {
  private constructor() {}
}
```

Конструктор рекомендуется отделять от окружающего кода как сверху, так и снизу одной пустой строкой:

```ts
// ✅ ХОРОШО ↴

class Foo {
  myField = 10;

  constructor(private readonly ctorParam) {}

  doThing() {
    console.log(ctorParam.getThing() + myField);
  }
}
```

```ts
// ❌ ПЛОХО ↴

class Foo {
  myField = 10;
  constructor(private readonly ctorParam) {}
  doThing() {
    console.log(ctorParam.getThing() + myField);
  }
}
```

#### Члены класса

##### Не используйте приватные поля вида `#private`

Не используйте приватные поля (также известные как приватные идентификаторы):

```ts
// ❌ ПЛОХО ↴

class Clazz {
  #ident = 1;
}
```

Вместо этого используйте поддерживаемые TypeScript аннотации видимости:

```ts
// ✅ ХОРОШО ↴

class Clazz {
  private ident = 1;
}
```

> Почему?  
> 
> Приватные идентификаторы вызывают существенные проблемы с размером и производительностью при понижении версии стандарта ECMAScript, в которую будет скомпилирован код TypeScript и не поддерживаются до ES2015. Они могут быть понижены только до уровня ES2015, но не ниже. В то же время, они не дают существенных преимуществ, когда для контроля области видимости используется статическая проверка типов.

##### Используйте модификатор `readonly`

Пометьте модификатором `readonly` те свойства, которые никогда не переназначаются вне конструктора (они не обязательно должны быть глубоко неизменяемыми).

##### Параметризованные свойства

Вместо того чтобы просто передавать очевидный инициализатор в член класса, используйте [параметризованные свойства](https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties) TypeScript.

```ts
// ❌ ПЛОХО ↴

class Foo {
  private readonly barService: BarService;

  constructor(barService: BarService) {
    this.barService = barService;
  }
}
```

```ts
// ✅ ХОРОШО ↴

class Foo {
  constructor(private readonly barService: BarService) {}
}
```

Если параметризованное свойство нуждается в документировании, то [используйте JSDoc тег `@param`](#комментарии-к-параметризованным-свойствам).

##### Инициализаторы полей

Если элемент класса не является параметризованным свойством, инициализируйте его там, где он объявлен, что иногда позволяет совсем отбросить конструктор.

```ts
// ❌ ПЛОХО ↴

class Foo {
  private readonly userList: string[];

  constructor() {
    this.userList = [];
  }
}
```

```ts
// ✅ ХОРОШО ↴

class Foo {
  private readonly userList: string[] = [];
}
```

> Совет: Свойства никогда не должны добавляться или удаляться из экземпляра после завершения работы конструктора, поскольку это существенно ограничивает возможности виртуальной машины в плане оптимизации структуры классов. Необязательные поля, которые могут быть заполнены позже, должны быть явно инициализированы значением `undefined`, чтобы предотвратить последующее изменение структуры.

##### Свойства, используемые за пределами лексической области класса

Для свойств, так или иначе задействованных вне лексической области видимости содержащего их класса, например, для свойств контроллера Angular используемых из шаблона, *не должна* использоваться приватная (`private`) область видимости, т.к. к этим свойствам потребуется доступ за пределами лексической области видимости их класса.

Для этих свойств используйте либо `protected`, либо `public`, в зависимости от того, что подходит. Для свойств используемых в шаблонах Angular и AngularJS следует использовать `protected`, а в Polymer - `public`.

В TypeScript коде *не должны* использоваться `obj['foo']` для обхода ограничения видимости свойства.

> Почему?
> 
> Когда свойство является приватным (`private`), вы объявляете автоматизированным системам и людям, что доступ к свойству ограничен методами объявленного класса, и они будут полагаться на это. Например, проверка на неиспользуемый код отметит приватное свойство, которое может посчитаться неиспользуемым, даже если какому-то коду из другого файла удастся обойти ограничение видимости.
> 
> Хотя это и кажется, что `obj['foo']` может обойти область видимости в компиляторе TypeScript, эта схема может быть нарушена путем изменения правил сборки, а также нарушается согласованность с оптимизациями.

##### Геттеры и Сеттеры

Для членов класса *возможно* иcпользовать геттеры и сеттеры, также известные как аксессоры. Методы-геттеры *должны* быть [чистыми функциями](https://en.wikipedia.org/wiki/Pure_function) (т.е. не иметь побочных эффектов и каждый раз возвращать одинаковый результат при одних и тех же параметрах, при этом геттеры не должны изменять наблюдаемое состояние). Они также полезны как средство ограничения видимости внутренних или подробных деталей реализации (показано ниже).

```ts
// ✅ ХОРОШО ↴

class Foo {
  constructor(private readonly someService: SomeService) {}

  get someMember(): string {
    return this.someService.someVariable;
  }

  set someMember(newValue: string) {
    this.someService.someVariable = newValue;
  }
}
```

```ts
// ❌ ПЛОХО ↴

class Foo {
  nextId = 0;
  get next() {
    return this.nextId++; // Плохо: геттер изменяет наблюдаемое состояние]
  }
}
```

Если аксессор используется для сокрытия свойства класса, то для скрытого свойства *возможно* указать префикс или суффикс с любым целым словом, например `internal` или `wrapped`. При использовании этих приватных свойств по возможности обращайтесь к их значению через аксессор. По крайней мере один аксессор к свойству *должен* быть нетривиальным: не определяйте сквозные аксессоры только для того, чтобы скрыть свойство. Вместо этого сделайте свойство публичным (или подумайте о том, чтобы сделать его доступным только для чтения (`readonly`), чем просто определять геттер без сеттера).

```ts
// ✅ ХОРОШО ↴

class Foo {
  private wrappedBar = '';
  get bar() {
    return this.wrappedBar || 'bar';
  }

  set bar(wrapped: string) {
    this.wrappedBar = wrapped.trim();
  }
}
```

```ts
// ❌ ПЛОХО ↴

class Bar {
  private barInternal = '';
  // Ни один из этих аксессоров не имеет логики, поэтому просто сделайте bar публичным
  get bar() {
    return this.barInternal;
  }

  set bar(value: string) {
    this.barInternal = value;
  }
}
```

Геттеры и сеттеры *не должны* задаваться с помощью `Object.defineProperty`, так как это препятствует переименованию свойств. 

##### Вычисляемые свойства

Вычисляемые свойства могут использоваться в классах только в том случае, если свойство имеет тип `symbol`. Свойства в словарном стиле (т.е. заключенные в кавычки или не являющиеся типом `symbol` в качестве ключа) не допускаются. Метод `[Symbol.iterator]` рекомендуется определять для любых классов которые логически итерируемы. В остальном, `Symbol` рекомендуется использовать умеренно.

> Совет: Будьте осторожны с использованием других встроенных свойств типа `symbol` (например `Symbol.isConcatSpreadable`), поскольку они не полифиллятся  компилятором и следовательно не будут работать в старых браузерах.

#### Видимость

Ограничение видимости свойств, методов и целых типов помогает сохранить код слабо связанным.

- Максимально ограничивайте область видимости обозначений.
- Рассмотрите возможность преобразования приватных методов в неэкспортируемые функции в том же файле, но вне какого-либо класса, а также перемещение приватных свойств в отдельные, неэкспортируемые классы.
- В TypeScript все обозначения по умолчанию публичные. Никогда не используйте модификатор `public`, за исключением случаев объявления доступных для чтения и записи (т.е. не `readonly`) публичных параметризованных свойств (в конструкторе).

```ts
// ❌ ПЛОХО ↴

class Foo {
  public bar = new Bar();  // ПЛОХО: нет необходимости в модификаторе "public"

  constructor(public readonly baz: Baz) {}  // ПЛОХО: модификатор "readonly" подразумевает, что это свойство имеет по умолчанию модификатор "public"
}
```

```ts
// ✅ ХОРОШО ↴

class Foo {
  bar = new Bar();  // ХОРОШО: нет необходимости в модификаторе "public"

  constructor(public baz: Baz) {}  // допускается модификатор "public"
}
```

См. также [Область видимости экспортируемых элементов](#область-видимости-экспортируемых-элементов).

#### Недопустимые паттерны при работе с классами

##### Не взаимодействуйте напрямую с прототипами (`prototype`)

Ключевое слово `class` позволяет создавать более понятные и читаемые определения классов, чем определение свойств в прототипах (`prototype`). В обычном прикладном коде нет необходимости манипулировать этими объектами. Миксины и модификация прототипов встроенных объектов однозначно запрещены.

**Исключение:** В коде фреймворков (например, Polymer или Angular) вполне может потребоваться использование прототипов (`prototype`) и в таком случае не рекомендуется прибегать к еще более худшим обходным путям, которые позволяют избежать этого.

### Функции

#### Терминология

Существует множество различных типов функций со своими характерными различиями между ними. В этом руководстве используется приведенная ниже терминология, которая соответствует [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions):

- "Объявление функции": объявление (т.е. не выражение) с использованием ключевого слова `function`
- "Функциональное выражение": выражение, обычно используемое в качестве значения при присваивании или передаваемое в качестве параметра, также с использованием ключевого слова `function`
- "Стрелочная функция": выражение, использующее `=>` синтаксис
- "Блочное тело функции": правая часть стрелочной функции со скобками
- "Краткое тело функции": правая часть стрелочной функции без скобок

Методы и классы/конструкторы в этом разделе не рассматриваются.

#### Для создания именованных функций предпочтительно использовать объявления функций (Function Declaration)

При определении именованных функций отдавайте предпочтение объявлениям функций, а не стрелочным функциям или функциональным выражениям.

```ts
// ✅ ХОРОШО ↴

function foo() {
  return 42;
}
```

```ts
// ❌ ПЛОХО ↴

const foo = () => 42;
```

Стрелочные функции *возможны* к использованию в тех случаях, когда например требуется явное указание типа.

```ts
// ✅ ХОРОШО ↴

interface SearchFunction {
  (source: string, subString: string): boolean;
}

const fooSearch: SearchFunction = (source, subString) => { ... };
```

#### Вложенные функции

В зависимости от ситуации, для тех функций, которые вложены в другие методы или функции, *возможно* использование объявлений функций или стрелочных функций. В частности, в теле метода предпочтительнее использовать стрелочные функции, поскольку они имеют доступ к внешнему `this`.

#### Не используйте функциональные выражения.

Не используйте функциональные выражения. Вместо этого используйте стрелочные функции.

```ts
// ✅ ХОРОШО ↴

bar(() => { this.doSomething(); })
```

```ts
// ❌ ПЛОХО ↴

bar(function() { ... })
```

**Исключение:** Функциональные выражения *возможно* использовать *только в тех случаях*, когда код должен динамически перепривязывать `this` (но это [не приветствуется](#перепривязывание-this)) или для функций-генераторов (которые не поддерживают стрелочный синтаксис).

#### Формы стрелочных функций

Используйте стрелочные функции с кратким (т.е. в виде выражения) или блочным телом функции там гдн это целесообразно.

```ts
// ✅ ХОРОШО ↴

// Для объявления функции верхнего уровня используйте Function Declarations.
function someFunction() {
  // Блочное тело функции - это хорошо
  const receipts = books.map((b: Book) => {
    const receipt = payMoney(b.price);
    recordTransaction(receipt);
    return receipt;
  });

  // Использование краткого тела функции является хорошим подходом, если возвращаемое значение будет использоваться:
  const longThings = myValues.filter(v => v.length > 1000).map(v => String(v));

  function payMoney(amount: number) {
    // Function Declarations - это хорошо, но при этом вы не должны в них обращаться к `this`. 
  }

  // Вложенные стрелочные функции могут быть назначены константе
  const computeTax = (amount: number) => amount * 0.12;
}
```

Используйте краткое тело функции только в том случае, если возвращаемое значение функции будет действительно использоваться. Блочное тело функции обеспечивает то, что возвращаемый тип является `void`, тем самым предотвращая возможные побочные эффекты.

```ts
// ❌ ПЛОХО ↴

// ПЛОХО: используйте блочное тело функции, если возвращаемое значение не используется.
myPromise.then(v => console.log(v));
// ПЛОХО: Хоть тут и есть проверка типа, это не защищает от нежелательного возврата значения.
let f: () => void;
f = () => 1;
```

```ts
// ✅ ХОРОШО ↴

// ХОРОШО: используется блочное тело функции поскольку возвращаемое значение не используется.
myPromise.then(v => {
  console.log(v);
});
// ХОРОШО: в коде могут использоваться блоки для удобочитаемости.
const transformed = [1, 2, 3].map(v => {
  const intermediate = someComplicatedExpr(v);
  const more = acrossManyLines(intermediate);
  return worthWrapping(more);
});
// ХОРОШО: явный `void` обеспечивает защиту от нежелательного возврата значения
myPromise.then(v => void console.log(v));
```

> Совет: Оператор `void` можно использовать для обеспечения гарантии того, что стрелочная функция c коротким телом функции всегда будет возвращать `undefined` для тех случаев, когда результат не планируется использовать.

#### Перепривязывание `this`

Функциональные выражения и объявления функций *не должны* использовать `this`, если только они не существуют специально для перепривязки `this`. В большинстве случаев перепривязки `this` можно избежать, используя стрелочные функции или явно заданные параметры.

```ts
// ❌ ПЛОХО ↴

function clickHandler() {
  // Плохо: что такое «this» в этом контексте?
  this.textContent = 'Hello';
}
// Плохо: `this` неявно ссылается на document.body .
document.body.onclick = clickHandler;
```

```ts
// ✅ ХОРОШО ↴

// Хорошо: явная ссылка на объект из стрелочной функции.
document.body.onclick = () => { document.body.textContent = 'hello'; };
// Альтернатива: взять явно заданный параметр
const setTextFn = (e: HTMLElement) => { e.textContent = 'hello'; };
document.body.onclick = setTextFn.bind(null, document.body);
```

Предпочтительно использовать стрелочные функции по сравнению с другими подходами к привязыванию `this`, такими как `f.bind(this)`, `goog.bind(f, this)` или `const self = this`.

#### В качестве функции обратного вызова (callback) предпочтите передавать стрелочную функцию

Обратные вызовы могут быть вызваны с непредусмотренными аргументами, которые могут пройти проверку типов, но при этом все равно приведут к логическим ошибкам.

Избегайте передачи именованной функции обратного вызова в функцию более высокого порядка, если вы не уверены в стабильности сигнатур вызовов обеих функций. Остерегайтесь, в частности, редко используемых необязательных параметров.

```ts
// ❌ ПЛОХО ↴

// ПЛОХО: Аргументы не передаются явно, что приводит к нежелательному поведению, 
// поскольку необязательный аргумент функции parseInt, задающий основание счисления,
// получает индексы массивов 0, 1 и 2.
const numbers = ['11', '5', '10'].map(parseInt);
// > [11, NaN, 2];
```

Вместо этого предпочтительно передавать стрелочную функцию, которая в свою очередь явно передает параметры в именованную функцию обратного вызова.

```ts
// ✅ ХОРОШО ↴

// ХОРОШО: Аргументы явно передаются в функцию обратного вызова
const numbers = ['11', '5', '3'].map((n) => parseInt(n));
// > [11, 5, 3]

// ХОРОШО: Функция определена локально и предназначена для использования в качестве функции обратного вызова
function dayFilter(element: string|null|undefined) {
  return element != null && element.endsWith('day');
}

const days = ['tuesday', undefined, 'juice', 'wednesday'].filter(dayFilter);
```

#### Стрелочные функции как свойства

В классах обычно *не рекомендуется* содержать свойства, которые проинициализированы как стрелочные функции. Использование стрелочных функций как свойств требует чтобы вызывающая их функция корректно понимала, что у вызываемой функции уже есть привязанный `this`, что увеличивает путаницу в понимании того, что такое `this`, а сами места вызовов и ссылки использующие эти функции могут смотреться некорректно работающими (т.к. это требует дополнительных знаний об окружении за пределами локальной области вызывающей функции, чтобы определить, что они корректны). В коде *рекомендуется* всегда использовать стрелочные функции для вызова методов экземпляра (`const handler = (x) => { this.listener(x); };`) и *не рекомендуется* получать или передавать ссылки на методы экземпляра (~~`const handler = this.listener; handler(x);`~~).

> Примечание: в некоторых специфических ситуациях, например, в случае привязки функций к шаблонам, стрелочные функции в качестве свойств полезны и создают гораздо более читабельный код. Руководствуйтесь здравым смыслом при использовании этого правила. Также см. раздел [Обработчики событий](#обработчики-событий) ниже.

```ts
// ❌ ПЛОХО ↴

class DelayHandler {
  constructor() {
    // Проблема: `this` не сохраняется в функции обратного вызова. `this` в обратном вызове
    // не будет экземпляром DelayHandler.
    setTimeout(this.patienceTracker, 5000);
  }
  private patienceTracker() {
    this.waitedPatiently = true;
  }
}
```

```ts
// ❌ ПЛОХО ↴

// Стрелочные функции обычно не рекомендуется задавать свойствам.
class DelayHandler {
  constructor() {
    // Плохо: этот код выглядит так, как будто тут забыли привязать `this`. 
    setTimeout(this.patienceTracker, 5000);
  }
  private patienceTracker = () => {
    this.waitedPatiently = true;
  }
}
```

```ts
// ✅ ХОРОШО ↴

// Явное управление `this` во время вызова.
class DelayHandler {
  constructor() {
    // По возможности используйте анонимные функции.
    setTimeout(() => {
      this.patienceTracker();
    }, 5000);
  }
  private patienceTracker() {
    this.waitedPatiently = true;
  }
}
```

#### Обработчики событий

Обработчики событий *могут* использовать стрелочные функции, когда нет необходимости удалять обработчик (например, если событие генерируется самим классом). Если для обработчика впоследствии требуется удаление, тогда правильным подходом будет использование назначенной свойству стрелочной функции, поскольку они автоматически захватывают `this` и при этом обеспечивается постоянная ссылка на обработчик для его последующего удаления.

```ts
// ✅ ХОРОШО ↴

// Обработчики событий могут быть анонимными функциями или назначенные свойствам стрелочными функциями.
class Component {
  onAttached() {
    // Событие генерируется этим классом, удалять его не нужно.
    this.addEventListener('click', () => {
      this.listener();
    });
    // this.listener это постоянная ссылка на функцию-обработчик, которую мы позже можем удалить.
    window.addEventListener('onbeforeunload', this.listener);
  }
  onDetached() {
    // Событие генерируется окном (window). Если мы не удалим функцию-обработчик (this.listener), то она
    // сохранит ссылку на `this` к которой привязана, что приведет к утечке памяти.
    window.removeEventListener('onbeforeunload', this.listener);
  }
  // Стрелочная функция, хранящаяся в свойстве, автоматически привязывается к `this`.
  private listener = () => {
    confirm('Вы хотите покинуть страницу?');
  }
}
```

Не используйте `bind` в выражениях, которые устанавливают обработчики событий, потому что это создает временную ссылку, которую нельзя удалить.

```ts
// ❌ ПЛОХО ↴

// Привязка слушателей создает временную ссылку, которая недоступна для удаления.
class Component {
  onAttached() {
    // Это создает временную ссылку, которая нам не будет доступна для удаления.
    window.addEventListener('onbeforeunload', this.listener.bind(this));
  }
  onDetached() {
    // метод bind каждый раз создает новую ссылку, поэтому эта строка не делает ничего.
    window.removeEventListener('onbeforeunload', this.listener.bind(this));
  }
  private listener() {
    confirm('Вы хотите покинуть страницу?');
  }
}
```

#### Инициализаторы параметров (значения параметров по умолчанию)

Необязательным параметрам функции может быть задано значение-инициализатор по умолчанию, который будет использоваться, когда аргумент опущен. Инициализаторы не должны иметь каких-либо заметных побочных эффектов. Инициализаторы рекомендуется делать как можно более простыми.

```ts
// ✅ ХОРОШО ↴

function process(name: string, extraContext: string[] = []) {}
function activate(index = 0) {}
```

```ts
// ❌ ПЛОХО ↴

// ПЛОХО: побочный эффект инкрементирования счетчика
let globalCounter = 0;
function newId(index = globalCounter++) {}

// ПЛОХО: раскрывает общее мутабельное состояние, что может привести к непреднамеренной связанности между вызовами функций
class Foo {
  private readonly defaultPaths: string[];
  frobnicate(paths = defaultPaths) {}
}
```

Используйте параметры по умолчанию умеренно. Предпочтительно использовать [деструктуризацию](#деструктуризация-объекта) для создания читабельных API, в случае если имеется более чем несколько необязательных параметров, которые не имеют определенного порядка расположения друг за другом.

#### Предпочтительно использовать rest-оператор и spread-оператор в случае если это вполне уместно

Используйте rest-параметр вместо доступа к переменной `arguments`. Никогда не называйте локальную переменную или параметр как `arguments`, поскольку это вносит путаницу, перекрывая встроенное имя.

```ts
// ✅ ХОРОШО ↴

function variadic(array: string[], ...numbers: number[]) {}
```

Вместо `Function.prototype.apply` используйте функционал spread-оператора.

#### Форматирование функций

Пустые строки в начале или конце тела функции не допускаются.

В отдельных случаях для создания логических групп выражений в теле функции `возможно` использование одинарной пустой строки.

В генераторах рекомендуется добавлять символ `*` к ключевым словам `function` и `yield`, т.е. `function* foo()` и `yield* iter`, а не `function *foo()` или `yield *iter`.

Скобки вокруг левой части одноаргументной стрелочной функции рекомендуются, но не обязательны.

Не ставьте пробел после `...` в синтаксисе rest-оператора или spread-оператора.

```ts
// ✅ ХОРОШО ↴

function myFunction(...elements: number[]) {}
myFunction(...array, ...iterable, ...generator());
```

#### Использование this

Используйте `this` только в конструкторах и методах классов, в функциях, в которых явно объявлен тип `this` (например, `function func(this: ThisType, ...)`), или в стрелочных функциях, определенных в той области видимости, в которой может использоваться `this`.

Никогда не используйте `this` в качестве ссылки на глобальный объект, контекст `eval`, цель события, или (если нет в этом явной необходимости) на вызываемые через методы `call()` и `apply()` функции.

```ts
// ❌ ПЛОХО ↴

this.alert('Hello');
```

### Примитивные литералы

#### Строковые литералы

##### Используйте одинарные кавычки

Обычные строковые литералы заключаются в одинарные кавычки (`'`), а не в двойные (`"`).

> Совет: если строка содержит в себе символ одинарной кавычки, рассмотрите возможность использования шаблонной строки, чтобы избежать необходимости экранирования кавычек.

##### Не используйте продолжения строк

Не используйте *продолжения строк* (то есть завершение строки внутри строкового литерала обратным слешем) ни в обычных, ни в шаблонных строковых литералах. Хотя ES5 позволяет это, это может привести к неожиданным ошибкам, если любой пробельный символ стоит после косой черты — к тому же, он является менее очевидным для читателей.

Запрещено:

```ts
// ❌ ПЛОХО ↴

const longString = 'Это очень длинная строка, которая превышает лимит в \
    80 символов. К сожалению, она содержит длинные отрезки пустого пространства, так \
    как имеются отступы для поддержания форматирования.';
```

Вместо этого напишите:

```ts
// ✅ ХОРОШО ↴

const longString = 'Это очень длинная строка, которая превышает лимит в ' +
    '80 символов. К сожалению, она содержит длинные отрезки пустого пространства, так ' +
    'как имеются отступы для поддержания форматирования.';

const SINGLE_STRING =
    'http://тут.также/допустимо_использовать_единую_длинную_строку_если_разрыв_этой_строки_затруднит_ее_обнаружение_при_поиске';
```

##### Шаблонные литералы

Используйте шаблонные литералы (разделенные `` ` ``) вместо сложной конкатенации строк, особенно если речь идет о многострочных литералах. Шаблонные литералы могут занимать несколько строк.

Если шаблонный литерал охватывает несколько строк, ему не обязательно соблюдать окружающие отступы в блоке, хотя это и можно сделать, в случае если добавленные пробелы не имеют значения.

Пример:

```ts
// ✅ ХОРОШО ↴

function arithmetic(a: number, b: number) {
  return `Это таблица с арифметическими операторами:
${a} + ${b} = ${a + b}
${a} - ${b} = ${a - b}
${a} * ${b} = ${a * b}
${a} / ${b} = ${a / b}`;
}
```

#### Числовые литералы

Числа могут быть указаны в десятичной, шестнадцатеричной, восьмеричной или двоичной форме. Используйте соответствующие префиксы `0x`, `0o` и `0b` со строчными буквами для шестнадцатеричных, восьмеричных и двоичных форм соответственно. Никогда не включайте ведущий ноль, если за ним не следуют `x`, `o` или `b`.


#### Преобразование типов

В TypeScript коде *возможно* использовать `String()` и `Boolean()` (примечание: без `new`!) функции, строковые шаблонные литералы или `!!` для преобразования типов.

```ts
// ✅ ХОРОШО ↴

const bool = Boolean(false);
const str = String(aNumber);
const bool2 = !!str;
const str2 = `result: ${bool2}`;
```

Значения перечислений (`enum`) (включая объединения перечислений и других типов) *не должны* преобразовываться в булевы значения с помощью `Boolean()` или `!!`, а должны вместо этого сравниваться явным образом с помощью операторов сравнения.

```ts
// ❌ ПЛОХО ↴

enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
let enabled = Boolean(level);

const maybeLevel: SupportLevel|undefined = ...;
enabled = !!maybeLevel;
```

```ts
// ✅ ХОРОШО ↴

enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
let enabled = level !== SupportLevel.NONE;

const maybeLevel: SupportLevel|undefined = ...;
enabled = level !== undefined && level !== SupportLevel.NONE;
```

> Почему?
>
> Для большинства задач не имеет значения, числовое или строковое значение сопоставлено с именем перечисления во время выполнения программы, поскольку значения перечислений указываются в исходном коде по имени. Следовательно, инженеры привыкли не задумываться об этом, а потому нежелательны ситуации, когда это *действительно* важно, так как они будут приводить к неожиданностям. Так происходит и в случае преобразования перечислений в булевы значения; в частности, вероятно может быть неожиданным, что по умолчанию первое объявленное значение перечисления является ложным (потому что оно равно 0), в то время как остальные значения являются истинными. Пользователи, читающие код, в котором используется значение перечисления, могут даже не знать, является ли оно первым объявленным значением или нет.

Не приветствуется для приведения к строке использовать конкатенацию строк, так как при проверке кода мы отслеживаем, чтобы операнды оператора «плюс» имели совпадающие типы.

Код *должен* использовать `Number()` для парсинга числовых значений и *должен* явно проверять его возврат на значения `NaN`, за исключением случаев, когда из контекста точно известно, что сбой парсинга невозможен.

Примечание: `Number('')`, `Number(' ')`, и `Number('\t')` могут вернуть `0` вместо `NaN`. `Number('Infinity')` и `Number('-Infinity')` могут вернуть `Infinity` и `-Infinity` соответственно. Кроме того, экспоненциальная запись, такая как `Number('1e+309')` и `Number('-1e+309')`, может привести к переполнению и преобразованию в `Infinity`. Подобные случаи могут потребовать особого обращения.

```ts
// ✅ ХОРОШО ↴

const aNumber = Number('123');
if (!isFinite(aNumber)) throw new Error(...);
```

В коде *не должен* использоваться унарный плюс (`+`) для преобразования строки в число. Парсинг чисел может привести к неудаче, иметь неожиданные исключительные ситуации и может быть признаком дурно пахнущего кода (парсинг чисел не на том уровне). Учитывая это, унарный плюс слишком легко пропустить при проверке кода.

```ts
// ❌ ПЛОХО ↴

const x = +y;
```

В коде также *не должны* использоваться `parseInt` или `parseFloat` для парсинга чисел, за исключением случаев парсинга в строках недесятичных числовых значений (см. ниже). Обе эти функции игнорируют конечные символы в строке, что может привести к возникновению ошибочного состояния (например, парсинг `12 гномов` как `12`).

```ts
// ❌ ПЛОХО ↴

const n = parseInt(someString, 10);  // Подвержено ошибкам,
const f = parseFloat(someString);    // независимо от передачи основания системы счисления.
```

Код, требующий выполнить парсинг числа с указанием системы счисления, перед вызовом `parseInt` *должен* проверить, что входные данные содержат только подходящие для этой системы счисления цифры;

```ts
// ✅ ХОРОШО ↴

if (!/^[a-fA-F0-9]+$/.test(someString)) throw new Error(...);
  // Требуется для парсинга восьмеричного числа.
// tslint:disable-next-line:ban
const n = parseInt(someString, 16);  // Допустимо только для основания числа != 10
```

Используйте `Number()`, а затем `Math.floor` или `Math.trunc` (там, где это возможно) для парсинга целых чисел:

```ts
// ✅ ХОРОШО ↴

let f = Number(someString);
if (isNaN(f)) handleError();
f = Math.floor(f);
```

##### Неявное преобразование типов

Не используйте явное булево преобразование в условиях, в которых уже имеется неявное булево преобразование. Это условия в операторах `if`, `for` и `while`.

```ts
// ❌ ПЛОХО ↴

const foo: MyInterface|null = ...;
if (!!foo) {...}
while (!!foo) {...}
```

```ts
// ✅ ХОРОШО ↴

const foo: MyInterface|null = ...;
if (foo) {...}
while (foo) {...}
```

[Как и в случае явных преобразований](#преобразование-типов), значения перечислений (включая объединения перечислений и других типов) не должны неявно приводиться к булевым значениям, а должны сравниваться явным образом с помощью операторов сравнения.

```ts
// ❌ ПЛОХО ↴

enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
if (level) {...}

const maybeLevel: SupportLevel|undefined = ...;
if (level) {...}
```

```ts
// ✅ ХОРОШО ↴

enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
if (level !== SupportLevel.NONE) {...}

const maybeLevel: SupportLevel|undefined = ...;
if (level !== undefined && level !== SupportLevel.NONE) {...}
```

Другие типы значений могут быть либо неявно преобразованы в булевы значения, либо явно сравнены с помощью операторов сравнения:

```ts
// ✅ ХОРОШО ↴

// Явное сравнение > 0 это хорошо:
if (arr.length > 0) {...}
// так же как и полагаться на неявное булево преобразование:
if (arr.length) {...}
```

### Управляющие структуры

#### Операторы управления потоком & блоки

Операторы управления потоком (`if`, `else`, `for`, `do`, `while` и т.д.) всегда используют блоки со скобками для размещения содержащегося в них кода, даже если тело состоит из одного выражения.

```ts
// ✅ ХОРОШО ↴

for (let i = 0; i < x; i++) {
  doSomethingWith(i);
}

if (x) {
  doSomethingWithALongMethodNameThatForcesANewLine(x);
}
```

```ts
// ❌ ПЛОХО ↴

if (x)
  doSomethingWithALongMethodNameThatForcesANewLine(x);

for (let i = 0; i < x; i++) doSomethingWith(i);
```

**Исключение:** *возможно* не использовать блоки если оператор `if` умещается на одной строке.

```ts
// ✅ ХОРОШО ↴

if (x) x.doFoo();
```

##### Использование присваивания в операторах управления

Предпочитайте избегать присваивания значений переменных внутри операторов управления. Присваивание легко спутать с проверкой на равенство внутри этих операторов.

```ts
// ❌ ПЛОХО ↴

if (x = someFunction()) {
  // Присваивание легко перепутать с проверкой на равенство
  // ...
}
```

```ts
// ✅ ХОРОШО ↴

x = someFunction();
if (x) {
  // ...
}
```

В тех случаях, когда присваивание внутри оператора управления более предпочтительно, заключите это присваивание в дополнительные круглые скобки, чтобы указать, что оно сделано намеренно.

```ts
// ✅ ХОРОШО ↴

while ((x = someFunction())) {
  // Двойная скобка указывает на то, что присваивание сделано намеренно
  // ...
}
```

##### Итерация по массивам

Для итерации по массивам предпочтительно использовать `for (... of someArr)`. Также приемлемо использовать `Array.prototype.forEach` или обычные циклы `for`:

```ts
// ✅ ХОРОШО ↴

for (const x of someArr) {
  // x - ссылается на значение из someArr
}

for (let i = 0; i < someArr.length; i++) {
  // Если необходим индекс, то используйте явный пересчет, а иначе используйте форму for/of.
  const x = someArr[i];
  // ...
}
for (const [i, x] of someArr.entries()) {
  // Альтернативная версия предыдущего.
}
```

Циклы `for`-`in` можно использовать только для объектов со словарными ключами. Не используйте `for (... in ...)` для итерации по массивам, т.к. это будет контринтуитивно давать индексы массива (в виде строк!), а не значения:

```ts
// ❌ ПЛОХО ↴

for (const x in someArray) {
  // x - это индекс!
}
```

В циклах `for`-`in` рекомендуется использовать `Object.prototype.hasOwnProperty` для исключения нежелательных свойств прототипа. По возможности, вместо `for`-`in` предпочтительно использовать `for`-`of` с `Object.keys`, `Object.values` или `Object.entries`.

```ts
// ✅ ХОРОШО ↴

for (const key in obj) {
  if (!obj.hasOwnProperty(key)) continue;
  doWork(key, obj[key]);
}
for (const key of Object.keys(obj)) {
  doWork(key, obj[key]);
}
for (const value of Object.values(obj)) {
  doWorkValOnly(value);
}
for (const [key, value] of Object.entries(obj)) {
  doWork(key, value);
}
```

#### Группирующие круглые скобки

Необязательные группирующие круглые скобки опускаются только в том случае, если автор кода и рецензент согласны с тем, что нет никакой разумной вероятности того, что без них код будет неправильно истолкован или что они не сделали бы код более удобочитаемым. Неразумно предполагать, что каждый кто читает код знает наизусть всю таблицу приоритета операторов.

Не используйте лишние круглые скобки вокруг всего выражения, следующего за `delete`, `typeof`, `void`, `return`, `throw`, `case`, `in`, `of` или `yield`.

#### Обработка исключений

Исключения являются важной частью языка и их рекомендуется использовать везде, где случаются исключительные ситуации.

Пользовательские исключения являются отличным способом передачи из функций дополнительной информации об ошибках. Их рекомендуется определять и использовать везде, где недостаточно встроенного типа `Error`.

Предпочтение отдается выбрасыванию исключений, а не специальным подходам к обработке ошибок (таким как передача ссылки на тип контейнера ошибки или возврат объекта со свойством ошибки).

##### Использование `new` при создании экземпляров класса `Error`

Всегда используйте `new Error()` при создании исключений вместо простого вызова `Error()`. В обоих случаях создается новый экземпляр `Error`, но использование `new` более согласуется с тем, как создаются экземпляры других объектов.

```ts
// ✅ ХОРОШО ↴

throw new Error('Foo is not a valid bar.');
```

```ts
// ❌ ПЛОХО ↴

throw Error('Foo is not a valid bar.');
```

##### При выбрасывании исключений используйте только экземпляры класса `Error` и его подклассов

JavaScript (и соответственно TypeScript) позволяет бросать исключения или отклонять промисы (`Promise`) с произвольными значениями. Однако если выброшенное значение не является экземпляром класса `Error`, то оно не получит записи трассировки стека, что затруднит отладку. Это правило распространяется и на отклоняемые значения `Promise`, поскольку `Promise.reject(obj)` эквивалентен `throw obj;` в асинхронных функциях.

```ts
// ❌ ПЛОХО ↴

// плохо: не позволяет получить трассировку стека.
throw 'ой, ошибка!';
// Для промисов
new Promise((resolve, reject) => void reject('ой, ошибка!'));
Promise.reject();
Promise.reject('ой, ошибка!');
```

Вместо этого, при выбрасывании исключений используйте только экземпляры класса (или подкласса) `Error`:

```ts
// ✅ ХОРОШО ↴

// При выбрасывании исключений используйте только экземпляры класса Error
throw new Error('ой, ошибка!');
// ... или подтипы класса Error
class MyError extends Error {}
throw new MyError('моя "ой, ошибка!"');
// Для промисов
new Promise((resolve) => resolve()); // Отсутствие отклонения - это нормально
new Promise((resolve, reject) => void reject(new Error('ой, ошибка!')));
Promise.reject(new Error('ой, ошибка!'));
```

##### Перехват и проброс исключений

В коде, при перехвате исключений, *рекомендуется* рассматривать все бросаемые исключения как экземпляры класса `Error`.

```ts
// ✅ ХОРОШО ↴

function assertIsError(e: unknown): asserts e is Error {
  if (!(e instanceof Error)) throw new Error('"e" не принадлежит классу Error');
}

try {
  doSomething();
} catch (e: unknown) {
  // Все выбрасываемые исключения должны быть подтипами класса Error. Не обрабатывайте другие
  // возможные значения, кроме случаев, когда вы точно знаете, что именно они будут выброшены.
  assertIsError(e);
  displayError(e.message);
  // или проброс:
  throw e;
}
```

Обработчики исключений *не должны* защитно обрабатывать типы, отличные от `Error`, за исключением случаев, когда достоверно известно, что вызываемый API выбрасывает исключения, не соответствующие типу `Error`, в нарушение вышеуказанного правила. В таком случае рекомендуется добавить комментарий, в котором специально указывается источник возникновения исключения, не соответствующего типу `Error`.

```ts
// ✅ ХОРОШО ↴

try {
  badApiThrowingStrings();
} catch (e: unknown) {
  // Примечание: это плохое API при выбрасывании исключения передает строку, вместо экземпляра класса Error
  if (typeof e === 'string') { ... }
}
```

> Почему?
>
> Избегайте [чрезмерно защитного программирования](https://en.wikipedia.org/wiki/Defensive_programming#Offensive_programming). Повторение одних и тех же защитных средств от проблемы, которой не будет существовать в большей части кода, приводит к появлению шаблонного кода, который не является полезным.

##### Пустой блок catch

В редчайших случаях бывает корректным ничего не делать в ответ на пойманное исключение. Когда действительно уместно не выполнять никаких действий в блоке catch, причины, по которым это оправдано, объясняются в комментарии.

```ts
// ✅ ХОРОШО ↴

try {
  return handleNumericResponse(response);
} catch (e: unknown) {
  // Ответ не является числовым. Продолжаем обрабатывать как текст.
}
return handleTextResponse(response);
```

Запрещено:

```ts
// ❌ ПЛОХО ↴

try {
  shouldFail();
  fail('ожидалась ошибка');
} catch (expected: unknown) {
}
```

#### Оператор `switch`

Каждый `switch` оператор *должен* включать в себя блок по умолчанию (`default`), даже если там не содержится кода. При этом блок `default` должен размещаться самым последним.

```ts
// ✅ ХОРОШО ↴

switch (x) {
  case Y:
    doSomethingElse();
    break;
  default:
    // ничего не делать.
}
```

В блоке `switch` каждая группа операторов завершается либо оператором `break`, либо оператором `return`, либо выбросом исключения. Непустые группы операторов (`case ...`) *не должны* проваливаться (обеспечивается настройками компилятора[^comment-no-fallthrough-cases-in-switch]):

[^comment-no-fallthrough-cases-in-switch]: Прим. пер.: В блоке оператора `switch` непустые группы операторов `case` не допускаются к проваливанию компилятором при активной опции `noFallthroughCasesInSwitch`. Подробнее вы можете ознакомиться тут: [https://www.typescriptlang.org/tsconfig#noFallthroughCasesInSwitch](https://www.typescriptlang.org/tsconfig#noFallthroughCasesInSwitch).

```ts
// ❌ ПЛОХО ↴

switch (x) {
  case X:
    doSomething();
    // дальнейший пропуск - не разрешен!
  case Y:
    // ...
}
```

Допускается пропуск пустых групп операторов:

```ts
// ✅ ХОРОШО ↴

switch (x) {
  case X:
  case Y:
    doSomething();
    break;
  default: // ничего не делать.
}
```

#### Проверка равенства

Всегда используйте тройное равенство (`===`) и неравенство (`!==`). Операторы двойного равенства вызывают склонные к ошибкам приведения типов, которые трудны для понимания и работают медленнее в реализации виртуальных машин JavaScript. Смотрите также [JavaScript таблицу равенства](https://dorey.github.io/JavaScript-Equality-Table/).

```ts
// ❌ ПЛОХО ↴

if (foo == 'bar' || baz != bam) {
  // Трудное для понимания поведение из-за преобразования типов.
}
```

```ts
// ✅ ХОРОШО ↴

if (foo === 'bar' || baz !== bam) {
  // Здесь все хорошо и понятно.
}
```

**Исключение**: При сравнении с значением `null` *возможно* использовать операторы `==` и `!=` для общего охвата `null` и `undefined` значений.

```ts
// ✅ ХОРОШО ↴

if (foo == null) {
  // Будет срабатывать, когда foo равен null или undefined. 
}
```

#### Утверждения типа (Type Assertions) и утверждения ненулевого значения (Non-nullability Assertions)

Утверждения типа (`x as SomeType`) и утверждения ненулевого значения (`y!`) не безопасны. Оба только заглушают компилятор TypeScript, но не вставляют никаких проверок во время выполнения, чтобы соответствовать этим утверждениям, поэтому они могут привести к сбою вашей программы во время выполнения.

По этой причине, вам *не рекомендуется* использовать утверждения типа и утверждения ненулевого значения без явной или объяснимой причины.

Вместо этого:

```ts
// ❌ ПЛОХО ↴

(x as Foo).foo();

y!.bar();
```

Когда вы захотите произвести утверждение типа или утверждение ненулевого значения, то лучшим решением будет написать проверку, которая будет работать во время выполнения.

```ts
// ✅ ХОРОШО ↴

// предположим, что Foo - это класс.
if (x instanceof Foo) {
  x.foo();
}

if (y) {
  y.bar();
}
```

Иногда из-за некоторых внутренних особенностей вашего кода вы можете быть уверены, что форма утверждения безопасна. В таких ситуациях *рекомендуется* добавить пояснение, объясняющее, почему вы согласны с небезопасным поведением:

```ts
// ✅ ХОРОШО ↴

// x это Foo, потому что ...
(x as Foo).foo();

// y не может быть null, потому что ...
y!.bar();
```

*Возможно* обойтись без комментариев, если очевидны причины, лежащие в основе применения утверждения типа или утверждения ненулевого значения. Например, сгенерированный код-прототип всегда допускает значение `null`, но, возможно, в контексте кода хорошо известно, что определенные поля всегда предоставляются серверной частью. В таком случае, принимайте решение руководствуясь своим профессиональным видением.

##### Синтаксис утверждения типа

Утверждения типа *должны* использовать синтаксис `as` (в отличие от синтаксиса угловых скобок). Это позволяет заключить утверждение в круглые скобки при обращении к элементу.

```ts
// ❌ ПЛОХО ↴

const x = (<Foo>z).length;
const y = <Foo>z.length;
```

```ts
// ✅ ХОРОШО ↴

// z должен быть Foo, потому что ...
const x = (z as Foo).length;
```
