# Руководство Google по стилю написания кода на языке TypeScript (перевод руководства "Google TypeScript Style Guide")

## Дополнительная информация по переводу

Репозиторий текущего перевода расположен по адресу: [https://github.com/olegbarabanov/google-typescript-style-guide-ru](https://github.com/olegbarabanov/google-typescript-style-guide-ru).

С оригинальным руководством по стилю вы можете ознакомиться по адресу: [https://google.github.io/styleguide/tsguide.html](https://google.github.io/styleguide/tsguide.html).

Перевод основан на [версии оригинального руководства от ***21.10.2023***](https://github.com/google/styleguide/blob/4d9a47834bfbadeb00a3dcf3d9808ffe49e43aeb/tsguide.html).

Хотя данный перевод и стремится быть максимально соответствующим оригинальному тексту, в текст перевода были добавлены сноски на комментарии и примечания переводчика, которые дополняют или разъясняют суть конкретного выражения. Также подобные сноски присутствуют в местах исправления *явных* ошибок, которые присутствовали в оригинале и которые могли бы ввести в заблуждение.

Если Вы нашли несоответствие, ошибку или неточность в переводе, вы можете оформить это в виде *[issue](https://github.com/olegbarabanov/google-typescript-style-guide-ru/issues)* или предложить собственное исправление в виде *[pull request](https://github.com/olegbarabanov/google-typescript-style-guide-ru/pulls)* в репозиторий проекта, либо написать переводчику по адресу [mail@olegbarabanov.ru](mailto:mail@olegbarabanov.ru).

## Введение

Данное руководство основано на внутреннем руководстве Google по стилю написания кода на языке TypeScript, но при этом оно было незначительно скорректировано с целью удаления разделов предназначенных для внутреннего пользования Google. Внутренняя среда Google предусматривает иные ограничения на TypeScript, чем те, что вы могли бы встретить за пределами Google. Приведенные здесь советы особенно полезны для людей, создающих код, который они намерены импортировать в Google, однако в других случаях они могут и не применяться в вашей внешней по отношению к Google среде.

Для этой версии руководства не существует какого-либо механизма автоматического развертывания, поскольку она предоставляется волонтерами в ответ на запросы пользователей.

### Примечание к терминологии

Данное руководство ссылается на терминологию стандарта [RFC 2119](https://tools.ietf.org/html/rfc2119) при использовании фраз *ДОЛЖЕН*, *НЕ ДОЛЖЕН*, *РЕКОМЕНДУЕТСЯ*, *НЕ РЕКОМЕНДУЕТСЯ* и *ВОЗМОЖНО* [^comment-terminology]. Термины *ПРЕДПОЧИТАТЬ* и *ИЗБЕГАТЬ* соответствуют терминам *РЕКОМЕНДУЕТСЯ* и *НЕ РЕКОМЕНДУЕТСЯ* соответственно. Императивные и декларативные высказывания носят предписывающий характер и соответствуют термину *ДОЛЖЕН*.

[^comment-terminology]: Прим. пер.: В оригинале используются термины *MUST* и *SHOULD* которые зачастую переводят буквально как *должен*. При этом MUST носит *обязательный характер*, а *SHOULD* - *рекомендательный*. Т.к. в русском языке такие термины, как: "*должен*", "*обязан*", "*стоит*", "*необходимо*" многими воспринимаются как имеющими строго обязательный характер, при буквальном переводе это может ввести в заблуждение. Поэтому для большего понимания эти термины были адаптированы как:  
    - *ДОЛЖЕН* | *НЕ ДОЛЖЕН* - носят строго обязательный характер;
    - *РЕКОМЕНДУЕТСЯ* | *НЕ РЕКОМЕНДУЕТСЯ* - являются настойчивой рекомендацией, но тем не менее не имеют обязательного характера;
    - *ВОЗМОЖНО* - обозначают допустимый вариант.

    Такая адаптация вполне совместима с оригинальным стандартом [RFC 2119](https://tools.ietf.org/html/rfc2119) и не нарушает его.

### Примечание к руководству

Все приведенные примеры **не носят нормативного характера** и служат лишь для иллюстрации стандартных формулировок из данного руководства по стилю. Т.е. хоть примеры и выполнены в стиле текущего руководства, они могут не иллюстрировать представление кода *исключительно* в этом стиле. Любые дополнительные решения в отношении форматирования кода, представленные в примерах, не должны рассматриваться в качестве правил руководства.

## Основы исходных файлов

### Кодировка файлов: UTF-8

Исходные файлы кодируются в UTF-8.

### Специальные символы

#### Пробельные символы

Помимо последовательности символов перевода строки, ASCII-символ горизонтального пробела (0x20) является единственным допустимым пробельным символом, который может появляться где-либо в исходном коде. Это также подразумевает, что в строковых литералах все прочие пробельные символы экранируются.

#### Специальные экранирующие последовательности

Для каждого символа, для которого существует специальная экранирующая последовательность (`\'`, `\"`, `\\`, `\b`, `\f`, `\n`, `\r`, `\t`, `\v`) предпочтительнее использовать именно ее вместо соответствующего числового экранирования (например, `\x0a`, `\u000a` или `\u{a}`). Устаревшие восьмеричные символы экранирования не используются.

#### Символы не из таблицы ASCII

Для остальных символов, которые не из таблицы ASCII, используйте подходящий символ Unicode (например `∞`). Для непечатаемых символов можно использовать эквивалентный шестнадцатеричный код или экранирование Unicode-символов (например `\u221e`) вместе с пояснительным комментарием.

```ts
// ✅ ХОРОШО ↴

// Совершенно ясно даже без комментария
const units = 'μs';

// Используйте Unicode-экранирование для непечатаемых символов
const output = '\ufeff' + content; // это маркер последовательности байтов (Unicode BOM)
```

```ts
// ❌ ПЛОХО ↴

// Даже с комментарием, это сложно для чтения и подвержено потенциальным ошибкам.
const units = '\u03bcs'; // Греческая буква mu, 's'

// Читающий код не поймет, что это такое
const output = '\ufeff' + content;
```

## Структура исходного файла

Исходный файл состоит из следующих **по порядку** частей:

- Информация об авторских правах, при наличии
- JSDoc с `@fileoverview`, при наличии
- Объявление импортов, при наличии
- Реализация файла

Для разделения перечисленных частей друг от друга используется **только одна пустая строка**.

### Информация об авторских правах

Если необходимо указать в файле информацию о лицензии или авторских правах, добавьте ее в JSDoc в верхней части файла[^comment-copyright-or-license-jsdoc].

[^comment-copyright-or-license-jsdoc]: Прим. пер.: В JSDoc для указания информации о лицензии используется тег `@license`, а для информации об авторских правах тег `@copyright`. 

### JSDoc тег `@fileoverview`

Файл может иметь на верхнем уровне JSDoc с тегом `@fileoverview`. При наличии, в нем может быть представлено описание содержимого файла, его применение, а также информация о его зависимостях. 

Пример[^comment-jsdoc-fileoverview]:

[^comment-jsdoc-fileoverview]: Прим. пер.: В примере комментария представлен классический условный текст-заполнитель (текст-"заглушка", текст-"рыба") ["Lorem ipsum dolor sit amet, consectetur..."](https://en.wikipedia.org/wiki/Lorem_ipsum), который не несет в себе никакой смысловой нагрузки и часто используется для простой имитации какого-либо текстового содержимого.

```ts
// ✅ ХОРОШО ↴

/**
 * @fileoverview Описание файла. Lorem ipsum dolor sit amet, consectetur
 * adipiscing elit, sed do eiusmod tempor incididunt.
 */
```

### Импорты

В ES6 и TypeScript есть четыре варианта операторов импорта:

| Вид импорта | Пример | Назначение |
| ----------- | ------ | ---------- |
| модульный | `import * as foo from '...';` | Импорты TypeScript |
| именованный (деструктурированный) | `import {SomeThing} from '...';` | Импорты TypeScript |
| по умолчанию | `import SomeThing from '...';` | Только для поддержки стороннего кода, который их требует |
| для использования побочных эффектов | `import '...';` | Только для импорта библиотек ради получения их побочных эффектов при загрузке (таких как пользовательские элементы) |

```ts
// ✅ ХОРОШО ↴

// Хорошо: выберите один из двух вариантов в зависимости от ситуации (см. ниже).
import * as ng from '@angular/core';
import {Foo} from './foo';

// Только при необходимости: импорт по умолчанию.
import Button from 'Button';

// Иногда необходимо импортировать библиотеки для получения их вспомогательных эффектов:
import 'jasmine';
import '@polymer/paper-button';
```

#### Использование путей в импортах

В TypeScript коде обязательно *должны* указываться пути при импорте другого TypeScript кода. *Возможно* указывать относительные пути, т.е. начинающиеся с `.` или `..` или с базовой директории, как например `root/path/to/file`.

В коде *рекомендуется* использовать относительные импорты (`./foo`) вместо абсолютных импортов `path/to/foo` при ссылке на файлы в пределах одного и того же (в логическом смысле) проекта, т.к. это позволяет перемещать весь проект без внесения изменений в эти импорты.

Рассмотрите возможность ограничения количества родительских шагов (`../../../`), т.к. это может затруднить понимание структуры модулей и путей.

```ts
// ✅ ХОРОШО ↴

import {Symbol1} from 'path/from/root';
import {Symbol2} from '../parent/file';
import {Symbol3} from './sibling';
```

#### Импорты пространств имен в сравнении с именованными импортами

Могут использоваться как импорты пространств имен, так и именованные импорты.

Именованные импорты предпочтительны для элементов, часто используемых в файле, а также для элементов, имеющих понятное название, как например, `describe` и `it` в Jasmine. При необходимости с помощью оператора `as` именованные импорты могут быть переименованы в более понятные названия.

Импорты пространств имен предпочтительны при использовании множества различных элементов из больших API. Импорт пространства имен, несмотря на `*`, не сопоставим с "подстановочным" (wildcard) импортом, который встречается в других языках. Вместо этого, импорт пространства имен присваивает имя всему экспорту модуля и каждый экспортируемый элемент из модуля становится свойством этого имени модуля. Импорты пространств имен могут поспособствовать удобочитаемости в случае экспортируемых элементов, которые имеют распространенные имена, наподобие `Model` или `Controller`, без необходимости объявлять для них псевдонимы.

```ts
// ❌ ПЛОХО ↴

// Плохо: слишком длинный оператор импорта с излишними пространствами имен.
import {Item as TableviewItem, Header as TableviewHeader, Row as TableviewRow,
  Model as TableviewModel, Renderer as TableviewRenderer} from './tableview';

let item: TableviewItem|undefined;
```

```ts
// ✅ ХОРОШО ↴

// Лучше: используйте модуль для пространства имен. 
import * as tableview from './tableview';

let item: tableview.Item|undefined;
```

```ts
// ❌ ПЛОХО ↴

import * as testing from './testing';

// Плохо: Имя модуля не способствует удобочитаемости.
testing.describe('foo', () => {
  testing.it('bar', () => {
    testing.expect(null).toBeNull();
    testing.expect(undefined).toBeUndefined();
  });
});
```

```ts
// ✅ ХОРОШО ↴

// Лучше: дайте локальные имена распространенным функциям.
import {describe, it, expect} from './testing';

describe('foo', () => {
  it('bar', () => {
    expect(null).toBeNull();
    expect(undefined).toBeUndefined();
  });
});
```

##### Особый случай: Приложения использующие JSPB proto-файлы

Приложения использующие JSPB proto-файлы должны использовать для них именованный импорт, даже если это приводит к возникновению длинных строк импорта[^comment-jspb-proto].

[^comment-jspb-proto]: Прим. пер.: Данный тема связана с использованием технологии Protocol Buffers (https://github.com/protocolbuffers/protobuf)

Это правило существует для повышения производительности сборки и избавления от мертвого кода, поскольку часто файлы `.proto` содержат множество "сообщений" (`message`), которые не всегда нужны все вместе. Используя деструктурированный импорт, система сборки может создавать более точную структуру зависимостей от "сообщений" JSPB в приложении их использующем, сохраняя при этом удобство импорта на основе путей.

```ts
// ✅ ХОРОШО ↴

// ХОРОШО: Импортируйте из proto-файла именно тот набор элементов, который вам нужен.
import {Foo, Bar} from './foo.proto';

function copyFooBar(foo: Foo, bar: Bar) {...}
```

#### Переименование импортов

В коде *рекомендуется* устранять возможные конфликты имен используя импорт пространств имен или переименовывая сами экспорты. При необходимости в коде *можно* переименовывать импорты (`import {SomeThing as SomeOtherThing}`).

Три примера, когда переименование может быть полезным:

1. Если необходимо избежать коллизий с другими импортируемыми элементами;
2. Если имя импортированного элемента генерируется;
3. При импорте элементов, имена которых сами по себе неясны, переименование может улучшить ясность кода. Например, при использовании RxJS функция `from` может быть более удобочитаемой, если ее переименовать в `observableFrom`.

### Экспорты

По всему коду используйте именованные экспорты:

```ts
// ✅ ХОРОШО ↴

// Использование именованного экспорта:
export class Foo { ... }
```

Не используйте экспорт по умолчанию. Это гарантирует, что все импорты будут следовать единому шаблону.

```ts
// ❌ ПЛОХО ↴

// Не используйте экспорт по умолчанию:
export default class Foo { ... } // ПЛОХО!
```

> Почему?
> 
> Экспорт по умолчанию не предоставляет канонического имени, что затрудняет централизованное обслуживание при относительно небольшой пользе для владельцев кода, причем возможно ухудшение читабельности:
> 
> ```ts
> // ❌ ПЛОХО ↴
> 
> import Foo from './bar';  // Валидно.
> import Bar from './bar';  // Также валидно.
> ```
> 
> Преимущество именованного экспорта заключается в том, что оно приводит к ошибкам, когда операторы импорта пытаются импортировать что-то, что не было объявлено. В `foo.ts`:
> 
> ```ts
> // ❌ ПЛОХО ↴
> 
> const foo = 'blah';
> export default foo;
> ```
> 
> И в `bar.ts`:
> 
> ```ts
> // ❌ ПЛОХО ↴
> 
> import {fizz} from './foo';
> ```
> 
> В результате возникает ошибка `error TS2614: Module '"./foo"' has no exported member 'fizz'`. Если указать в `bar.ts`:
> 
> ```ts
> // ❌ ПЛОХО ↴
> 
> import fizz from './foo';
> ```
> 
> В результате получается `fizz === foo`, что может быть неожиданным и затрудняющим отладку.
> 
> Кроме того, экспорт по умолчанию побуждает людей помещать все в один большой объект, чтобы разместить все вместе в пространстве имен:
> 
> ```ts
> // ❌ ПЛОХО ↴
> 
> export default class Foo {
>   static SOME_CONSTANT = ...
>   static someHelpfulFunction() { ... }
>   ...
> }
> ```
> 
> В приведенном выше примере у нас есть область видимости файла, которая может использоваться как пространство имен. У нас также есть, возможно, ненужная вторая область видимости (класс `Foo`), которая в других файлах может двусмысленно использоваться и как тип, и как значение.
> 
> Вместо этого предпочтительно использовать файловую область видимости для пространства имен, а также именованный экспорт:
> 
> ```ts
> // ✅ ХОРОШО ↴
> 
> export const SOME_CONSTANT = ...
> export function someHelpfulFunction()
> export class Foo {
>   // тут только элементы класса
> }
> ```

#### Область видимости экспортируемых элементов

TypeScript не поддерживает ограничение видимости экспортируемых элементов. Экспортируйте только те элементы, которые используются вне модуля. В целом, минимизируйте экспортируемую часть API модулей.

#### Мутабельность экспортов

Независимо от технической стороны, мутабельные экспорты могут создавать трудно понимаемый и отлаживаемый код, особенно при реэкспорте в различных модулях. Если по другому сформулировать это правило, то `export let` не допускается.

```ts
// ❌ ПЛОХО ↴

export let foo = 3;
// В чистом ES6 foo является мутабельным, и импортеры будут видеть изменение его значения уже через секунду.
// В TS (прим. пер.: в версии TS < 3.9, при использовании модулей CommonJS), если foo реэкспортируется вторым файлом,
// импортеры не увидят изменения значения.
// Прим. пер.: В версии TS >= 3.9, это будет работать по аналогии с ES6.
window.setTimeout(() => {
  foo = 4;
}, 1000 /* миллисекунды */);

```

Если необходимо поддерживать доступные извне мутабельные привязки, то вместо этого *рекомендуется* явно использовать функции-геттеры.

```ts
// ✅ ХОРОШО ↴

let foo = 3;
window.setTimeout(() => {
  foo = 4;
}, 1000 /* миллисекунды */);
// Используйте явно заданный геттер для доступа к мутабельному экспорту.
export function getFoo() { return foo; };
```

При экспорте одного из двух значений в зависимости от условий, в качестве стандартного шаблона, сначала выполняется проверка условий, а затем экспорт. Убедитесь, что все экспортируемые значения являются окончательными после выполнения всего тела модуля.

```ts
// ✅ ХОРОШО ↴

function pickApi() {
  if (useOtherApi()) return OtherApi;
  return RegularApi;
}
export const SomeApi = pickApi();
```

#### Классы-контейнеры

Не создавайте классы-контейнеры со статическими методами или свойствами ради пространства имен.

```ts
// ❌ ПЛОХО ↴

export class Container {
  static FOO = 1;
  static bar() { return 1; }
}
```

Вместо этого экспортируйте отдельные константы и функции:

```ts
// ✅ ХОРОШО ↴

export const FOO = 1;
export function bar() { return 1; }
```

### Импорт и экспорт типов

#### Импорт типа

Вы можете использовать `import type {...}` если вы используете импортируемый элемент только в качестве типа. Для значений используйте обычный импорт:

```ts
// ✅ ХОРОШО ↴

import type {Foo} from './foo';
import {Bar} from './foo';

import {type Foo, Bar} from './foo';
```

> Почему?
> 
> Компилятор TypeScript автоматически определяет различия и не внедряет динамическую (runtime) загрузку для обращений к типам. Так зачем же тогда аннотировать импорт типов?
>
> Компилятор TypeScript может работать в двух режимах:
>
> - В режиме разработки (development mode) мы обычно хотим получить быстрые итерации циклов выполнения. Компилятор транспилирует код в JavaScript без полной информации о типе. Это работает намного быстрее, запрашивая `import type` лишь в некоторых случаях.
> - В режиме эксплуатации (production mode) мы хотим обеспечить корректность. Компилятор проверяет типы для всех элементов, а также проверяет использование корректного `import type`.
>
> Совет: Если вам необходима обязательная динамическая (runtime) загрузка для получения сторонних эффектов, используйте `import '...';`. См. [импорты](#импорты).

#### Экспорт типа

Используйте `export type` при реэкспорте типа, например:

```ts
// ✅ ХОРОШО ↴

export type {AnInterface} from './foo';
```

> Почему?
>
> `export type` полезен тем, что позволяет использовать реэкспорт типов при пофайловой транспиляции. См. [документацию по `isolatedModules`](https://www.typescriptlang.org/tsconfig#exports-of-non-value-identifiers).
> 
> Также `export type` может показаться полезным, чтобы избежать какого-либо экспортирования значения элемента в API. Однако и это не дает гарантий, т.к. последующий код может по-прежнему импортировать API другим путем. Лучший способ для разделения и гарантии использования API по типу и значению - разделить элементы, например, на `UserService` и `AjaxUserService`. Это менее подвержено ошибкам и лучше передает смысл.

#### Используйте модули, а не пространства имен

TypeScript поддерживает два метода организации кода: пространства имен (*namespaces*) и модули, но использование пространств имен необходимо избегать. Т.е. ваш код *должен* ссылаться на код в других файлах с помощью импорта и экспорта вида `import {foo} from 'bar';`

В вашем коде *не должны* использоваться `namespace Foo { ... }` конструкции. Пространства имен (`namespace`) *возможно* использовать только тогда, когда это необходимо для взаимодействия с внешним сторонним кодом. Чтобы семантически разделить пространство имен вашего кода, используйте отдельные файлы.

В коде *не должны* использоваться `require` (как в `import x = require('...');`) для импортов. Используйте синтаксис модулей ES6.

```ts
// ❌ ПЛОХО ↴

// Плохо: не используйте пространства имен:
namespace Rocket {
  function launch() { ... }
}

// Плохо: не используйте <reference>
/// <reference path="..."/>

// Плохо: не используйте require()
import x = require('mydep');
```

> Примечание: В TypeScript пространства имен (`namespace`) раньше назывались внутренними модулями и использовали ключевое слово `module` в виде `module Foo { ... }`. Не используйте такую форму. Всегда используйте ES6 импорты.

## Языковые особенности

В этом разделе указывается, какие особенности можно или нельзя использовать, а также прочие ограничения на их применение.

Языковые особенности, которые не рассматриваются в данном руководстве по стилю, могут быть использованы без каких-либо рекомендаций по их применению.

### Объявление локальных переменных

#### Используйте const и let

Всегда используйте `const` или `let` для объявления переменных. По умолчанию используйте `const`, если не требуется переназначение переменной. Никогда не используйте `var`.

```ts
// ✅ ХОРОШО ↴

const foo = otherValue;  // Используйте, если "foo" никогда не меняется.
let bar = someValue;     // Используйте, если для "bar" когда-либо позднее будет присвоено значение 
```

`const` и `let` имеют блочную область видимости, как и переменные в большинстве других языков. `var` в JavaScript ограничен областью действия функции, что может вызвать трудные для понимания ошибки. Не используйте его.

```ts
// ❌ ПЛОХО ↴

var foo = someValue;     // Не используйте - область видимости var сложна и подвержена ошибкам.
```

Переменные *не должны* использоваться до их объявления.

#### При каждом обьявлении переменных задается только одна переменная

При каждом объявлении локальных переменных задается только одна переменная: т.е. такие объявления, как `let a = 1, b = 2`, не используются.

### Литералы массива

#### Не используйте конструктор `Array`

В коде *не должен* использоваться конструктор `Array()`, с или без `new`. Его применение неоднозначно и сбивает с толку:

```ts
// ❌ ПЛОХО ↴

const a = new Array(2); // [undefined, undefined]
const b = new Array(2, 3); // [2, 3];
```

Вместо этого всегда используйте скобки для инициализации массивов или `from` для инициализации `Array` с определенным размером:

```ts
// ✅ ХОРОШО ↴

const a = [2];
const b = [2, 3];

// Эквивалент для Array(2):
const c = [];
c.length = 2;

// [0, 0, 0, 0, 0]
Array.from<number>({length: 5}).fill(0);
```

#### Не определяйте свойства в массивах

Не определяйте и не используйте нечисловые свойства массива (кроме `length`). Вместо этого используйте `Map` (или `Object`).

#### Использование синтаксиса spread-оператора

Использование синтаксиса spread-оператора `[...foo]; {...bar}` является удобным сокращением для неглубокого копирования или конкатенации итерируемых структур.

```ts
// ✅ ХОРОШО ↴

const foo = [
  1,
];

const foo2 = [
  ...foo,
  6,
  7,
];

const foo3 = [
  5,
  ...foo,
];

foo2[1] === 6;
foo3[1] === 1;
```

При использовании синтаксиса spread-оператора раскладываемое значение *должно* соответствовать создаваемому. При создании массива раскладывайте только итерируемые структуры. Примитивы, включая `null` и `undefined`, *не должны* раскладываться.

```ts
// ❌ ПЛОХО ↴

const foo = [7];
const bar = [5, ...(shouldUseFoo && foo)]; // может быть undefined

// Создает {0: 'a', 1: 'b', 2: 'c'} но при этом не содержит длины (length)
const fooStrings = ['a', 'b', 'c'];
const ids = {...fooStrings};
```

```ts
// ✅ ХОРОШО ↴

const foo = shouldUseFoo ? [7] : [];
const bar = [5, ...foo];
const fooStrings = ['a', 'b', 'c'];
const ids = [...fooStrings, 'd', 'e'];
```

#### Деструктуризация массива

Литералы массивов могут использоваться в левой части присваивания для выполнения деструктуризации (например, при распаковке нескольких значений из одного массива или итерируемого элемента). В конце можно указать переменную (без пробела между `...` и именем переменной) для присвоения оставшихся элементов (прим. пер.: переменная `rest` на примере ниже). Неиспользуемые элементы следует пропускать.

```ts
// ✅ ХОРОШО ↴

const [a, b, c, ...rest] = generateResults();
let [, b,, d] = someArray;
```

Деструктуризация может также использоваться и для параметров функций. Если деструктурированный массив как параметр является необязательным, в таких случаях всегда указывайте `[]` в качестве значения по умолчанию, а в левой части указывайте значения по умолчанию:

```ts
// ✅ ХОРОШО ↴

function destructured([a = 4, b = 2] = []) { … }
```

Запрещено:

```ts
// ❌ ПЛОХО ↴

function badDestructuring([a, b] = [4, 2]) { … }
```

> Совет: Для упаковки/распаковки нескольких значений в параметр или в возврат функции (`return`) по возможности следует предпочесть деструктуризацию объекта вместо деструктуризации массива, поскольку это позволяет присваивать имена отдельным элементам и задавать для каждого из них свой тип.

### Объектные литералы

#### Не используйте конструктор `Object`

Конструктор `Object` запрещен. Вместо этого используйте объектные литералы (`{}` или `{a: 0, b: 1, c: 2}`).

#### Итерация по объектам

Итерация по объектам с помощью `for (... in ...)` подвержена вероятным ошибкам, т.к. это включает в себя все перечисляемые свойства из цепочки прототипов.

Не используйте не фильтрованные `for (... in ...)` выражения:

```ts
// ❌ ПЛОХО ↴

for (const x in someObj) {
  // x может происходить от некоторого родительского прототипа!
}
```

Либо явно отфильтруйте значения с помощью оператора `if`, либо используйте `for (... of Object.keys(...))`.

```ts
// ✅ ХОРОШО ↴

for (const x in someObj) {
  if (!someObj.hasOwnProperty(x)) continue;
  // сейчас x был точно определен в принадлежности someObj
}
for (const x of Object.keys(someObj)) { // примечание: for _of_!
  // сейчас x был точно определен в принадлежности someObj
}
for (const [key, value] of Object.entries(someObj)) { // примечание: for _of_!
  // сейчас key был точно определен в принадлежности someObj
}
```

#### Использование синтаксиса spread-оператора

Использование синтаксиса spread-оператора `[...foo]; {...bar}` является удобным сокращением для неглубокого копирования объекта. При использовании синтаксиса spread-оператора для инициализации объектов, более поздние значения заменяют более ранние с тем же ключом.

```ts
// ✅ ХОРОШО ↴

const foo = {
  num: 1,
};

const foo2 = {
  ...foo,
  num: 5,
};

const foo3 = {
  num: 5,
  ...foo,
}

foo2.num === 5;
foo3.num === 1;
```

