# Руководство Google по стилю написания кода на языке TypeScript (перевод руководства "Google TypeScript Style Guide")

## Дополнительная информация по переводу

Репозиторий текущего перевода расположен по адресу: [https://github.com/olegbarabanov/google-typescript-style-guide-ru](https://github.com/olegbarabanov/google-typescript-style-guide-ru).

С оригинальным руководством по стилю вы можете ознакомиться по адресу: [https://google.github.io/styleguide/tsguide.html](https://google.github.io/styleguide/tsguide.html).

Перевод основан на [версии оригинального руководства от ***21.10.2023***](https://github.com/google/styleguide/blob/4d9a47834bfbadeb00a3dcf3d9808ffe49e43aeb/tsguide.html).

Хотя данный перевод и стремится быть максимально соответствующим оригинальному тексту, в текст перевода были добавлены сноски на комментарии и примечания переводчика, которые дополняют или разъясняют суть конкретного выражения. Также подобные сноски присутствуют в местах исправления *явных* ошибок, которые присутствовали в оригинале и которые могли бы ввести в заблуждение.

Если Вы нашли несоответствие, ошибку или неточность в переводе, вы можете оформить это в виде *[issue](https://github.com/olegbarabanov/google-typescript-style-guide-ru/issues)* или предложить собственное исправление в виде *[pull request](https://github.com/olegbarabanov/google-typescript-style-guide-ru/pulls)* в репозиторий проекта, либо написать переводчику по адресу [mail@olegbarabanov.ru](mailto:mail@olegbarabanov.ru).

## Введение

Данное руководство основано на внутреннем руководстве Google по стилю написания кода на языке TypeScript, но при этом оно было незначительно скорректировано с целью удаления разделов предназначенных для внутреннего пользования Google. Внутренняя среда Google предусматривает иные ограничения на TypeScript, чем те, что вы могли бы встретить за пределами Google. Приведенные здесь советы особенно полезны для людей, создающих код, который они намерены импортировать в Google, однако в других случаях они могут и не применяться в вашей внешней по отношению к Google среде.

Для этой версии руководства не существует какого-либо механизма автоматического развертывания, поскольку она предоставляется волонтерами в ответ на запросы пользователей.

### Примечание к терминологии

Данное руководство ссылается на терминологию стандарта [RFC 2119](https://tools.ietf.org/html/rfc2119) при использовании фраз *ДОЛЖЕН*, *НЕ ДОЛЖЕН*, *РЕКОМЕНДУЕТСЯ*, *НЕ РЕКОМЕНДУЕТСЯ* и *ВОЗМОЖНО* [^comment-terminology]. Термины *ПРЕДПОЧИТАТЬ* и *ИЗБЕГАТЬ* соответствуют терминам *РЕКОМЕНДУЕТСЯ* и *НЕ РЕКОМЕНДУЕТСЯ* соответственно. Императивные и декларативные высказывания носят предписывающий характер и соответствуют термину *ДОЛЖЕН*.

[^comment-terminology]: Прим. пер.: В оригинале используются термины *MUST* и *SHOULD* которые зачастую переводят буквально как *должен*. При этом MUST носит *обязательный характер*, а *SHOULD* - *рекомендательный*. Т.к. в русском языке такие термины, как: "*должен*", "*обязан*", "*стоит*", "*необходимо*" многими воспринимаются как имеющими строго обязательный характер, при буквальном переводе это может ввести в заблуждение. Поэтому для большего понимания эти термины были адаптированы как:  
    - *ДОЛЖЕН* | *НЕ ДОЛЖЕН* - носят строго обязательный характер;
    - *РЕКОМЕНДУЕТСЯ* | *НЕ РЕКОМЕНДУЕТСЯ* - являются настойчивой рекомендацией, но тем не менее не имеют обязательного характера;
    - *ВОЗМОЖНО* - обозначают допустимый вариант.

    Такая адаптация вполне совместима с оригинальным стандартом [RFC 2119](https://tools.ietf.org/html/rfc2119) и не нарушает его.

### Примечание к руководству

Все приведенные примеры **не носят нормативного характера** и служат лишь для иллюстрации стандартных формулировок из данного руководства по стилю. Т.е. хоть примеры и выполнены в стиле текущего руководства, они могут не иллюстрировать представление кода *исключительно* в этом стиле. Любые дополнительные решения в отношении форматирования кода, представленные в примерах, не должны рассматриваться в качестве правил руководства.

## Основы исходных файлов

### Кодировка файлов: UTF-8

Исходные файлы кодируются в UTF-8.

### Специальные символы

#### Пробельные символы

Помимо последовательности символов перевода строки, ASCII-символ горизонтального пробела (0x20) является единственным допустимым пробельным символом, который может появляться где-либо в исходном коде. Это также подразумевает, что в строковых литералах все прочие пробельные символы экранируются.

#### Специальные экранирующие последовательности

Для каждого символа, для которого существует специальная экранирующая последовательность (`\'`, `\"`, `\\`, `\b`, `\f`, `\n`, `\r`, `\t`, `\v`) предпочтительнее использовать именно ее вместо соответствующего числового экранирования (например, `\x0a`, `\u000a` или `\u{a}`). Устаревшие восьмеричные символы экранирования не используются.

#### Символы не из таблицы ASCII

Для остальных символов, которые не из таблицы ASCII, используйте подходящий символ Unicode (например `∞`). Для непечатаемых символов можно использовать эквивалентный шестнадцатеричный код или экранирование Unicode-символов (например `\u221e`) вместе с пояснительным комментарием.

```ts
// ✅ ХОРОШО ↴

// Совершенно ясно даже без комментария
const units = 'μs';

// Используйте Unicode-экранирование для непечатаемых символов
const output = '\ufeff' + content; // это маркер последовательности байтов (Unicode BOM)
```

```ts
// ❌ ПЛОХО ↴

// Даже с комментарием, это сложно для чтения и подвержено потенциальным ошибкам.
const units = '\u03bcs'; // Греческая буква mu, 's'

// Читающий код не поймет, что это такое
const output = '\ufeff' + content;
```

## Структура исходного файла

Исходный файл состоит из следующих **по порядку** частей:

- Информация об авторских правах, при наличии
- JSDoc с `@fileoverview`, при наличии
- Объявление импортов, при наличии
- Реализация файла

Для разделения перечисленных частей друг от друга используется **только одна пустая строка**.

### Информация об авторских правах

Если необходимо указать в файле информацию о лицензии или авторских правах, добавьте ее в JSDoc в верхней части файла[^comment-copyright-or-license-jsdoc].

[^comment-copyright-or-license-jsdoc]: Прим. пер.: В JSDoc для указания информации о лицензии используется тег `@license`, а для информации об авторских правах тег `@copyright`. 

### JSDoc тег `@fileoverview`

Файл может иметь на верхнем уровне JSDoc с тегом `@fileoverview`. При наличии, в нем может быть представлено описание содержимого файла, его применение, а также информация о его зависимостях. 

Пример[^comment-jsdoc-fileoverview]:

[^comment-jsdoc-fileoverview]: Прим. пер.: В примере комментария представлен классический условный текст-заполнитель (текст-"заглушка", текст-"рыба") ["Lorem ipsum dolor sit amet, consectetur..."](https://en.wikipedia.org/wiki/Lorem_ipsum), который не несет в себе никакой смысловой нагрузки и часто используется для простой имитации какого-либо текстового содержимого.

```ts
// ✅ ХОРОШО ↴

/**
 * @fileoverview Описание файла. Lorem ipsum dolor sit amet, consectetur
 * adipiscing elit, sed do eiusmod tempor incididunt.
 */
```

### Импорты

В ES6 и TypeScript есть четыре варианта операторов импорта:

| Вид импорта | Пример | Назначение |
| ----------- | ------ | ---------- |
| модульный | `import * as foo from '...';` | Импорты TypeScript |
| именованный (деструктурированный) | `import {SomeThing} from '...';` | Импорты TypeScript |
| по умолчанию | `import SomeThing from '...';` | Только для поддержки стороннего кода, который их требует |
| для использования побочных эффектов | `import '...';` | Только для импорта библиотек ради получения их побочных эффектов при загрузке (таких как пользовательские элементы) |

```ts
// ✅ ХОРОШО ↴

// Хорошо: выберите один из двух вариантов в зависимости от ситуации (см. ниже).
import * as ng from '@angular/core';
import {Foo} from './foo';

// Только при необходимости: импорт по умолчанию.
import Button from 'Button';

// Иногда необходимо импортировать библиотеки для получения их вспомогательных эффектов:
import 'jasmine';
import '@polymer/paper-button';
```

#### Использование путей в импортах

В TypeScript коде обязательно *должны* указываться пути при импорте другого TypeScript кода. *Возможно* указывать относительные пути, т.е. начинающиеся с `.` или `..` или с базовой директории, как например `root/path/to/file`.

В коде *рекомендуется* использовать относительные импорты (`./foo`) вместо абсолютных импортов `path/to/foo` при ссылке на файлы в пределах одного и того же (в логическом смысле) проекта, т.к. это позволяет перемещать весь проект без внесения изменений в эти импорты.

Рассмотрите возможность ограничения количества родительских шагов (`../../../`), т.к. это может затруднить понимание структуры модулей и путей.

```ts
// ✅ ХОРОШО ↴

import {Symbol1} from 'path/from/root';
import {Symbol2} from '../parent/file';
import {Symbol3} from './sibling';
```

#### Импорты пространств имен в сравнении с именованными импортами

Могут использоваться как импорты пространств имен, так и именованные импорты.

Именованные импорты предпочтительны для элементов, часто используемых в файле, а также для элементов, имеющих понятное название, как например, `describe` и `it` в Jasmine. При необходимости с помощью оператора `as` именованные импорты могут быть переименованы в более понятные названия.


