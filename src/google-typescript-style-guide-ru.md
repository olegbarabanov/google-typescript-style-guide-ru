# Руководство Google по стилю написания кода на языке TypeScript (перевод руководства "Google TypeScript Style Guide")

## Дополнительная информация по переводу

Репозиторий текущего перевода расположен по адресу: [https://github.com/olegbarabanov/google-typescript-style-guide-ru](https://github.com/olegbarabanov/google-typescript-style-guide-ru).

С оригинальным руководством по стилю вы можете ознакомиться по адресу: [https://google.github.io/styleguide/tsguide.html](https://google.github.io/styleguide/tsguide.html).

Перевод основан на [версии оригинального руководства от ***21.10.2023***](https://github.com/google/styleguide/blob/4d9a47834bfbadeb00a3dcf3d9808ffe49e43aeb/tsguide.html).

Хотя данный перевод и стремится быть максимально соответствующим оригинальному тексту, в текст перевода были добавлены сноски на комментарии и примечания переводчика, которые дополняют или разъясняют суть конкретного выражения. Также подобные сноски присутствуют в местах исправления *явных* ошибок, которые присутствовали в оригинале и которые могли бы ввести в заблуждение.

Если Вы нашли несоответствие, ошибку или неточность в переводе, вы можете оформить это в виде *[issue](https://github.com/olegbarabanov/google-typescript-style-guide-ru/issues)* или предложить собственное исправление в виде *[pull request](https://github.com/olegbarabanov/google-typescript-style-guide-ru/pulls)* в репозиторий проекта, либо написать переводчику по адресу [mail@olegbarabanov.ru](mailto:mail@olegbarabanov.ru).

## Введение

Данное руководство основано на внутреннем руководстве Google по стилю написания кода на языке TypeScript, но при этом оно было незначительно скорректировано с целью удаления разделов предназначенных для внутреннего пользования Google. Внутренняя среда Google предусматривает иные ограничения на TypeScript, чем те, что вы могли бы встретить за пределами Google. Приведенные здесь советы особенно полезны для людей, создающих код, который они намерены импортировать в Google, однако в других случаях они могут и не применяться в вашей внешней по отношению к Google среде.

Для этой версии руководства не существует какого-либо механизма автоматического развертывания, поскольку она предоставляется волонтерами в ответ на запросы пользователей.

### Примечание к терминологии

Данное руководство ссылается на терминологию стандарта [RFC 2119](https://tools.ietf.org/html/rfc2119) при использовании фраз *ДОЛЖЕН*, *НЕ ДОЛЖЕН*, *РЕКОМЕНДУЕТСЯ*, *НЕ РЕКОМЕНДУЕТСЯ* и *ВОЗМОЖНО* [^comment-terminology]. Термины *ПРЕДПОЧИТАТЬ* и *ИЗБЕГАТЬ* соответствуют терминам *РЕКОМЕНДУЕТСЯ* и *НЕ РЕКОМЕНДУЕТСЯ* соответственно. Императивные и декларативные высказывания носят предписывающий характер и соответствуют термину *ДОЛЖЕН*.

[^comment-terminology]: Прим. пер.: В оригинале используются термины *MUST* и *SHOULD* которые зачастую переводят буквально как *должен*. При этом MUST носит *обязательный характер*, а *SHOULD* - *рекомендательный*. Т.к. в русском языке такие термины, как: "*должен*", "*обязан*", "*стоит*", "*необходимо*" многими воспринимаются как имеющими строго обязательный характер, при буквальном переводе это может ввести в заблуждение. Поэтому для большего понимания эти термины были адаптированы как:  
    - *ДОЛЖЕН* | *НЕ ДОЛЖЕН* - носят строго обязательный характер;
    - *РЕКОМЕНДУЕТСЯ* | *НЕ РЕКОМЕНДУЕТСЯ* - являются настойчивой рекомендацией, но тем не менее не имеют обязательного характера;
    - *ВОЗМОЖНО* - обозначают допустимый вариант.

    Такая адаптация вполне совместима с оригинальным стандартом [RFC 2119](https://tools.ietf.org/html/rfc2119) и не нарушает его.

### Примечание к руководству

Все приведенные примеры **не носят нормативного характера** и служат лишь для иллюстрации стандартных формулировок из данного руководства по стилю. Т.е. хоть примеры и выполнены в стиле текущего руководства, они могут не иллюстрировать представление кода *исключительно* в этом стиле. Любые дополнительные решения в отношении форматирования кода, представленные в примерах, не должны рассматриваться в качестве правил руководства.

## Основы исходных файлов

### Кодировка файлов: UTF-8

Исходные файлы кодируются в UTF-8.

### Специальные символы

#### Пробельные символы

Помимо последовательности символов перевода строки, ASCII-символ горизонтального пробела (0x20) является единственным допустимым пробельным символом, который может появляться где-либо в исходном коде. Это также подразумевает, что в строковых литералах все прочие пробельные символы экранируются.

#### Специальные экранирующие последовательности

Для каждого символа, для которого существует специальная экранирующая последовательность (`\'`, `\"`, `\\`, `\b`, `\f`, `\n`, `\r`, `\t`, `\v`) предпочтительнее использовать именно ее вместо соответствующего числового экранирования (например, `\x0a`, `\u000a` или `\u{a}`). Устаревшие восьмеричные символы экранирования не используются.

#### Символы не из таблицы ASCII

Для остальных символов, которые не из таблицы ASCII, используйте подходящий символ Unicode (например `∞`). Для непечатаемых символов можно использовать эквивалентный шестнадцатеричный код или экранирование Unicode-символов (например `\u221e`) вместе с пояснительным комментарием.

```ts
// ✅ ХОРОШО ↴

// Совершенно ясно даже без комментария
const units = 'μs';

// Используйте Unicode-экранирование для непечатаемых символов
const output = '\ufeff' + content; // это маркер последовательности байтов (Unicode BOM)
```

```ts
// ❌ ПЛОХО ↴

// Даже с комментарием, это сложно для чтения и подвержено потенциальным ошибкам.
const units = '\u03bcs'; // Греческая буква mu, 's'

// Читающий код не поймет, что это такое
const output = '\ufeff' + content;
```

## Структура исходного файла

Исходный файл состоит из следующих **по порядку** частей:

- Информация об авторских правах, при наличии
- JSDoc с `@fileoverview`, при наличии
- Объявление импортов, при наличии
- Реализация файла

Для разделения перечисленных частей друг от друга используется **только одна пустая строка**.

### Информация об авторских правах

Если необходимо указать в файле информацию о лицензии или авторских правах, добавьте ее в JSDoc в верхней части файла[^comment-copyright-or-license-jsdoc].

[^comment-copyright-or-license-jsdoc]: Прим. пер.: В JSDoc для указания информации о лицензии используется тег `@license`, а для информации об авторских правах тег `@copyright`. 

### JSDoc тег `@fileoverview`

Файл может иметь на верхнем уровне JSDoc с тегом `@fileoverview`. При наличии, в нем может быть представлено описание содержимого файла, его применение, а также информация о его зависимостях. 

Пример[^comment-jsdoc-fileoverview]:

[^comment-jsdoc-fileoverview]: Прим. пер.: В примере комментария представлен классический условный текст-заполнитель (текст-"заглушка", текст-"рыба") ["Lorem ipsum dolor sit amet, consectetur..."](https://en.wikipedia.org/wiki/Lorem_ipsum), который не несет в себе никакой смысловой нагрузки и часто используется для простой имитации какого-либо текстового содержимого.

```ts
// ✅ ХОРОШО ↴

/**
 * @fileoverview Описание файла. Lorem ipsum dolor sit amet, consectetur
 * adipiscing elit, sed do eiusmod tempor incididunt.
 */
```

### Импорты

В ES6 и TypeScript есть четыре варианта операторов импорта:

| Вид импорта | Пример | Назначение |
| ----------- | ------ | ---------- |
| модульный | `import * as foo from '...';` | Импорты TypeScript |
| именованный (деструктурированный) | `import {SomeThing} from '...';` | Импорты TypeScript |
| по умолчанию | `import SomeThing from '...';` | Только для поддержки стороннего кода, который их требует |
| для использования побочных эффектов | `import '...';` | Только для импорта библиотек ради получения их побочных эффектов при загрузке (таких как пользовательские элементы) |

```ts
// ✅ ХОРОШО ↴

// Хорошо: выберите один из двух вариантов в зависимости от ситуации (см. ниже).
import * as ng from '@angular/core';
import {Foo} from './foo';

// Только при необходимости: импорт по умолчанию.
import Button from 'Button';

// Иногда необходимо импортировать библиотеки для получения их вспомогательных эффектов:
import 'jasmine';
import '@polymer/paper-button';
```

#### Использование путей в импортах

В TypeScript коде обязательно *должны* указываться пути при импорте другого TypeScript кода. *Возможно* указывать относительные пути, т.е. начинающиеся с `.` или `..` или с базовой директории, как например `root/path/to/file`.

В коде *рекомендуется* использовать относительные импорты (`./foo`) вместо абсолютных импортов `path/to/foo` при ссылке на файлы в пределах одного и того же (в логическом смысле) проекта, т.к. это позволяет перемещать весь проект без внесения изменений в эти импорты.

Рассмотрите возможность ограничения количества родительских шагов (`../../../`), т.к. это может затруднить понимание структуры модулей и путей.

```ts
// ✅ ХОРОШО ↴

import {Symbol1} from 'path/from/root';
import {Symbol2} from '../parent/file';
import {Symbol3} from './sibling';
```

#### Импорты пространств имен в сравнении с именованными импортами

Могут использоваться как импорты пространств имен, так и именованные импорты.

Именованные импорты предпочтительны для элементов, часто используемых в файле, а также для элементов, имеющих понятное название, как например, `describe` и `it` в Jasmine. При необходимости с помощью оператора `as` именованные импорты могут быть переименованы в более понятные названия.

Импорты пространств имен предпочтительны при использовании множества различных элементов из больших API. Импорт пространства имен, несмотря на `*`, не сопоставим с "подстановочным" (wildcard) импортом, который встречается в других языках. Вместо этого, импорт пространства имен присваивает имя всему экспорту модуля и каждый экспортируемый элемент из модуля становится свойством этого имени модуля. Импорты пространств имен могут поспособствовать удобочитаемости в случае экспортируемых элементов, которые имеют распространенные имена, наподобие `Model` или `Controller`, без необходимости объявлять для них псевдонимы.

```ts
// ❌ ПЛОХО ↴

// Плохо: слишком длинный оператор импорта с излишними пространствами имен.
import {Item as TableviewItem, Header as TableviewHeader, Row as TableviewRow,
  Model as TableviewModel, Renderer as TableviewRenderer} from './tableview';

let item: TableviewItem|undefined;
```

```ts
// ✅ ХОРОШО ↴

// Лучше: используйте модуль для пространства имен. 
import * as tableview from './tableview';

let item: tableview.Item|undefined;
```

```ts
// ❌ ПЛОХО ↴

import * as testing from './testing';

// Плохо: Имя модуля не способствует удобочитаемости.
testing.describe('foo', () => {
  testing.it('bar', () => {
    testing.expect(null).toBeNull();
    testing.expect(undefined).toBeUndefined();
  });
});
```

```ts
// ✅ ХОРОШО ↴

// Лучше: дайте локальные имена распространенным функциям.
import {describe, it, expect} from './testing';

describe('foo', () => {
  it('bar', () => {
    expect(null).toBeNull();
    expect(undefined).toBeUndefined();
  });
});
```

##### Особый случай: Приложения использующие JSPB proto-файлы

Приложения использующие JSPB proto-файлы должны использовать для них именованный импорт, даже если это приводит к возникновению длинных строк импорта[^comment-jspb-proto].

[^comment-jspb-proto]: Прим. пер.: Данный тема связана с использованием технологии Protocol Buffers (https://github.com/protocolbuffers/protobuf)

Это правило существует для повышения производительности сборки и избавления от мертвого кода, поскольку часто файлы `.proto` содержат множество "сообщений" (`message`), которые не всегда нужны все вместе. Используя деструктурированный импорт, система сборки может создавать более точную структуру зависимостей от "сообщений" JSPB в приложении их использующем, сохраняя при этом удобство импорта на основе путей.

```ts
// ✅ ХОРОШО ↴

// ХОРОШО: Импортируйте из proto-файла именно тот набор элементов, который вам нужен.
import {Foo, Bar} from './foo.proto';

function copyFooBar(foo: Foo, bar: Bar) {...}
```

#### Переименование импортов

В коде *рекомендуется* устранять возможные конфликты имен используя импорт пространств имен или переименовывая сами экспорты. При необходимости в коде *можно* переименовывать импорты (`import {SomeThing as SomeOtherThing}`).

Три примера, когда переименование может быть полезным:

1. Если необходимо избежать коллизий с другими импортируемыми элементами;
2. Если имя импортированного элемента генерируется;
3. При импорте элементов, имена которых сами по себе неясны, переименование может улучшить ясность кода. Например, при использовании RxJS функция `from` может быть более удобочитаемой, если ее переименовать в `observableFrom`.

### Экспорты

По всему коду используйте именованные экспорты:

```ts
// ✅ ХОРОШО ↴

// Использование именованного экспорта:
export class Foo { ... }
```

Не используйте экспорт по умолчанию. Это гарантирует, что все импорты будут следовать единому шаблону.

```ts
// ❌ ПЛОХО ↴

// Не используйте экспорт по умолчанию:
export default class Foo { ... } // ПЛОХО!
```

> Почему?
> 
> Экспорт по умолчанию не предоставляет канонического имени, что затрудняет централизованное обслуживание при относительно небольшой пользе для владельцев кода, причем возможно ухудшение читабельности:
> 
> ```ts
> // ❌ ПЛОХО ↴
> 
> import Foo from './bar';  // Валидно.
> import Bar from './bar';  // Также валидно.
> ```
> 
> Преимущество именованного экспорта заключается в том, что оно приводит к ошибкам, когда операторы импорта пытаются импортировать что-то, что не было объявлено. В `foo.ts`:
> 
> ```ts
> // ❌ ПЛОХО ↴
> 
> const foo = 'blah';
> export default foo;
> ```
> 
> И в `bar.ts`:
> 
> ```ts
> // ❌ ПЛОХО ↴
> 
> import {fizz} from './foo';
> ```
> 
> В результате возникает ошибка `error TS2614: Module '"./foo"' has no exported member 'fizz'`. Если указать в `bar.ts`:
> 
> ```ts
> // ❌ ПЛОХО ↴
> 
> import fizz from './foo';
> ```
> 
> В результате получается `fizz === foo`, что может быть неожиданным и затрудняющим отладку.
> 
> Кроме того, экспорт по умолчанию побуждает людей помещать все в один большой объект, чтобы разместить все вместе в пространстве имен:
> 
> ```ts
> // ❌ ПЛОХО ↴
> 
> export default class Foo {
>   static SOME_CONSTANT = ...
>   static someHelpfulFunction() { ... }
>   ...
> }
> ```
> 
> В приведенном выше примере у нас есть область видимости файла, которая может использоваться как пространство имен. У нас также есть, возможно, ненужная вторая область видимости (класс `Foo`), которая в других файлах может двусмысленно использоваться и как тип, и как значение.
> 
> Вместо этого предпочтительно использовать файловую область видимости для пространства имен, а также именованный экспорт:
> 
> ```ts
> // ✅ ХОРОШО ↴
> 
> export const SOME_CONSTANT = ...
> export function someHelpfulFunction()
> export class Foo {
>   // тут только элементы класса
> }
> ```

#### Область видимости экспортируемых элементов

TypeScript не поддерживает ограничение видимости экспортируемых элементов. Экспортируйте только те элементы, которые используются вне модуля. В целом, минимизируйте экспортируемую часть API модулей.

#### Мутабельность экспортов

Независимо от технической стороны, мутабельные экспорты могут создавать трудно понимаемый и отлаживаемый код, особенно при реэкспорте в различных модулях. Если по другому сформулировать это правило, то `export let` не допускается.

```ts
// ❌ ПЛОХО ↴

export let foo = 3;
// В чистом ES6 foo является мутабельным, и импортеры будут видеть изменение его значения уже через секунду.
// В TS (прим. пер.: в версии TS < 3.9, при использовании модулей CommonJS), если foo реэкспортируется вторым файлом,
// импортеры не увидят изменения значения.
// Прим. пер.: В версии TS >= 3.9, это будет работать по аналогии с ES6.
window.setTimeout(() => {
  foo = 4;
}, 1000 /* миллисекунды */);

```

Если необходимо поддерживать доступные извне мутабельные привязки, то вместо этого *рекомендуется* явно использовать функции-геттеры.

```ts
// ✅ ХОРОШО ↴

let foo = 3;
window.setTimeout(() => {
  foo = 4;
}, 1000 /* миллисекунды */);
// Используйте явно заданный геттер для доступа к мутабельному экспорту.
export function getFoo() { return foo; };
```

При экспорте одного из двух значений в зависимости от условий, в качестве стандартного шаблона, сначала выполняется проверка условий, а затем экспорт. Убедитесь, что все экспортируемые значения являются окончательными после выполнения всего тела модуля.

```ts
// ✅ ХОРОШО ↴

function pickApi() {
  if (useOtherApi()) return OtherApi;
  return RegularApi;
}
export const SomeApi = pickApi();
```

#### Классы-контейнеры

Не создавайте классы-контейнеры со статическими методами или свойствами ради пространства имен.

```ts
// ❌ ПЛОХО ↴

export class Container {
  static FOO = 1;
  static bar() { return 1; }
}
```

Вместо этого экспортируйте отдельные константы и функции:

```ts
// ✅ ХОРОШО ↴

export const FOO = 1;
export function bar() { return 1; }
```

### Импорт и экспорт типов

#### Импорт типа

Вы можете использовать `import type {...}` если вы используете импортируемый элемент только в качестве типа. Для значений используйте обычный импорт:

```ts
// ✅ ХОРОШО ↴

import type {Foo} from './foo';
import {Bar} from './foo';

import {type Foo, Bar} from './foo';
```

> Почему?
> 
> Компилятор TypeScript автоматически определяет различия и не внедряет динамическую (runtime) загрузку для обращений к типам. Так зачем же тогда аннотировать импорт типов?
>
> Компилятор TypeScript может работать в двух режимах: